(* ::Package:: *)

(* ::Code::Initialization::Bold:: *)
BeginPackage["OpenRayTracer`",{"Glasses`","StockLenses`"}];


(* ::Code::Initialization::Bold:: *)
thickLensMakerEquationEFL::usage = "Calculates the effective focal lens using auss-Gullstrand formula, i.e. distance between the focal point on the image side and the principal plane on the image side";
thinLensMakerEquationEFL::usage = "Calculates focal length of a thin lens, using the Lensmaker equation";
thinLensCombinationEFL::usage = "Calculates focal length of two combined thin lenses";
thickLensBackFocalLength::usage = "Calculates the back focal lens of a thick lens (Kingslake 2010, p. 78)";
thickLensRearPrincipalPlane::usage = "Calculates the position of the rear principal plane Kingslake 2010, p. 79";
thickLensDistanceBetweenPrincipalPlanes::usage = "Calculates the distance between principal planes of a thick lens Kingslake 2010, p. 79";
getValue::usage = "getValue[index_,list_List,default_] returns the value in the list at the index poistion. If the list is too short, the dafault value is returned";
getValueFromAtomOrList::usage = "getValueFromAtomOrList[index_,values_] returns the value at the index position of vthe values argument if values is a list. If it is an atom (i.e. single element), the the whole values argument is returned";
findReflectedRayUnitVector::usage = "findReflectedRayUnitVector[incidentRayUnitVector_,normalToSurface_] finds the unit vector for the raflection of a ray with incidentRayUnitVector unit vector, hitting a surface with a normalToSurface normal";
findRefractedRayUnitVector::usage = "findRefractedRayUnitVector[incidentRayUnitVector_,normalToSurface_,n1_,n2_] uses Snell's law to calculate the unit vector describing refracted ray for a ray passing from a medium with the refractive index n1 and crossing a boundary with a medium with refractive index n2. The unit vector of the incident ray should be specified as the incidentRayUnitVector argument, while the normal to the surface between two media as the normalToSurface argument";
findRefractedRayUnitVectorUnderParaAxialApproximation::usage = "findRefractedRayUnitVectorUnderParaAxialApproximation[incidentRayUnitVector_,normalToSurface_,n1_,n2_] uses paraxial approximation to calculate the unit vector describing refracted ray for a ray passing from a medium with the refractive index n1 and crossing a boundary with a medium with refractive index n2. The equations are as in Gatland 2002, but the direction of normal to teh surface is reversed.";
findNormalToSphericalSurface2D::usage = "findNormalToSphericalSurface2D[r_,R_] returns a unit normal vector to the surface of a sphere of radius R and ceter at {0,0} (in 2 D, i.e. a circle) at the height r \n findNormalToSphericalSurface2D[\[Rho]_,R_,normalAtVertex_] returns a unit vector normal  to the surface of a sphere of radius R (in 2 D, i.e. a circle). The normal at the vertex (point on the surface most distant from its edges) of the spherical surface is specified as the normalAtVertex argument. The location of the point at which we seek the normal is specified by the parameter \[Rho], which spans the interval
between -\!\(\*FractionBox[\(R\), \(2\)]\) and \!\(\*FractionBox[\(R\), \(2\)]\)";
findNormalToSphericalSurface3D::usage = "findNormalToSphericalSurface3D[xCan_,yCan_,R_,normalAtVertex_] returns a unit vector normal to the surface of a sphere of radius R. The location of the point at which we seek the normal is specified by the parameters xCan and YCan, which can be understood as the coordinates of the point in the canonical orintation of the sphere, when its vertex was moved to {0,0,0} and the sphere was the rotated so that the normal at the vertex is {-1,0,0}.";


(* ::Code::Initialization::Bold:: *)
findNormalToAsphericalSurface2D::usage = "findNormalToAsphericalSurface2D[r_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_] returns \n ";
findNormalToAsphericalSurface3D::usage = "findNormalToAsphericalSurface3D";
findNormalToCylindricalSurface3D::usage = " findNormalToCylindricalSurface3D[\[Theta]Can_,normalAtVertex_] returns a unit vector normal to the cylindrical surface. The orientation of the cylinder is specified  by the unit vector normalAtVertex, which should be parallel to the axis of the cylinder. The point on the curved surface of a cylinder is spcified through the parameter \[Theta]Can. 
After transformation to the canonical orientation (in which the normal parallel to the axis of the cylinder is {-1,0,0}), \[Theta]Can is equal to the angle between the z axis and the shortest (i.e. perpendicular) line between the  in the canonical orientation";
createThinLens::usage = "createThinLens[vertex_?NumericQ,R1_?NumericQ,R2_?NumericQ,centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createThinLens]] creates a thin lens object, for which paraxial laws hold for every ray. 
The radii of curvature are R1 and R2, the left-most point on the lens has the z - coordinate (optical axis) equal to vertex. The lens is made of glass specified by the glass argument.";
createSphericalLens::usage = "createArbitrarySphericalLens[centralPoint_List,normalAtVertex_List,R1_?NumericQ,R2_?NumericQ,centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitrarySphericalLens]] creates a spherical lens object (thick lens), which refracts light according the full Snell's law. The radii of curvature are R1 and R2, the left-most point on the lens has the z - coordinate (optical axis) equal to vertex. The lens is made of glass specified by the glass argument. The lens is not tilted (i.e the normal at the vertex is parallel to the optical axis, being equal to {-1,0,0})";
createArbitrarySphericalLens::usage = "createArbitrarySphericalLens[centralPoint_List,normalAtVertex_List,R1_?NumericQ,R2_?NumericQ,centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitrarySphericalLens]] creates a spherical lens object (thick lens), which refracts light according the full Snell's law. The radii of curvature are R1 and R2 (can be infinite for planar faces), the left-most point on the lens has vertex of the first surface at the centralPoint position. The lens can be tilted (the normal at the vertex of the first surface is specified as the argument normalAtVertex)";
createAsphericLens::usage ="createAsphericLens[vertex_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,R2_,centerThickness_, lensDiameter_,glass_,opts:OptionsPattern[createAsphericLens]] creates an object for a lens with one face aspherical and one face spherical. The aspherical face is described by the radius R1, conical constant k and aspherical constants A4 - A16. The spherical face is descried by the radius R2, which can be infinite.";
createArbitraryAsphericPlanarLens::usage = "createArbitraryAsphericPlanarLens[centralPoint_List,normalAtVertex_List,R1_?NumericQ,k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,centerThickness_?NumericQ,lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitraryAsphericPlanarLens]] creates";
createArbitraryCementedAspherizedDoubletLens::usage ="createArbitraryCementedAspherizedDoubletLens[centralPoint_List,normalAtVertex_List,R1_?NumericQ,R2_?NumericQ,RAspheric_?NumericQ,k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,centerThicknessSpherical_?NumericQ,centerThicknessAspherical_?NumericQ, lensDiameter_?NumericQ,glass1_String,glass2_String,opts:OptionsPattern[createArbitraryCementedAspherizedDoubletLens]]";
createArbitraryPlanarScreen::usage = "createArbitraryPlanarScreen[centralPoint_List,diameter_?NumericQ,thickness_?NumericQ,normal_?List,opts:OptionsPattern[createArbitraryPlanarScreen]]";
createCircularVerticalScreen::usage = "createCircularVerticalScreen[centerPoint_List,diameter_?NumericQ]";
createCircularVerticalDiaphragm::usage = "createCircularVerticalDiaphragm[centerPoint_List,innerDiameter_?NumericQ,outerDiameter_?NumericQ]";
createPlanarCircularMirror::usage = "creates and object for a circular mirror with a planar reflective surface. The center of the reflective surface is specified by the \!\(\*
StyleBox[\"centerPoint\",\nFontSlant->\"Italic\"]\) parameter, the normal unit vector to the reflective surface by the \!\(\*
StyleBox[\"normal\",\nFontSlant->\"Italic\"]\) parameter. The parameter \!\(\*
StyleBox[\"reflectanceFunction\",\nFontSlant->\"Italic\"]\) accepts a pure function, which return a fraction of light reflected for a particular wavelength (specified in microns).";
createPlanarRectangularMirror::usage = "creates an object for a rectangular mirror with a planar reflective surface. The center of the reflective surface is specified by the \!\(\*
StyleBox[\"centerPoint\",\nFontSlant->\"Italic\"]\) parameter, the normal unit vector to the reflective surface is specified by the \!\(\*
StyleBox[\"normal\",\nFontSlant->\"Italic\"]\) parameter. The parameter \!\(\*
StyleBox[\"reflectanceFunction\",\nFontSlant->\"Italic\"]\) accepts a pure function, which return a fraction of light reflected for a particular wavelength (specified in microns).";
createPrismMirror::usage = "creates an object for triangular prism surface, with a planar reflective surface. The center of the reflective surface is specified by the \!\(\*
StyleBox[\"centerPoint\",\nFontSlant->\"Italic\"]\) parameter, the normal unit vector to the reflective surface is specified by the \!\(\*
StyleBox[\"normal\",\nFontSlant->\"Italic\"]\) parameter. The parameter \!\(\*
StyleBox[\"reflectanceFunction\",\nFontSlant->\"Italic\"]\) accepts a pure function, which return a fraction of light reflected for a particular wavelength (specified in microns).";
createDichroicCircularPlanarMirror::usage = "creates an object for a circular dichroic mirror with a planar reflective surface. The center of the reflective/transmittive surface is specified by the \!\(\*
StyleBox[\"centerPoint\",\nFontSlant->\"Italic\"]\) parameter, the normal unit vector to the surface by the \!\(\*
StyleBox[\"normal\",\nFontSlant->\"Italic\"]\) parameter. The parameters \!\(\*
StyleBox[\"reflectanceFunction\",\nFontSlant->\"Italic\"]\) and \!\(\*
StyleBox[\"transmittanceFunction\",\nFontSlant->\"Italic\"]\) accept a pure function, which return a fraction of light reflected/transmitted for a particular wavelength (specified in microns).";
createBeamSplitterCube::usage = "creates an object for a cube beam splitter. The center of the outer face of the cube which accepts radiation in the normal conditions should be specified as the \!\(\*
StyleBox[\"firstFaceCentralPoint\",\nFontSlant->\"Italic\"]\) parameter, the unit vector normal to this face as \!\(\*
StyleBox[\"normalToFirstFace\",\nFontSlant->\"Italic\"]\) parameter. The fraction of light transmitted by the cube (by. the hypotenuse face) is specified by the \!\(\*
StyleBox[\"transmittanceFunction\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)parameter, which is a pure function, accepting wavelength (in microns) as an argument";
createIntegratingSphere::usage = "creates an object for an integrating sphere.";


(* ::Code::Initialization::Bold:: *)
createBench::usage = "creates an object that stores and operates on optical components forming an optical setup.";
readInRaySet::usage = "reads in a ray file in a text format. The file should be structured as a table, with the furst line for a column headings, and the following lines of the numerical values specifying rays. The first three columns should contain the three coordinates of the ray origin, the next three the coordinates of a unit vector
descirbing the ray, while the last column should contain flux value. Such files are available for at least some of the Osram LEDs. The origin of each ray is translated by a vector specified in the \!\(\*
StyleBox[\"vertex\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)parameter, so that the ray set can be placed in a specific location with respect to optical setup.";
readInRaySetLightToolsAsciiExport::usage = "reads in a ray file in a text format from LightTools. The origin of each ray is translated by a vector specified in the \!\(\*
StyleBox[\"vertex\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)parameter, so that the ray set can be placed in a specific location with respect to optical setup.";
createRayFan::usage = "creates an object representing a 2D fan of rays from a points {sz, sy}. The ray fan contains rays which form the angle with the \!\(\*
StyleBox[\"beamDirection\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)vector that lies in the interval {-\!\(\*
StyleBox[\"beamHalfAngle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\) \!\(\*
StyleBox[\"beamHalfAngle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\), with angular specing determined by the \!\(\*
StyleBox[\"rayAngularSpacing\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)parameter. If \!\(\*
StyleBox[\"beamDirection\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)is not specified, it is assumed to be parallel to the optical axis (i.e. {1,0,0}).";
createRegularlySpacedRayFansFromNonPointSource::usage = "creates a list of ray objects, emanating from mulitple points of a source. The source is assumed to be one-dimmensional, perpendicular to the optica (z) axis. ";
createRegularlySpacedRayFansFromNonPointSource3D::usage = "creates a list of ray objects, emanating from multiple points of a source. The source is two-dimensional surface (embedded in 3D), perpendicular to the optical (z) axis.";
createCollimatedBeam2D::usage = "creates a 2D beam of collimated rays";
createCollimatedSheet::usage = "";
createCollimatedBeam3D::usage = "creates a 3D beam of collimated rays";
createRayPyramidSquareBase::usage = "creates a 3D beam, emanating from a single point, specified by the \!\(\*
StyleBox[\"origin\",\nFontSlant->\"Italic\"]\) parameter. Azimuthal and longitudinal angles corresponds to nodes of a regular, rectangular grid in the polar angle vs azimuth space.";
createRayBeamRandomEllipsoidalCrossSection::usage = "creates a 3D beam, emanating from a single point, specified by the \!\(\*
StyleBox[\"origin\",\nFontSlant->\"Italic\"]\) parameter. Azimuthal and polar angles are sampled randomly from an ellipse in the polar angle vs azimuth space. The axes of the elipse are specified by the \!\(\*
StyleBox[\"rangePolarAngle\",\nFontSlant->\"Italic\"]\) and \!\(\*
StyleBox[\"rangeAzimuth\",\nFontSlant->\"Italic\"]\) parameters.";
createRayBeamRandomRectangularCrossSection::usage = "creates a 3D beam, emanating from a single point, specified by the \!\(\*
StyleBox[\"origin\",\nFontSlant->\"Italic\"]\) parameter. Azimuthal and polar angles are sampled randomly from a rectangle in the polar angle vs azimuth space. The rectangle is determined by the \!\(\*
StyleBox[\"rangePolarAngle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)and\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"rangeAzimuth\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)parameters.";
createRayPyramidHexagonalBase::usage = "creates a 3D beam, emanating from a single point, specified by the \!\(\*
StyleBox[\"origin\",\nFontSlant->\"Italic\"]\) parameter. Azimuthal and polar angles corresponds to nodes of a regular, hexagonal grid in the polar angle vs azimuth space.";
createRaysObject::usage = "creates an object representing a bundle or rays of a particular wavelength.";


(* ::Code::Initialization::Bold:: *)
Begin["`Private`"];


(* ::Code::Initialization::Bold:: *)
(*I don't know why we need to specify separate function for releaseHold, however calling ReleaseHold directly in the code doesn't work*)releaseHold[rays_]:=ReleaseHold[rays]


(* ::Subsubsection::Bold:: *)
(*PLOTTING STYLE*)


(* ::Input::Initialization::Bold:: *)
lensSurfaceStyle=Directive[Black,AbsoluteThickness[1]];


(* ::Input::Initialization::Bold:: *)
singleRayColor=Black;


(* ::Input::Initialization::Bold:: *)
lens3DStyle=Directive[{Opacity[0.8],GrayLevel[0.4]}];


(* ::Input::Initialization::Bold:: *)
thinConvergingLensArrow=Graphics[Line[{{{-1,1/2},{0,0},{-1,-1/2}}}]];


(* ::Input::Initialization::Bold:: *)
thinDivergingLensArrow=Graphics[Line[{{{1,1/2},{0,0},{1,-1/2}}}]];


(* ::Input::Initialization::Bold:: *)
screen2DStyle=Directive[Black];


(* ::Input::Initialization::Bold:: *)
screen3DStyle=Directive[Black,Specularity[]];


(* ::Input::Initialization::Bold:: *)
rayStyleSequence={Directive[Red,Opacity[0.5]],Directive[Green,Opacity[0.5]],Directive[Blue,Opacity[0.5]],Directive[Magenta,Opacity[0.5]],Directive[Orange,Opacity[0.5]],Directive[Cyan,Opacity[0.5]],Directive[Yellow,Opacity[0.5]],Directive[Purple,Opacity[0.5]],Directive[Pink,Opacity[0.5]],Directive[Brown,Opacity[0.5]],Directive[Black,Opacity[0.5]]};


(* ::Subsubsection::Bold:: *)
(*GEOMETRIC OPTICS FORMULAS*)


(* ::Input::Initialization::Bold:: *)
(*Gauss-Gullstrand formula, distance between the focal point on the image side and the principal plane on the image side, Kingslake 2010, p. 78, Burke 1996, p. 319*)thickLensMakerEquationEFL[R1_,R2_,centerThickness_,ng_]:=Which[R1==\[Infinity]||R1==-\[Infinity],R2/(1-ng),R2==\[Infinity]||R2==-\[Infinity],R1/(-1+ng),True,(ng R1 R2)/((-1+ng) (centerThickness (-1+ng)+ng (-R1+R2)))]


(* ::Input::Initialization::Bold:: *)
(*Gross 2005, p.3 0, distance between the focal point on the image side and the principal plane on the image side, Kingslake 2010, p. 78, Burke 1996, p. 319*)thickLensMakerEquationEFL[R1_,R2_,centerThickness_,n1_,n2_]:=Which[R1==\[Infinity]||R1==-\[Infinity],(n1 R2)/(n1-n2),R2==\[Infinity]||R2==-\[Infinity],-((n1 R1)/(n1-n2)),True,(n1 n2  R1 R2)/((n2-n1) (centerThickness (n2-n1)+n2(R2-R1)))]


(* ::Input::Initialization::Bold:: *)
(**)thinLensMakerEquationEFL[R1_,R2_,ng_?NumericQ]:=Which[R1==\[Infinity]||R1==-\[Infinity],R2/(1-ng),R2==\[Infinity]||R2==-\[Infinity],R1/(-1+ng),True,( R1 R2)/((-1+ng) (R2-R1))]


(* ::Input::Initialization::Bold:: *)
(**)thinLensMakerEquationEFL[R1_,R2_,wavelengthInMicrons_,glassName_String]:=With[{ng=getGlassRefractiveIndex[wavelengthInMicrons,glassName]},thinLensMakerEquationEFL[R1,R2,ng]]


(* ::Input::Initialization::Bold:: *)
(**)thinLensCombinationEFL[f1_,f2_,d_]:=(f1*f2)/(f1+f2-d)


(* ::Input::Initialization::Bold:: *)
(*Kingslake 2010, p. 78*)thickLensBackFocalLength[R1_,R2_,centerThickness_,ng_]:=With[{EFL=thickLensMakerEquationEFL[R1,R2,centerThickness,ng]},EFL(1-(centerThickness*(ng-1))/(ng*R1))]


(* ::Input::Initialization::Bold:: *)
(*with respect to rear (i.e. image-side) vertex, Kingslake 2010, p. 79*)thickLensRearPrincipalPlane[R1_,R2_,centerThickness_,ng_]:=With[{EFL=thickLensMakerEquationEFL[R1,R2,centerThickness,ng]},-EFL((centerThickness*(ng-1))/(ng*R1))]


(* ::Input::Initialization::Bold:: *)
(*hiatus, Kingslake 2010, p. 79*)thickLensDistanceBetweenPrincipalPlanes[R1_,R2_,centerThickness_,ng_]:=((centerThickness*(ng-1))/ng)


(* ::Subsubsection::Bold:: *)
(*UTILITY FUNCTIONS*)


(* ::Input::Initialization::Bold:: *)
getValue[index_,list_List,default_]:=If[index<= Length[list],list[[index]],default];


(* ::Input::Initialization::Bold:: *)
getValueFromAtomOrList[index_,values_]:=If[AtomQ[values],values,values[[Min[index,Length[values]]]]]


(* ::Subsubsection::Bold:: *)
(*REFLECTION*)


(* ::Input::Initialization::Bold:: *)
(*Roland, Nonimaging Optics, p.8*)findReflectedRayUnitVector[incidentRayUnitVector_,normalToSurface_]:=incidentRayUnitVector-2Dot[normalToSurface,incidentRayUnitVector]*normalToSurface


(* ::Subsubsection::Bold:: *)
(*SNELL'S LAW*)


(* ::Input::Initialization::Bold:: *)
(*Miks 2012, reversed direction of normal*)findRefractedRayUnitVector[incidentRayUnitVector_,normalToSurface_,n1_,n2_]:=With[{\[Mu]=n1/n2,dotProduct =Dot[normalToSurface,incidentRayUnitVector] },With[{angle=ArcCos[-dotProduct]},If[(\[Mu]>1&&angle>ArcSin[1/\[Mu]]),Print["WARNING - TOTAL INTERNAL REFLECTION " <>" recorded angle "<>ToString[angle/Degree]<> " critical angle "<>ToString[ArcSin[1/\[Mu]]/Degree]]];With[{refractedRay=(\[Mu] * incidentRayUnitVector- normalToSurface Sqrt[1-\[Mu]^2 (1-dotProduct^2)]-\[Mu] normalToSurface*dotProduct)},refractedRay]]]


(* ::Input::Initialization::Bold:: *)
(*Gatland 2002,reversed direction of normal*)findRefractedRayUnitVectorUnderParaAxialApproximation[incidentRayUnitVector_,normalToSurface_,n1_,n2_]:=With[{v=n1*incidentRayUnitVector+(n2-n1)*(-normalToSurface)},v/Norm[v]]


(* ::Subsubsection::Bold:: *)
(*POINTS OF INTERSECTION BETWEEN A RAY AND AN OPTICAL SURFACE*)


(* ::Text::Bold:: *)
(*Kingslake 2010, p. 36*)


(* ::Input::Bold:: *)
(*(*Q'*)getEmergingRayDistanceFromVertex[I_,U_,R_,n_,nIm_]:=With[{sinIIm=n/nIm Sin[I],Q=R(Sin[I]-Sin[U])},With[{CosIIm=Sqrt[1-sinIIm^2]},With[{CosUIm=Cos[I-U]CosIIm+Sin[I-U]sinIIm},(Q (CosUIm+CosIIm))/(Cos[U]+Cos[I])]]]*)


(* ::Input::Initialization::Bold:: *)
getPointLineDistance[point_List,linePoint_List,lineUnitVector_List]:=Norm[(linePoint-point)-((linePoint-point).lineUnitVector)lineUnitVector]


(* ::Input::Initialization::Bold:: *)
findRaySphericalSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,R_,vertex_]:=With[{sol=Quiet[Solve[{r==sr+(z-sz) \[CapitalDelta]r/\[CapitalDelta]z,z==vertex+1/R*r^2/(1+Sqrt[1-r^2/R^2])},{z,r},Reals],{Solve::ratnz}]},With[{selectedSol=MinimalBy[Map[{#[[1,2]],#[[2,2]],(#[[1,2]]-sz)^2+(#[[2,2]]-sr)^2}&,sol],(*This N is necessery here, because of stupid way MinimalBy orders values*)N[Last[#]]&]},If[Length[selectedSol]>0,{selectedSol[[1,1]],selectedSol[[1,2]]},selectedSol]]]


(* ::Input::Initialization::Bold:: *)
(*quite fast, the vector {\[CapitalDelta]z,\[CapitalDelta]z,\[CapitalDelta]y} should be a unit vector*)findRaySphericalSurfaceIntersection3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R_,vertex_,(*e.g. lens diameter*)surfaceDiameter_]:=With[{v=( sx \[CapitalDelta]x+ sy \[CapitalDelta]y+ sz \[CapitalDelta]z- R \[CapitalDelta]z- vertex \[CapitalDelta]z)^2- (sx^2+sy^2+sz^2-2 R sz+2 R vertex-2 sz vertex+vertex^2) },If[v>= 0,With[{d1=- sx \[CapitalDelta]x- sy \[CapitalDelta]y+ R \[CapitalDelta]z- sz \[CapitalDelta]z+ vertex \[CapitalDelta]z-Sqrt[v]},With[{d=If[d1<0,d1+2*Sqrt[v],d1]},If[d>= 0&&(sx+d*\[CapitalDelta]x)^2+(sy+d*\[CapitalDelta]y)^2<surfaceDiameter^2/4,{sz+d*\[CapitalDelta]z,sx+d*\[CapitalDelta]x,sy+d*\[CapitalDelta]y},{}]]],{}]]


(* ::Input::Initialization::Bold:: *)
(*suitable for a general conic sorface, including oblate ellipsoidal (k >0, line joining foci is perpendicular to the optical axis), spherical (k = 0), prolate ellipsoidal (0 < k < -1),paraboloidal (-1) or hyperboloidal  (k < -1) surfaces, the vector {\[CapitalDelta]z,\[CapitalDelta]z,\[CapitalDelta]y} should be a unit vector*)findRayGeneralConicSurfaceIntersection3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R_,k_,vertex_,(*e.g. lens diameter*)surfaceDiameter_]:=With[{c=1/R},With[{v= - c (c (sx^2+sy^2+(1+k) (sz-vertex)^2)+2( vertex-sz)) (1+k \[CapitalDelta]z^2)+ (\[CapitalDelta]z-c (sx \[CapitalDelta]x+sy \[CapitalDelta]y+(1+k) (sz-vertex) \[CapitalDelta]z))^2 },If[v>= 0,With[{d1=(\[CapitalDelta]z-c (sx \[CapitalDelta]x+sy \[CapitalDelta]y+(1+k) (sz-vertex) \[CapitalDelta]z)-Sqrt[v])/(c(1+ k \[CapitalDelta]z^2))},With[{d=If[d1<0,d1+(2*Sqrt[v])/(c(1+ k \[CapitalDelta]z^2)),d1]},If[d>= 0&&(sx+d*\[CapitalDelta]x)^2+(sy+d*\[CapitalDelta]y)^2<surfaceDiameter^2/4,{sz+d*\[CapitalDelta]z,sx+d*\[CapitalDelta]x,sy+d*\[CapitalDelta]y},{}]]],{}]]]


(* ::Input::Initialization::Bold:: *)
(*returns list of pairs {positive d scalar factor, normal at intersection point}, for which the vectors hits the surface within the lens diameter, i.e. it not necessary to check whether the ray actually hit the surface*)findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,R_,lensDiameter_,centralPoint_,normalAtVertex_,(*needs to be relatively high value, to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=(**)If[Abs[R]!=Infinity,With[{vertex=centralPoint[[1]],shiftY=centralPoint[[2]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]]},With[{rMin=-(lensDiameter/2)+shiftY,rMax=lensDiameter/2+shiftY},With[{sol=Quiet[Solve[{sz+d \[CapitalDelta]z==-normal1 (R-R Sqrt[1-(r-shiftY)^2/R^2])+ normal2 (r-shiftY)+vertex,sr+d \[CapitalDelta]r==-normal2 (R-R Sqrt[1- (r-shiftY)^2/R^2])- normal1 (r-shiftY)+shiftY},{d,r},Reals],{Solve::ratnz}]},Map[ {#[[1]],With[{normalInCanonicalDirection=findNormalToSphericalSurface2D[#[[2]]-shiftY,R,normalAtVertex]},If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]r},normalInCanonicalDirection]<\[Pi]/2,-normalInCanonicalDirection,normalInCanonicalDirection]]}&,Sort[Select[Map[{#[[1,2]],#[[2,2]]}&,sol],(#[[1]]> tolerance&&(#[[2]]>= rMin&&#[[2]]<= rMax)&)],(#1[[1]]<#2[[1]]&)]]]]],findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,lensDiameter,centralPoint,normalAtVertex,(*needs to be relatively high value if it is necessary to prevent spurious cross sections when ray emerges from the surface*)tolerance]]


(* ::Input::Initialization::Bold:: *)
(*canonical position is teh r coordinate in the interval [-lensDiameter/2,lensDiameter/2]*)getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][\[Rho]_,R1_,centralPoint_,normalAtVertex_]:=With[{vertex=centralPoint[[1]],shiftY=centralPoint[[2]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]]},If[Abs[R1]!= \[Infinity],{-normal1 (R1-R1 Sqrt[1- (\[Rho]^2)/R1^2])+ normal2 \[Rho]+vertex,-normal2 (R1-R1 Sqrt[1- (\[Rho]^2)/R1^2])- normal1 \[Rho]+shiftY},{vertex+normal2 \[Rho],shiftY-normal1 \[Rho]}]]


(* ::Input::Initialization::Bold:: *)
findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R1_,lensDiameter_,centralPoint_,normalAtVertex_,(*needs to be relatively high value when there is a need to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=(**)With[{vertex=centralPoint[[1]],shiftX=centralPoint[[2]],shiftY=centralPoint[[3]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]],normal3=normalAtVertex[[3]]},With[(*zCan, xCan, yCan are coordinates in the canonical orientation of the lens, i.e. with the normal {-1,0,0}, and the vertex {0,0,0}*){sol=Quiet[Solve[If[Abs[normal2^2+normal3^2]<10^-12,With[{zCan=With[{r2=(xCan)^2+(yCan)^2},1/R1*r2/(1+Sqrt[1-r2/R1^2])]},{sz+d \[CapitalDelta]z==vertex-normal1 zCan,sx+d \[CapitalDelta]x==shiftX-normal1 xCan,sy+d \[CapitalDelta]y==shiftY+yCan}],With[{zCan=With[{r2=(xCan)^2+(yCan)^2},1/R1*r2/(1+Sqrt[1-r2/R1^2])]},{sz+d \[CapitalDelta]z==normal2 xCan+normal3 yCan-normal1 zCan+vertex,sx+d \[CapitalDelta]x==((-normal1 normal2^2+normal3^2) xCan-(1+normal1) normal2 normal3 yCan)/(normal2^2+normal3^2)-normal2 zCan+shiftX,sy+d \[CapitalDelta]y==(-(1+normal1) normal2 normal3 xCan+normal2^2 yCan-normal1 normal3^2 yCan)/(normal2^2+normal3^2)-normal3 zCan+shiftY}]],{d,xCan,yCan},Reals],{Solve::ratnz}]},Map[{#[[1]],With[{normalInCanonicalDirection=findNormalToSphericalSurface3D[#[[2]],#[[3]],R1,normalAtVertex]},If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},normalInCanonicalDirection]<\[Pi]/2,-normalInCanonicalDirection,normalInCanonicalDirection]]}&,Sort[Select[Map[{#[[1,2]],#[[2,2]],#[[3,2]]}&,sol],(#[[1]]>= tolerance&&Sqrt[(#[[2]]^2+#[[3]]^2)]<= lensDiameter/2&)],(#1[[1]]<#2[[1]]&)]]]]


(* ::Input::Initialization::Bold:: *)
findRayAsphericalSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,R_,k_,ACoefficients_List,vertex_]:=findRayAsphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R,k,getValue[1,ACoefficients,0],getValue[2,ACoefficients,0],getValue[3,ACoefficients,0],getValue[4,ACoefficients,0],getValue[5,ACoefficients,0],getValue[6,ACoefficients,0],getValue[7,ACoefficients,0],vertex]


(* ::Input::Initialization::Bold:: *)
findRayAsphericalSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_]:=With[{sol=Quiet[Solve[{r==sr+(z-sz) \[CapitalDelta]r/\[CapitalDelta]z,z==vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8+A10*r^10+A12*r^12+A14*r^14+A16*r^16},{z,r},Reals],{Solve::ratnz}]},With[{selectedSol=MinimalBy[Map[{#[[1,2]],#[[2,2]],(#[[1,2]]-sz)^2+(#[[2,2]]-sr)^2}&,sol],(*This N is necessery here, because of stupid way MinimalBy orders values*)N[Last[#]]&]},If[Length[selectedSol]>0,{selectedSol[[1,1]],selectedSol[[1,2]]},selectedSol]]]


(* ::Input::Initialization::Bold:: *)
(*returns list of pairs {positive d scalar factor, normal at intersection point}, for which the vectors hits the surface within the lens diameter, i.e. it not necessary to check whether the ray actually hit the surface*)findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,centralPoint_,normalAtVertex_,(*needs to be relatively high value when there is a need to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=(**)With[{vertex=centralPoint[[1]],shiftY=centralPoint[[2]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]]},With[{rMin=-(lensDiameter/2)+shiftY,rMax=lensDiameter/2+shiftY},With[{sol=Quiet[Solve[{sz+d \[CapitalDelta]z==1/(1+k)  (-normal1 (R1-R1 Sqrt[1-((1+k) (r-shiftY)^2)/R1^2]+(1+k) (A4+(A6+A8 (r-shiftY)^2+A10 (r-shiftY)^4+A12 (r-shiftY)^6+(A14+A16 (r-shiftY)^2) (r-shiftY)^8) (r-shiftY)^2) (r-shiftY)^4)+(1+k) normal2 (r-shiftY))+vertex,sr+d \[CapitalDelta]r==1/(1+k)  (-normal2 (R1-R1 Sqrt[1-((1+k) (r-shiftY)^2)/R1^2]+(1+k) (A4+(A6+A8 (r-shiftY)^2+A10 (r-shiftY)^4+A12 (r-shiftY)^6+(A14+A16 (r-shiftY)^2) (r-shiftY)^8) (r-shiftY)^2) (r-shiftY)^4)-(1+k) normal1 (r-shiftY))+shiftY},{d,r},Reals],{Solve::ratnz}]},Map[{#[[1]],With[{normalInCanonicalDirection=findNormalToAsphericalSurface2D[#[[2]]-shiftY,R1,k,A4,A6,A8,A10,A12,A14,A16,normalAtVertex]},If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]r},normalInCanonicalDirection]<\[Pi]/2,-normalInCanonicalDirection,normalInCanonicalDirection]]}&,Sort[Select[Map[{#[[1,2]],#[[2,2]]}&,sol],(#[[1]]> tolerance&&(#[[2]]>= rMin&&#[[2]]<= rMax)&)],(#1[[1]]<#2[[1]]&)]]]]]


(* ::Input::Initialization::Bold:: *)
getAsphericalSurfaceCoordinatesAsFunctionOfCanonicalPosition\[Rho][\[Rho]_,R1_,k_,AsphericCoefficients_List,centralPoint_,normalAtVertex_]:=getAsphericalSurfaceCoordinatesAsFunctionOfCanonicalPosition\[Rho][\[Rho],R1,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],centralPoint,normalAtVertex]


(* ::Input::Initialization::Bold:: *)
getAsphericalSurfaceCoordinatesAsFunctionOfCanonicalPosition\[Rho][\[Rho]_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centralPoint_,normalAtVertex_]:=With[{vertex=centralPoint[[1]],shiftY=centralPoint[[2]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]]},{(-normal1 (R1-R1 Sqrt[1-((1+k) \[Rho]^2)/R1^2]+(1+k) (A4+(A6+A8 \[Rho]^2+A10 \[Rho]^4+A12 \[Rho]^6+(A14+A16 \[Rho]^2) \[Rho]^8) \[Rho]^2) \[Rho]^4)+(1+k) normal2 \[Rho])/(1+k) +vertex,(-normal2 (R1-R1 Sqrt[1-((1+k) \[Rho]^2)/R1^2]+(1+k) (A4+(A6+A8 \[Rho]^2+A10 \[Rho]^4+A12 \[Rho]^6+(A14+A16 \[Rho]^2) \[Rho]^8) \[Rho]^2) \[Rho]^4)-(1+k) normal1 \[Rho])/(1+k) +shiftY}]


(* ::Input::Initialization::Bold:: *)
getAsphericalSag[r_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_]:=With[{rSquared=r^2},1/R*rSquared/(1+Sqrt[1-(1+k) rSquared/R^2])+A4*rSquared^2+A6*rSquared^3+A8*rSquared^4+A10*rSquared^5+A12*rSquared^6+A14*rSquared^7+A16*rSquared^8]


(* ::Input::Initialization::Bold:: *)
getSphericalSag[r_,R_]:=With[{rSquared=r^2},1/R*rSquared/(1+Sqrt[1-rSquared/R^2])]


(* ::Input::Initialization::Bold:: *)
(*much faster with NSolve than with Solve*)findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,centralPoint_,normalAtVertex_,(*needs to be relatively high value when there is a need to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=(**)With[{vertex=centralPoint[[1]],shiftX=centralPoint[[2]],shiftY=centralPoint[[3]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]],normal3=normalAtVertex[[3]]},With[(*zCan, xCan, yCan are coordinates in the canonical orientation of the lens, i.e. with the normal {-1,0,0}, and the vertex {0,0,0}*){sol=Quiet[If[Abs[normal2^2+normal3^2]<= 10^-12,NSolve[With[{zCan=With[{r2=(xCan)^2+(yCan)^2},1/R1*r2/(1+Sqrt[1-(1+k) r2/R1^2])+A4*r2^2+A6*r2^3+A8*r2^4+A10*r2^5+A12*r2^6+A14*r2^7+A16*r2^8]},{sz+d \[CapitalDelta]z==vertex-normal1 zCan,sx+d \[CapitalDelta]x==shiftX-normal1 xCan,sy+d \[CapitalDelta]y==shiftY+yCan}],{d,xCan,yCan},Reals,WorkingPrecision->25],NSolve[With[{zCan=With[{r2=(xCan)^2+(yCan)^2},1/R1*r2/(1+Sqrt[1-(1+k) r2/R1^2])+A4*r2^2+A6*r2^3+A8*r2^4+A10*r2^5+A12*r2^6+A14*r2^7+A16*r2^8]},{sz+d \[CapitalDelta]z==normal2 xCan+normal3 yCan-normal1 zCan+vertex,sx+d \[CapitalDelta]x==((-normal1 normal2^2+normal3^2) xCan-(1+normal1) normal2 normal3 yCan)/(normal2^2+normal3^2)-normal2 zCan+shiftX,sy+d \[CapitalDelta]y==(-(1+normal1) normal2 normal3 xCan+normal2^2 yCan-normal1 normal3^2 yCan)/(normal2^2+normal3^2)-normal3 zCan+shiftY}],{d,xCan,yCan},Reals,WorkingPrecision->25]],{NSolve::precw}]},Map[{#[[1]],With[{normalInCanonicalDirection=findNormalToAsphericalSurface3D[#[[2]],#[[3]],R1,k,A4,A6,A8,A10,A12,A14,A16,normalAtVertex]},If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},normalInCanonicalDirection]<\[Pi]/2,-normalInCanonicalDirection,normalInCanonicalDirection]]}&,Sort[Select[Map[{#[[1,2]],#[[2,2]],#[[3,2]]}&,sol],(#[[1]]>= tolerance&&Sqrt[(#[[2]]^2+#[[3]]^2)]<= lensDiameter/2&)],(#1[[1]]<#2[[1]]&)]]]]


(* ::Input::Initialization::Bold:: *)
getPlanarSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][\[Rho]_,centralPoint_,normalAtVertex_]:=With[{vertex=centralPoint[[1]],shiftY=centralPoint[[2]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]]},{normal2 \[Rho]+vertex,shiftY-normal1 \[Rho]}]


(* ::Input::Initialization::Bold:: *)
findPositiveScalarFactorsAndNormalsAtIncidenceRayPlanarSurfaceIntersectionArbitraryElement[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,centralPoint_,normalAtVertex_,isInside_Function]:=findPositiveScalarFactorsAndNormalsAtIncidenceRayPlanarSurfaceIntersectionArbitraryElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,centralPoint,normalAtVertex,isInside,0]


(* ::Input::Initialization::Bold:: *)
(*returns list of pairs {positive d scalar factor, normal at intersection point}, for which the vectors hits the surface within the lens diameter, i.e. it not necessary to check whether the ray actually hit the surface*)findPositiveScalarFactorsAndNormalsAtIncidenceRayPlanarSurfaceIntersectionArbitraryElement[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,centralPoint_,normalAtVertex_,(*function of the r coordinate, returns true when  the point (0,rCan) is inside the element in its canonical orientation, i.e. with normal at vertex {-1,0} at the central point is (0,0) *)isInside_Function,(*needs to be relatively high value if it is necessary to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=With[{vertex=centralPoint[[1]],shiftY=centralPoint[[2]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]]},With[{sol=If[Abs[normal2 \[CapitalDelta]r+normal1 \[CapitalDelta]z]<= 10^-15,{},If[Abs[\[CapitalDelta]z]<= 10^-15,{(*d*)(normal2 shiftY-normal2 sr-normal1 sz+normal1 vertex)/(normal2 \[CapitalDelta]r),(normal2 shiftY \[CapitalDelta]r+sz \[CapitalDelta]r-vertex \[CapitalDelta]r)/(normal2 \[CapitalDelta]r)-shiftY},{(-normal2 shiftY-sz+vertex+(normal2 (normal2 shiftY \[CapitalDelta]r+sz \[CapitalDelta]r-vertex \[CapitalDelta]r+shiftY \[CapitalDelta]z+normal1 shiftY \[CapitalDelta]z-sr \[CapitalDelta]z))/(normal2 \[CapitalDelta]r+normal1 \[CapitalDelta]z))/\[CapitalDelta]z,(normal2 shiftY \[CapitalDelta]r+sz \[CapitalDelta]r-vertex \[CapitalDelta]r+shiftY \[CapitalDelta]z+normal1 shiftY \[CapitalDelta]z-sr \[CapitalDelta]z)/(normal2 \[CapitalDelta]r+normal1 \[CapitalDelta]z)-shiftY}]]},If[Length[sol]>= 2&&sol[[1]]> tolerance&&(isInside[sol[[2]]]),{{sol[[1]],If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]r},normalAtVertex]<\[Pi]/2,-normalAtVertex,normalAtVertex]}},{}]]]


(* ::Input::Initialization::Bold:: *)
findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,centralPoint_,normalAtVertex_,(*function of the x and y canonical coordinates, returns true when  the point (0,xCan,yXan) is inside the element in its canonical orientation, i.e. with normal at vertex {-1,0,0} at the central point is (0,0,0) *)isInside_Function,(*needs to be relatively high value when there is a need to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=(**)With[{vertex=centralPoint[[1]],shiftX=centralPoint[[2]],shiftY=centralPoint[[3]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]],normal3=normalAtVertex[[3]]},With[(*zCan, xCan, yCan are coordinates in the canonical orientation of the lens, i.e. with the normal {-1,0,0}, and the vertex {0,0,0}*){sol=Quiet[If[Abs[normal2^2+normal3^2]<= 10^-12,{{d->(-sz+vertex)/\[CapitalDelta]z,xCan->(shiftX-sx-((-sz+vertex) \[CapitalDelta]x)/\[CapitalDelta]z)/normal1,yCan->-shiftY+sy+((-sz+vertex) \[CapitalDelta]y)/\[CapitalDelta]z}},Solve[{sz+d \[CapitalDelta]z==normal2 xCan+normal3 yCan+vertex,sx+d \[CapitalDelta]x==((-normal1 normal2^2+normal3^2) xCan-(1+normal1) normal2 normal3 yCan)/(normal2^2+normal3^2)+shiftX,sy+d \[CapitalDelta]y==(-(1+normal1) normal2 normal3 xCan+normal2^2 yCan-normal1 normal3^2 yCan)/(normal2^2+normal3^2)+shiftY},{d,xCan,yCan},Reals]],{Solve::ratnz}]},Map[{#[[1]],With[{normalInCanonicalDirection=normalAtVertex},If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},normalInCanonicalDirection]<\[Pi]/2,-normalInCanonicalDirection,normalInCanonicalDirection]]}&,Sort[Select[Map[{#[[1,2]],#[[2,2]],#[[3,2]]}&,sol],(#[[1]]>= tolerance&&isInside[#[[2]],#[[3]]]&)],(#1[[1]]<#2[[1]]&)]]]]


(* ::Input::Initialization::Bold:: *)
findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,lensDiameter_,centralPoint_,normalAtVertex_]:=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,lensDiameter,centralPoint,normalAtVertex,0]


(* ::Input::Initialization::Bold:: *)
(*returns list of pairs {positive d scalar factor, normal at intersection point}, for which the vectors hits the surface within the lens diameter, i.e. it not necessary to check whether the ray actually hit the surface*)findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,diameter_,centralPoint_,normalAtVertex_,(*needs to be relatively high value if it is necessary to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=With[{vertex=centralPoint[[1]],shiftY=centralPoint[[2]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]]},With[{rMin=-(diameter/2)+shiftY,rMax=diameter/2+shiftY},With[{sol=If[Abs[normal2 \[CapitalDelta]r+normal1 \[CapitalDelta]z]<= 10^-15,{},If[Abs[\[CapitalDelta]z]<= 10^-15,{(*d*)(normal2 shiftY-normal2 sr-normal1 sz+normal1 vertex)/(normal2 \[CapitalDelta]r),(normal2 shiftY \[CapitalDelta]r+sz \[CapitalDelta]r-vertex \[CapitalDelta]r)/(normal2 \[CapitalDelta]r)},{(-normal2 shiftY-sz+vertex+(normal2 (normal2 shiftY \[CapitalDelta]r+sz \[CapitalDelta]r-vertex \[CapitalDelta]r+shiftY \[CapitalDelta]z+normal1 shiftY \[CapitalDelta]z-sr \[CapitalDelta]z))/(normal2 \[CapitalDelta]r+normal1 \[CapitalDelta]z))/\[CapitalDelta]z,(normal2 shiftY \[CapitalDelta]r+sz \[CapitalDelta]r-vertex \[CapitalDelta]r+shiftY \[CapitalDelta]z+normal1 shiftY \[CapitalDelta]z-sr \[CapitalDelta]z)/(normal2 \[CapitalDelta]r+normal1 \[CapitalDelta]z)}]]},If[Length[sol]>= 2&&sol[[1]]> tolerance&&(sol[[2]]>= rMin&&sol[[2]]<= rMax),{{sol[[1]],If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]r},normalAtVertex]<\[Pi]/2,-normalAtVertex,normalAtVertex]}},{}]]]]


(* ::Input::Initialization::Bold:: *)
findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,lensDiameter_,centralPoint_,normalAtVertex_,(*needs to be relatively high value when there is a need to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=(**)With[{vertex=centralPoint[[1]],shiftX=centralPoint[[2]],shiftY=centralPoint[[3]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]],normal3=normalAtVertex[[3]]},With[(*zCan, xCan, yCan are coordinates in the canonical orientation of the lens, i.e. with the normal {-1,0,0}, and the vertex {0,0,0}*){sol=Quiet[If[Abs[normal2^2+normal3^2]<= 10^-12,{{d->(-sz+vertex)/\[CapitalDelta]z,xCan->(shiftX-sx-((-sz+vertex) \[CapitalDelta]x)/\[CapitalDelta]z)/normal1,yCan->-shiftY+sy+((-sz+vertex) \[CapitalDelta]y)/\[CapitalDelta]z}},Solve[{sz+d \[CapitalDelta]z==normal2 xCan+normal3 yCan+vertex,sx+d \[CapitalDelta]x==((-normal1 normal2^2+normal3^2) xCan-(1+normal1) normal2 normal3 yCan)/(normal2^2+normal3^2)+shiftX,sy+d \[CapitalDelta]y==(-(1+normal1) normal2 normal3 xCan+normal2^2 yCan-normal1 normal3^2 yCan)/(normal2^2+normal3^2)+shiftY},{d,xCan,yCan},Reals]],{Solve::ratnz}]},Map[{#[[1]],With[{normalInCanonicalDirection=normalAtVertex},If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},normalInCanonicalDirection]<\[Pi]/2,-normalInCanonicalDirection,normalInCanonicalDirection]]}&,Sort[Select[Map[{#[[1,2]],#[[2,2]],#[[3,2]]}&,sol],(#[[1]]>= tolerance&&Sqrt[(#[[2]]^2+#[[3]]^2)]<= lensDiameter/2&)],(#1[[1]]<#2[[1]]&)]]]]


(* ::Input::Initialization::Bold:: *)
(*canonical orientation cylinder of length equal to thickness, whose axis is the z-axis, and occupies the right hal plane, i.e. the axis in the z interval {0, thickness}, so that the central point is{0,0,0}*)findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R1_,length_,centralPoint_,normalAtVertex_,(*needs to be relatively high value when there is a need to prevent spurious cross sections when ray emerges from the surface*)tolerance_]:=(**)With[{vertex=centralPoint[[1]],shiftX=centralPoint[[2]],shiftY=centralPoint[[3]],normal1=normalAtVertex[[1]],normal2=normalAtVertex[[2]],normal3=normalAtVertex[[3]]},With[(*zCan, xCan, yCan are coordinates in the canonical orientation of the lens, i.e. with the normal {-1,0,0}, and the vertex {0,0,0}*){sol=Quiet[If[Abs[normal2^2+normal3^2]<= 10^-12,Solve[{yCan^2==R1^2-xCan^2,sz+d \[CapitalDelta]z==vertex-normal1 zCan,sx+d \[CapitalDelta]x==shiftX-normal1 xCan,sy+d \[CapitalDelta]y==shiftY+yCan},{d,zCan,xCan,yCan},Reals],Solve[{yCan^2==R1^2-xCan^2,sz+d \[CapitalDelta]z==normal2 xCan+normal3 yCan-normal1 zCan+vertex,sx+d \[CapitalDelta]x==((-normal1 normal2^2+normal3^2) xCan-(1+normal1) normal2 normal3 yCan)/(normal2^2+normal3^2)-normal2 zCan+shiftX,sy+d \[CapitalDelta]y==(-(1+normal1) normal2 normal3 xCan+normal2^2 yCan-normal1 normal3^2 yCan)/(normal2^2+normal3^2)-normal3 zCan+shiftY},{d,zCan,xCan,yCan},Reals]],{Solve::ratnz}]},Map[{#[[1]],With[{normalInCanonicalDirection=findNormalToCylindricalSurface3D[ArcTan[#[[3]],#[[4]]],normalAtVertex]},If[VectorAngle[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},normalInCanonicalDirection]<\[Pi]/2,-normalInCanonicalDirection,normalInCanonicalDirection]]}&,Sort[Select[Map[{#[[1,2]],#[[2,2]],#[[3,2]],#[[4,2]]}&,sol],(#[[1]]>= tolerance&&#[[2]]>= 0&&#[[2]]<= length&)],(#1[[1]]<#2[[1]]&)]]]]


(* ::Input::Initialization::Bold:: *)
(*quite fast*)findRayAsphericalSurfaceIntersection3DFindRoot[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_,lensDiameter_]:=With[{maxRSq=lensDiameter^2/4},With[{sagExtremum=1/R*maxRSq/(1+Sqrt[1-(1+k) maxRSq/R^2])+A4*maxRSq^2+A6*maxRSq^3+A8*maxRSq^4+A10*maxRSq^5+A12*maxRSq^6+A14*maxRSq^7+A16*maxRSq^8},With[{sol=Quiet[FindRoot[{x==sx+(z-sz) \[CapitalDelta]x/\[CapitalDelta]z&&y==sy+(z-sz) \[CapitalDelta]y/\[CapitalDelta]z&&With[{r=Sqrt[x^2+y^2]},z==vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8+A10*r^10+A12*r^12+A14*r^14+A16*r^16]},{{z,vertex+sagExtremum/2,Min[vertex,vertex+sagExtremum],Max[vertex,vertex+sagExtremum]},{x,0,-(lensDiameter/2),lensDiameter/2},{y,0,-(lensDiameter/2),lensDiameter/2}}],{FindRoot::reged}]},If[Length[sol]>0,{sol[[1,2]],sol[[2,2]],sol[[3,2]]},sol]]]]


(* ::Input::Initialization::Bold:: *)
(*too slow*)findRayAsphericalSurfaceIntersection3DSolve1[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_,lensDiameter_]:=With[{maxRSq=lensDiameter^2/4},With[{sagExtremum=1/R*maxRSq/(1+Sqrt[1-(1+k) maxRSq/R^2])+A4*maxRSq^2+A6*maxRSq^3+A8*maxRSq^4+A10*maxRSq^5+A12*maxRSq^6+A14*maxRSq^7+A16*maxRSq^8},With[{sol=N[Quiet[Solve[{x==sx+(z-sz) \[CapitalDelta]x/\[CapitalDelta]z&&y==sy+(z-sz) \[CapitalDelta]y/\[CapitalDelta]z&&With[{r=Sqrt[x^2+y^2]},z==vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8+A10*r^10+A12*r^12+A14*r^14+A16*r^16]&&z>= Min[vertex,vertex+sagExtremum]&&z<=  Max[vertex,vertex+sagExtremum]},{z,x,y},Reals],{Solve::ratnz}]]},With[{selectedSol=MinimalBy[Map[{#[[1,2]],#[[2,2]],#[[3,2]],(#[[1,2]]-sz)^2+(#[[2,2]]-sx)^2+(#[[3,2]]-sy)^2}&,sol],(*This N is necessery here, because of stupid way MinimalBy orders values*)N[Last[#]]&]},If[Length[selectedSol]>0,{selectedSol[[1,1]],selectedSol[[1,2]],selectedSol[[1,3]]},selectedSol]]]]]


(* ::Input::Initialization::Bold:: *)
(*too slow*)findRayAsphericalSurfaceIntersection3DSolve2[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_,lensDiameter_]:=With[{maxRSq=lensDiameter^2/4},With[{sol=N[Quiet[Solve[{With[{r=Sqrt[(sx+t* \[CapitalDelta]x)^2+(sy+t*\[CapitalDelta]y)^2]},(sz+t*\[CapitalDelta]z)==vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8+A10*r^10+A12*r^12+A14*r^14+A16*r^16]&&t>0},{t},Reals],{Solve::ratnz}]]},With[{selectedSol=MinimalBy[Map[#[[1,2]]&,sol],(*This N is necessery here, because of stupid way MinimalBy orders values*)N[#]&]},If[Length[selectedSol]>0,{sz+selectedSol[[1]]*\[CapitalDelta]z,sx+selectedSol[[1]]*\[CapitalDelta]x,sy+selectedSol[[1]]*\[CapitalDelta]y},selectedSol]]]]


(* ::Input::Initialization::Bold:: *)
(*quite fast*)findRayAsphericalSurfaceIntersection3DFastD[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_,lensDiameter_,opts:OptionsPattern[FindRoot]]:=With[{maxRSq=lensDiameter^2/4},With[{sagExtremum=1/R*maxRSq/(1+Sqrt[1-(1+k) maxRSq/R^2])+A4*maxRSq^2+A6*maxRSq^3+A8*maxRSq^4+A10*maxRSq^5+A12*maxRSq^6+A14*maxRSq^7+A16*maxRSq^8},If[\[CapitalDelta]z>0,With[{sol=Quiet[FindRoot[{With[{r=Sqrt[(sx+t* \[CapitalDelta]x)^2+(sy+t*\[CapitalDelta]y)^2]},(sz+t*\[CapitalDelta]z)==vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8+A10*r^10+A12*r^12+A14*r^14+A16*r^16]},{t,(sagExtremum-2 sz+2 vertex)/(2 \[CapitalDelta]z),Min[(vertex-sz)/\[CapitalDelta]z,((vertex+sagExtremum)-sz)/\[CapitalDelta]z],Max[(vertex-sz)/\[CapitalDelta]z,((vertex+sagExtremum)-sz)/\[CapitalDelta]z]},opts],{FindRoot::reged}]},If[Length[sol]>0,{sz+sol[[1,2]]*\[CapitalDelta]z,sx+sol[[1,2]]*\[CapitalDelta]x,sy+sol[[1,2]]*\[CapitalDelta]y},sol]],{}]]]


(* ::Input::Initialization::Bold:: *)
(*quite fast*)findRayAsphericalSurfaceIntersection3DFast[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_,lensDiameter_,opts:OptionsPattern[FindRoot]]:=With[{maxRSq=lensDiameter^2/4},With[{sagExtremum=1/R*maxRSq/(1+Sqrt[1-(1+k) maxRSq/R^2])+A4*maxRSq^2+A6*maxRSq^3+A8*maxRSq^4+A10*maxRSq^5+A12*maxRSq^6+A14*maxRSq^7+A16*maxRSq^8},If[\[CapitalDelta]z>0,With[{comp=Compile[{{t,_Real}},With[{rSq=(sx+t* \[CapitalDelta]x)^2+(sy+t*\[CapitalDelta]y)^2},-(sz+t*\[CapitalDelta]z)+vertex+rSq(1/R*1/(1+Sqrt[1-(1+k) rSq/R^2])+rSq (A4+A6 rSq+rSq^2 (A8+A10 rSq+A12 rSq^2+A14 rSq^3+A16 rSq^4)))],RuntimeOptions->{"EvaluateSymbolically"->False,"CatchMachineIntegerOverflow"->False}]},With[{sol=Quiet[FindRoot[comp[t],{t,(sagExtremum-2 sz+2 vertex)/(2 \[CapitalDelta]z),Min[(vertex-sz)/\[CapitalDelta]z,((vertex+sagExtremum)-sz)/\[CapitalDelta]z],Max[(vertex-sz)/\[CapitalDelta]z,((vertex+sagExtremum)-sz)/\[CapitalDelta]z]},opts],{FindRoot::reged,FindRoot::lstol}]},If[Length[sol]>0,{sz+sol[[1,2]]*\[CapitalDelta]z,sx+sol[[1,2]]*\[CapitalDelta]x,sy+sol[[1,2]]*\[CapitalDelta]y},sol]]],{}]]]


(* ::Input::Initialization::Bold:: *)
findRayVerticalPlanarSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,vertex_]:=If[\[CapitalDelta]z>0,{vertex,sr+(vertex-sz) \[CapitalDelta]r/\[CapitalDelta]z},Null]


(* ::Input::Initialization::Bold:: *)
findRayBackwardPropagationVerticalPlanarSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,vertex_]:=If[\[CapitalDelta]z<0,{vertex,sr+(vertex-sz) \[CapitalDelta]r/\[CapitalDelta]z},Null]


(* ::Input::Initialization::Bold:: *)
findRayVerticalPlanarSurfaceIntersection3D[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,vertex_]:=If[\[CapitalDelta]z>0,{vertex,sx+(vertex-sz) \[CapitalDelta]x/\[CapitalDelta]z,sy+(vertex-sz) \[CapitalDelta]y/\[CapitalDelta]z},{}]


(* ::Input::Initialization::Bold:: *)
findRayHorizontalPlanarSurfaceIntersection[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,surfaceR_]:=If[\[CapitalDelta]r!=0,{sz+(surfaceR-sr) \[CapitalDelta]z/\[CapitalDelta]r,surfaceR}]


(* ::Input::Initialization::Bold:: *)
(*s0 - initial point of ray, \[CapitalDelta]s - directional vector of the ray, n - normal to the plane, plane0 - point on the plane*)findRayArbitraryPlanarSurfaceIntersection[s0_,\[CapitalDelta]s_,plane0_,n_]:=With[{\[CapitalDelta]sn=Dot[\[CapitalDelta]s,n]},If[\[CapitalDelta]sn==0,Null,With[{d=Dot[(plane0-s0),n]/\[CapitalDelta]sn},s0+\[CapitalDelta]s*d]]]


(* ::Input::Initialization::Bold:: *)
findRayZAxisTubeIntersection[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,tubeCenterX_,tubeCenterY_,tubeRadius_]:=(If[\[CapitalDelta]x==0&&\[CapitalDelta]y==0,{},With[{t1=1/(2 (\[CapitalDelta]x^2+\[CapitalDelta]y^2)) (-2 sx \[CapitalDelta]x+2 tubeCenterX \[CapitalDelta]x-2 sy \[CapitalDelta]y+2 tubeCenterY \[CapitalDelta]y-Sqrt[(2 sx \[CapitalDelta]x-2 tubeCenterX \[CapitalDelta]x+2 sy \[CapitalDelta]y-2 tubeCenterY \[CapitalDelta]y)^2-4 (-tubeRadius^2+sx^2+sy^2-2 sx tubeCenterX+tubeCenterX^2-2 sy tubeCenterY+tubeCenterY^2) (\[CapitalDelta]x^2+\[CapitalDelta]y^2)]),t2=1/(2 (\[CapitalDelta]x^2+\[CapitalDelta]y^2)) (-2 sx \[CapitalDelta]x+2 tubeCenterX \[CapitalDelta]x-2 sy \[CapitalDelta]y+2 tubeCenterY \[CapitalDelta]y+Sqrt[(2 sx \[CapitalDelta]x-2 tubeCenterX \[CapitalDelta]x+2 sy \[CapitalDelta]y-2 tubeCenterY \[CapitalDelta]y)^2-4 (-tubeRadius^2+sx^2+sy^2-2 sx tubeCenterX+tubeCenterX^2-2 sy tubeCenterY+tubeCenterY^2) (\[CapitalDelta]x^2+\[CapitalDelta]y^2)])},With[{maxT=Max[t2,t1]},If[maxT>= 0,{sz+\[CapitalDelta]z*maxT,sx+\[CapitalDelta]x*maxT,sy+\[CapitalDelta]y*maxT},{}]]]])


(* ::Input::Initialization::Bold:: *)
(*pointCoordinates_,portCenterCoordinates_,tubeDiameter_*)checkIfPointIsWithinAnyZAxisTubeOpening[pointCoordinates_,zAxisPortDiametersAndTubeCenters_]:=Module[{within=False},Do[within=within||(Sqrt[(pointCoordinates[[2]]-zAxisPortDiametersAndTubeCenters[[i,2,2]])^2+(pointCoordinates[[3]]-zAxisPortDiametersAndTubeCenters[[i,2,3]])^2]<zAxisPortDiametersAndTubeCenters[[i,1]]/2),{i,1,Length[zAxisPortDiametersAndTubeCenters]}];within]


(* ::Input::Initialization::Bold:: *)
(*pointCoordinates_,portCenterCoordinates_,tubeDiameter_*)checkIfPointIsWithinAnyXAxisTubeOpening[pointCoordinates_,xAxisPortDiametersAndTubeCenters_]:=Module[{within=False},Do[within=within||(Sqrt[(pointCoordinates[[1]]-xAxisPortDiametersAndTubeCenters[[i,2,1]])^2+(pointCoordinates[[3]]-xAxisPortDiametersAndTubeCenters[[i,2,3]])^2]<xAxisPortDiametersAndTubeCenters[[i,1]]/2),{i,1,Length[xAxisPortDiametersAndTubeCenters]}];within]


(* ::Input::Initialization::Bold:: *)
(*pointCoordinates_,portCenterCoordinates_,tubeDiameter_*)checkIfPointIsWithinAnyYAxisTubeOpening[pointCoordinates_,yAxisPortDiametersAndTubeCenters_]:=Module[{within=False},Do[within=within||(Sqrt[(pointCoordinates[[1]]-yAxisPortDiametersAndTubeCenters[[i,2,1]])^2+(pointCoordinates[[2]]-yAxisPortDiametersAndTubeCenters[[i,2,2]])^2]<yAxisPortDiametersAndTubeCenters[[i,1]]/2),{i,1,Length[yAxisPortDiametersAndTubeCenters]}];within]


(* ::Input::Initialization::Bold:: *)
Options[findRayCircleIntersections]={IncludeOnlyFirstIntersection->False};


(* ::Input::Initialization::Bold:: *)
(*returns only intersections with ray propagating in the forward direction*)(*sz,sr - coordinates cz - the first coordinate of the center of the circle, cr - the second coordinate of the center of the circle*)findRayCircleIntersections[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,cz_,cr_,R_,opts:OptionsPattern[findRayCircleIntersections]]:=With[{ds=findRayCircleIntersectionsScalarFactors[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,cz,cr,R]},Module[{positiveIntersections={}},If[OptionValue[IncludeOnlyFirstIntersection],

If[Length[positiveIntersections]>0,positiveIntersections={sz+Min[ds]*\[CapitalDelta]z,sr+Min[ds]*\[CapitalDelta]r}],
Table[positiveIntersections=Append[positiveIntersections,{sz+ds[[i]]*\[CapitalDelta]z,sr+ds[[i]]*\[CapitalDelta]r}],{i,1,Length[ds]}]];positiveIntersections]]


(* ::Input::Initialization::Bold:: *)
Options[findRaySphereIntersections]={IncludeOnlyFirstIntersection->False};


(* ::Input::Initialization::Bold:: *)
(*returns only intersections with ray propagating in the forward direction*)(*sz,sr - coordinates cz - the first coordinate of the center of the circle, cr - the second coordinate of the center of the circle*)findRaySphereIntersections[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,cz_,cx_,cy_,R_,opts:OptionsPattern[findRaySphereIntersections]]:=With[{ds=findRaySphereIntersectionsScalarFactors[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,cz,cx,cy,R]},Module[{positiveIntersections={}},If[OptionValue[IncludeOnlyFirstIntersection],

If[Length[positiveIntersections]>0,positiveIntersections={sz+Min[ds]*\[CapitalDelta]z,sx+Min[ds]*\[CapitalDelta]x,sy+Min[ds]*\[CapitalDelta]y}],
Table[positiveIntersections=Append[positiveIntersections,{sz+ds[[i]]*\[CapitalDelta]z,sx+ds[[i]]*\[CapitalDelta]x,sy+ds[[i]]*\[CapitalDelta]y}],{i,1,Length[ds]}]];positiveIntersections]]


(* ::Input::Initialization::Bold:: *)
(*returns only scalar factors for intersections with ray propagating in the forward direction*)(*sz,sr - coordinates cz - the first coordinate of the center of the circle, cr - the second coordinate of the center of the circle*)findRayCircleIntersectionsScalarFactors[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,cz_,cr_,R_]:=With[{d1=(cr \[CapitalDelta]r-sr \[CapitalDelta]r+cz \[CapitalDelta]z-sz \[CapitalDelta]z+Sqrt[-cz^2 \[CapitalDelta]r^2+2 cz \[CapitalDelta]r (sz \[CapitalDelta]r+(cr-sr) \[CapitalDelta]z)-(sz \[CapitalDelta]r+cr \[CapitalDelta]z-sr \[CapitalDelta]z)^2+R^2 (\[CapitalDelta]r^2+\[CapitalDelta]z^2)])/(\[CapitalDelta]r^2+\[CapitalDelta]z^2),d2=-((-cr \[CapitalDelta]r+sr \[CapitalDelta]r-cz \[CapitalDelta]z+sz \[CapitalDelta]z+Sqrt[-cz^2 \[CapitalDelta]r^2+2 cz \[CapitalDelta]r (sz \[CapitalDelta]r+(cr-sr) \[CapitalDelta]z)-(sz \[CapitalDelta]r+cr \[CapitalDelta]z-sr \[CapitalDelta]z)^2+R^2 (\[CapitalDelta]r^2+\[CapitalDelta]z^2)])/(\[CapitalDelta]r^2+\[CapitalDelta]z^2))},Module[{ds={}},If[Im[d1]==0&&d1>0,ds=Append[ds,d1]];If[(Im[d2]==0&&d1!=d2&&d2>0),ds=Append[ds,d2]];ds]]


(* ::Input::Initialization::Bold:: *)
(*returns only scalar factors for intersections with ray propagating in the forward direction*)(*sz,sr - coordinates cz - the first coordinate of the center of the circle, cr - the second coordinate of the center of the circle*)findRaySphereIntersectionsScalarFactors[sz_,sx_,sy_,\[CapitalDelta]z_,\[CapitalDelta]x_,\[CapitalDelta]y_,cz_,cx_,cy_,R_]:=With[{d1=(cx \[CapitalDelta]x-sx \[CapitalDelta]x+cy \[CapitalDelta]y-sy \[CapitalDelta]y+cz \[CapitalDelta]z-sz \[CapitalDelta]z-1/2 Sqrt[4 (cx \[CapitalDelta]x-sx \[CapitalDelta]x+cy \[CapitalDelta]y-sy \[CapitalDelta]y+cz \[CapitalDelta]z-sz \[CapitalDelta]z)^2-4 (cx^2-R^2-2 cx sx+sx^2+(cy-sy)^2+(cz-sz)^2) (\[CapitalDelta]x^2+\[CapitalDelta]y^2+\[CapitalDelta]z^2)])/(\[CapitalDelta]x^2+\[CapitalDelta]y^2+\[CapitalDelta]z^2),d2=(cx \[CapitalDelta]x-sx \[CapitalDelta]x+cy \[CapitalDelta]y-sy \[CapitalDelta]y+cz \[CapitalDelta]z-sz \[CapitalDelta]z+1/2 Sqrt[4 (cx \[CapitalDelta]x-sx \[CapitalDelta]x+cy \[CapitalDelta]y-sy \[CapitalDelta]y+cz \[CapitalDelta]z-sz \[CapitalDelta]z)^2-4 (cx^2-R^2-2 cx sx+sx^2+(cy-sy)^2+(cz-sz)^2) (\[CapitalDelta]x^2+\[CapitalDelta]y^2+\[CapitalDelta]z^2)])/(\[CapitalDelta]x^2+\[CapitalDelta]y^2+\[CapitalDelta]z^2)},Module[{ds={}},If[Im[d1]==0&&d1>0,ds=Append[ds,d1]];If[(Im[d2]==0&&d1!=d2&&d2>0),ds=Append[ds,d2]];ds]]


(* ::Input::Initialization::Bold:: *)
(*line is represented in a similar way to a ray, i.e. we specify its origin and unit directional vector; returns only scalar factors for intersections with ray propagating in the forward direction*)(*sz,sr - coordinates cz - the first coordinate of the center of the circle, cr - the second coordinate of the center of the circle*)findRayLineIntersectionsScalarFactors[sz_,sr_,\[CapitalDelta]z_,\[CapitalDelta]r_,lineSz_,lineSr_,line\[CapitalDelta]z_,line\[CapitalDelta]r_]:=If[-line\[CapitalDelta]z \[CapitalDelta]r+line\[CapitalDelta]r \[CapitalDelta]z == 0,{},With[{d1=-((-lineSz line\[CapitalDelta]r+lineSr line\[CapitalDelta]z-line\[CapitalDelta]z sr+line\[CapitalDelta]r sz)/(-line\[CapitalDelta]z \[CapitalDelta]r+line\[CapitalDelta]r \[CapitalDelta]z))},Module[{ds={}},If[Im[d1]==0&&d1>0,ds=Append[ds,d1]];ds]]]


(* ::Subsubsection::Bold:: *)
(*UNIT VECTORS NORMAL TO OPTICAL SURFACES*)


(* ::Input::Initialization::Bold:: *)
findNormalToSphericalSurface2D[r_,R_]:=With[{der=r/(Sqrt[1-r^2/R^2] R)},1/Sqrt[der^2+1]*{-1,der}]


(* ::Input::Initialization::Bold:: *)
(*\[Rho] is a parameter describing the spherical curves, going from -R/2 to R/2*)findNormalToSphericalSurface2D[\[Rho]_,R_,normalAtVertex_]:=With[{normalVertex1=normalAtVertex[[1]],normalVertex2=normalAtVertex[[2]],canonicalOrientationNormal=With[{der=\[Rho]/(Sqrt[1- (\[Rho]^2)/R^2] R)},1/Sqrt[der^2+1]*{-1,der}]},{-canonicalOrientationNormal[[1]]* normalVertex1+canonicalOrientationNormal[[2]]* normalVertex2,-canonicalOrientationNormal[[2]]* normalVertex1-canonicalOrientationNormal[[1]]* normalVertex2}]


(* ::Input::Initialization::Bold:: *)
findNormalToSphericalSurface3D[x_,y_,R_]:=With[{derDenominator=R Sqrt[1-(x^2+y^2)/R^2]},With[{derX=x/derDenominator,derY=y/derDenominator},1/Sqrt[derX^2+derY^2+1]*{-1,derX,derY}]]


(* ::Input::Initialization::Bold:: *)
(*xCan and yCan are the coordinates between a point on the lens surface in the canonical orientation, when normalAtVertex is {-1,0,0} and vertex is {0,0,0}*)findNormalToSphericalSurface3D[xCan_,yCan_,R_,normalAtVertex_]:=With[{normalVertex1=normalAtVertex[[1]],normalVertex2=normalAtVertex[[2]],normalVertex3=normalAtVertex[[3]],(*normal to a non-rotated surface*)canonicalOrientationNormal=With[{rSquared=xCan^2+yCan^2},With[{derFactor= (1/(R Sqrt[1-(rSquared)/R^2]))},With[{derX=xCan*derFactor,derY=yCan*derFactor},(1/(\[Sqrt](derX^2+derY^2+1)))*{-1,derX,derY}]]]},If[Abs[normalVertex2^2+normalVertex3^2]<10^-12,With[{\[CapitalDelta]z=canonicalOrientationNormal[[1]],\[CapitalDelta]x=canonicalOrientationNormal[[2]],\[CapitalDelta]y=canonicalOrientationNormal[[3]]},{-normalVertex1 \[CapitalDelta]z,-normalVertex1 \[CapitalDelta]x,\[CapitalDelta]y}],With[{\[CapitalDelta]z=canonicalOrientationNormal[[1]],\[CapitalDelta]x=canonicalOrientationNormal[[2]],\[CapitalDelta]y=canonicalOrientationNormal[[3]]},{normalVertex2 \[CapitalDelta]x+normalVertex3 \[CapitalDelta]y-normalVertex1 \[CapitalDelta]z,((-normalVertex1 normalVertex2^2+normalVertex3^2) \[CapitalDelta]x)/(normalVertex2^2+normalVertex3^2)-((1+normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex2 \[CapitalDelta]z,((-1-normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]x+normalVertex2^2 \[CapitalDelta]y-normalVertex1 normalVertex3^2 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex3 \[CapitalDelta]z}],]]


(* ::Input::Initialization::Bold:: *)
findNormalToAsphericalSurface2D[r_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_]:=With[{der=4 A4 r^3+6 A6 r^5+8 A8 r^7+2 r^9 (5 A10+6 A12 r^2+7 A14 r^4+8 A16 r^6)+r/(Sqrt[1-((1+k) r^2)/R^2] R)},1/Sqrt[der^2+1]*{-1,der}]


(* ::Input::Initialization::Bold:: *)
(*\[Rho] is a parameter describing the aspheric curves, going from -lensDiameter/2 to lensDiameter/2*)findNormalToAsphericalSurface2D[\[Rho]_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,normalAtVertex_]:=With[{normalVertex1=normalAtVertex[[1]],normalVertex2=normalAtVertex[[2]],canonicalOrientationNormal=With[{der=4 A4 \[Rho]^3+6 A6 \[Rho]^5+8 A8 \[Rho]^7+2 \[Rho]^9 (5 A10+6 A12 \[Rho]^2+7 A14 \[Rho]^4+8 A16 \[Rho]^6)+\[Rho]/(Sqrt[1-((1+k) \[Rho]^2)/R^2] R)},1/Sqrt[der^2+1]*{-1,der}]},{-canonicalOrientationNormal[[1]]* normalVertex1+canonicalOrientationNormal[[2]]* normalVertex2,-canonicalOrientationNormal[[2]]* normalVertex1-canonicalOrientationNormal[[1]]* normalVertex2}]


(* ::Input::Initialization::Bold:: *)
findNormalToAsphericalSurface3D[xCan_,yCan_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_]:=With[{rSquared=xCan^2+yCan^2},With[{derFactor= (4 A4 rSquared+6 A6 rSquared^2+1/(R Sqrt[1-((1+k) rSquared)/R^2])+2 rSquared^3 (4 A8+rSquared (5 A10+rSquared (6 A12+rSquared (7 A14+8 A16 rSquared)))))},With[{derX=xCan*derFactor,derY=yCan*derFactor},(1/(\[Sqrt](derX^2+derY^2+1)))*{-1,derX,derY}]]]


(* ::Input::Initialization::Bold:: *)
(*we assume that {z,x,y} point lies on the surface of the lens - we DON'T CHECK IT!*)findNormalToAsphericalSurface3D[ z_,x_,y_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centralPoint_,normalAtVertex_]:=With[{rSquared=getPointLineDistance[{z,x,y},centralPoint,normalAtVertex]^2},With[{normalVertex1=normalAtVertex[[1]],normalVertex2=normalAtVertex[[2]],normalVertex3=normalAtVertex[[3]],(*normal to a non-rotated surface*)canonicalOrientationNormal=With[{derFactor= (4 A4 rSquared+6 A6 rSquared^2+1/(R \[Sqrt](1-((1+k) rSquared)/R^2))+2 rSquared^3 (4 A8+rSquared (5 A10+rSquared (6 A12+rSquared (7 A14+8 A16 rSquared)))))},With[{derX=x*derFactor,derY=y*derFactor},(1/(\[Sqrt](derX^2+derY^2+1)))*{-1,derX,derY}]]},With[{\[CapitalDelta]z=canonicalOrientationNormal[[1]],\[CapitalDelta]x=canonicalOrientationNormal[[2]],\[CapitalDelta]y=canonicalOrientationNormal[[3]]},{normalVertex2 \[CapitalDelta]x+normalVertex3 \[CapitalDelta]y-normalVertex1 \[CapitalDelta]z,((-normalVertex1 normalVertex2^2+normalVertex3^2) \[CapitalDelta]x)/(normalVertex2^2+normalVertex3^2)-((1+normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex2 \[CapitalDelta]z,((-1-normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]x+normalVertex2^2 \[CapitalDelta]y-normalVertex1 normalVertex3^2 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex3 \[CapitalDelta]z}]]]


(* ::Input::Initialization::Bold:: *)
(*xCan and yCan are the coordinates between a point on the lens surface in the canonical orientation, when normalAtVertex is {-1,0,0} and vertex is {0,0,0}*)findNormalToAsphericalSurface3D[xCan_,yCan_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,normalAtVertex_]:=With[{normalVertex1=normalAtVertex[[1]],normalVertex2=normalAtVertex[[2]],normalVertex3=normalAtVertex[[3]],(*normal to a non-rotated surface*)canonicalOrientationNormal=With[{rSquared=xCan^2+yCan^2},With[{derFactor= (4 A4 rSquared+6 A6 rSquared^2+1/(R Sqrt[1-((1+k) rSquared)/R^2])+2 rSquared^3 (4 A8+rSquared (5 A10+rSquared (6 A12+rSquared (7 A14+8 A16 rSquared)))))},With[{derX=xCan*derFactor,derY=yCan*derFactor},(1/(\[Sqrt](derX^2+derY^2+1)))*{-1,derX,derY}]]]},If[Abs[normalVertex2^2+normalVertex3^2]<10^-12,canonicalOrientationNormal,With[{\[CapitalDelta]z=canonicalOrientationNormal[[1]],\[CapitalDelta]x=canonicalOrientationNormal[[2]],\[CapitalDelta]y=canonicalOrientationNormal[[3]]},{normalVertex2 \[CapitalDelta]x+normalVertex3 \[CapitalDelta]y-normalVertex1 \[CapitalDelta]z,((-normalVertex1 normalVertex2^2+normalVertex3^2) \[CapitalDelta]x)/(normalVertex2^2+normalVertex3^2)-((1+normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex2 \[CapitalDelta]z,((-1-normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]x+normalVertex2^2 \[CapitalDelta]y-normalVertex1 normalVertex3^2 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex3 \[CapitalDelta]z}]]]


(* ::Input::Initialization::Bold:: *)
(*\[Theta]Can is the parameter describing location of the point on the cylindrical surface. After transformation to the canonical orientation (in which the normal parallel to the axis of the cylinder is {-1,0,0}), \[Theta]Can is equal to the angle between the z axis and the shortest (i.e. perpendicular) line between the  in the canonical orientation*)findNormalToCylindricalSurface3D[\[Theta]Can_,normalAtVertex_]:=With[{normalVertex1=normalAtVertex[[1]],normalVertex2=normalAtVertex[[2]],normalVertex3=normalAtVertex[[3]],(*normal to a non-rotated surface*)canonicalOrientationNormal={0,Cos[\[Theta]Can],Sin[\[Theta]Can]}},With[{\[CapitalDelta]z=canonicalOrientationNormal[[1]],\[CapitalDelta]x=canonicalOrientationNormal[[2]],\[CapitalDelta]y=canonicalOrientationNormal[[3]]},If[Abs[normalVertex2^2+normalVertex3^2]<= 10^-12,{normalVertex3 \[CapitalDelta]y,\[CapitalDelta]x,-normalVertex3 \[CapitalDelta]z},{normalVertex2 \[CapitalDelta]x+normalVertex3 \[CapitalDelta]y-normalVertex1 \[CapitalDelta]z,((-normalVertex1 normalVertex2^2+normalVertex3^2) \[CapitalDelta]x)/(normalVertex2^2+normalVertex3^2)-((1+normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex2 \[CapitalDelta]z,((-1-normalVertex1) normalVertex2 normalVertex3 \[CapitalDelta]x+normalVertex2^2 \[CapitalDelta]y-normalVertex1 normalVertex3^2 \[CapitalDelta]y)/(normalVertex2^2+normalVertex3^2)-normalVertex3 \[CapitalDelta]z}]]]


(* ::Subsubsection::Bold:: *)
(*LENS OBJECTS*)


(* ::Input::Initialization::Bold:: *)
Options[GeneralOptomechanicalPart]={PartId->""};


(* ::Input::Initialization::Bold:: *)
Options[GeneralLens]=Join[{GlassCatalogueData->{}},Options[GeneralOptomechanicalPart]];


(* ::Input::Initialization::Bold:: *)
Options[createAbstractLens]=Join[{Reverse->False,Visible->True},Options[GeneralLens]];


(* ::Input::Initialization::Bold:: *)
createAbstractLens[self_,centralPoint_List,opts:OptionsPattern[createAbstractLens]]:=createAbstractLens[self,centralPoint,2,opts]


(* ::Input::Initialization::Bold:: *)
createAbstractLens[self_,centralPoint_List,surfaceCount_Integer,opts:OptionsPattern[createAbstractLens]]:=Association["objectType"->"lens","glassCatalogueData"->OptionValue[GlassCatalogueData],"objectId"->OptionValue[PartId],"surfaceCount"->surfaceCount,"vertex"->centralPoint[[1]],"reversed"->OptionValue[Reverse],"interactWithRays2D"->Function[{rays,surroundingMedium},self["refractRays2D"][rays,surroundingMedium]],"refractRays2DAndDraw"->Function[{raysObject,surroundingMedium},With[{refractedRays=(self["refractRays2D"][raysObject,surroundingMedium])["traces"]},Show[Graphics[Table[Table[Line[{refractedRays[[i,j,1]],refractedRays[[i,j+1,1]]}],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw2D"][]]]],"refractRaysUpToScreen2D"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{refractedReysObject=(self["refractRays2D"][raysObject,surroundingMedium])},With[{raysAfterSecondSurface=refractedReysObject["traces"]},createRaysObject[ParallelMap[subjectRayToInteractionWithVerticalScreen[#,screenZPosition,screenDiameter]&,raysAfterSecondSurface],refractedReysObject["wavelength"]]]]],"refractRaysUptoScreen2DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{refractedRays=(self["refractRaysUpToScreen2D"][raysObject,surroundingMedium,screenZPosition,screenDiameter])["traces"]},Show[Graphics[Table[Table[Line[{refractedRays[[i,j,1]],refractedRays[[i,j+1,1]]}],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw2D"][]]]],"interactWithRays3D"->Function[{raysObject,surroundingMedium},self["refractRays3D"][raysObject,surroundingMedium]],"refractRaysUpToScreen3D"->(Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{refractedRaysObject=self["refractRays3D"][raysObject,surroundingMedium]},With[{refractedRays=refractedRaysObject["traces"]},createRaysObject[Table[subjectRayToInteractionWithVerticalScreen3D[refractedRays[[l]],screenZPosition,screenDiameter],{l,1,Length[refractedRays]}],refractedRaysObject["wavelength"]]]]]),"refractRays3DAndDraw"->Function[{raysObject,surroundingMedium},With[{refractedRays=(self["refractRays3D"][raysObject,surroundingMedium])["traces"]},Show[Graphics3D[Table[Table[With[{p1=refractedRays[[i,j,1]],p2=refractedRays[[i,j+1,1]]},If[p1=!=Null&&p2=!=Null,Line[{p1,p2}],{}]],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw3D"][]]]],"refractRaysUpToScreen3DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{refractedRays=(self["refractRaysUpToScreen3D"][raysObject,surroundingMedium,screenZPosition,screenDiameter])["traces"]},Show[Graphics3D[Table[Table[With[{p1=refractedRays[[i,j,1]],p2=refractedRays[[i,j+1,1]]},If[p1=!=Null&&p2=!=Null,Line[{p1,p2}],{}]],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw3D"][]]]]]


(* ::Input::Initialization::Bold:: *)
Options[createThinLens]=Join[{Options[createAbstractLens],DrawSimplifiedLens2D->True}];


(* ::Input::Initialization::Bold:: *)
createThinLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createThinLens]]:=Module[{self},self=Association[{createAbstractLens[self,{vertex,0,0},FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->vertex,"radius1"->R1,"radius2"->R2,"diameter"->lensDiameter,"glass"->glass,"draw2D"->(With[{f=self["EFL"][0.550]},If[OptionValue[DrawSimplifiedLens2D],Graphics[{If[f>= 0,Arrowheads[{{Automatic,Automatic,thinDivergingLensArrow},{Automatic,Automatic,thinConvergingLensArrow}}],Arrowheads[{{Automatic,Automatic,thinConvergingLensArrow},{Automatic,Automatic,thinDivergingLensArrow}}]],Arrow[{{vertex+centerThickness/2,-lensDiameter/2},{vertex+centerThickness/2,lensDiameter/2}}]}],drawSphericalLens[vertex,R1,R2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawSphericalLens]]]]]&),"draw3D"->(drawSphericalLens3D[vertex,R1,R2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawSphericalLens3D]]]&),"EFL"->Function[{wavelength},With[{ng=getGlassRefractiveIndex[wavelength,glass]},thickLensMakerEquationEFL[R1,R2,0,ng]]],"BFL"->Function[{wavelength},With[{ng=getGlassRefractiveIndex[wavelength,glass]},thickLensBackFocalLength[R1,R2,0,ng]]],"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],wavelength=raysObject["wavelength"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},With[{f=self["EFL"][wavelength]},createRaysObject[ParallelMap[subjectRayToRefractionOnSphericalThinLens[#,f,vertex+centerThickness/2,lensDiameter,n1,n2]&,rays],raysObject["wavelength"]]]]]),"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],ParallelMap[subjectRayToRefractionOnSphericalThinLens3D[#,-R2,-R1,vertex,centerThickness,lensDiameter,n1,n2]&,rays],ParallelMap[subjectRayToRefractionOnSphericalThinLens3D[#,R1,R2,vertex,centerThickness,lensDiameter,n1,n2]&,rays]],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createThinLens[vertex + vertexShift,R1,R2,centerThickness, lensDiameter,glass,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createSphericalLens]=Options[createAbstractLens];


(* ::Input::Initialization::Bold:: *)
createSphericalLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createSphericalLens]]:=Module[{self},self=Association[{createAbstractLens[self,{vertex,0,0},FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->vertex,"radius1"->R1,"radius2"->R2,"diameter"->lensDiameter,"glass"->glass,"draw2D"->(drawSphericalLens[vertex,R1,R2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawSphericalLens]]]&),"draw3D"->(drawSphericalLens3D[vertex,R1,R2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawSphericalLens3D]]]&),"EFL"->Function[{wavelength},With[{ng=getGlassRefractiveIndex[wavelength,glass]},thickLensMakerEquationEFL[R1,R2,centerThickness,ng]]],"BFL"->Function[{wavelength},With[{ng=getGlassRefractiveIndex[wavelength,glass]},thickLensBackFocalLength[R1,R2,centerThickness,ng]]],"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnSphericalLensSurface[#,-R2,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnSphericalLensSurface[#,-R1,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnSphericalLensSurface[#,R1,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnSphericalLensSurface[#,R2,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]]],raysObject["wavelength"]]]]),"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnSphericalLensSurface3D[#,-R2,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnSphericalLensSurface3D[#,-R1,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnSphericalLensSurface3D[#,R1,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnSphericalLensSurface3D[#,R2,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]]],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createSphericalLens[vertex+vertexShift,R1,R2,centerThickness, lensDiameter,glass,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createArbitrarySphericalLens]=Join[Options[createAbstractLens],Options[drawArbitrarilyOrientedSphericalLens]];


(* ::Code::Initialization::Bold:: *)
createArbitrarySphericalLens[vertex_?NumericQ,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitrarySphericalLens]]:=createArbitrarySphericalLens[{vertex, 0,0},normalAtVertex,R1,R2,centerThickness, lensDiameter,glass,opts]


(* ::Input::Initialization::Bold:: *)
createArbitrarySphericalLens[centralPoint_List,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitrarySphericalLens]]:=Module[{self},With[{centralPointS1=If[OptionValue[Reverse],centralPoint+centerThickness*(-normalAtVertex),centralPoint],centralPointS2=If[OptionValue[Reverse],centralPoint,centralPoint+centerThickness*(-normalAtVertex)],R1Eff=If[OptionValue[Reverse],-R1,R1],R2Eff=If[OptionValue[Reverse],-R2,R2]},With[{edgeBottom1=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][-(lensDiameter/2),R1Eff,centralPointS1,normalAtVertex],edgeBottom2=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][-(lensDiameter/2),R2Eff,centralPointS2,normalAtVertex],edgeTop1=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][lensDiameter/2,R1Eff,centralPointS1,normalAtVertex],edgeTop2=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][lensDiameter/2,R2Eff,centralPointS2,normalAtVertex]},self=Association[{createAbstractLens[self,centralPoint,FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->centralPoint[[1]],"radius1"->R1,"radius2"->R2,"diameter"->lensDiameter,"glass"->glass,"draw2D"->(drawArbitrarilyOrientedSphericalLens[centralPoint,normalAtVertex,R1,R2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawArbitrarilyOrientedSphericalLens]]]&),"draw3D"->(drawArbitrarilyOrientedSphericalLens3D[centralPoint,normalAtVertex,R1,R2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawArbitrarilyOrientedSphericalLens3D]]]&),"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[ParallelMap[(*WE ASSUME THAT A RAY CAN CROSS ONLY TWO SURFACES OF THE LENS *)With[{refractedAtFirstSurface=refractOnArbitrarySphericalLens[#,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n1,n2,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,True]},refractOnArbitrarySphericalLens[refractedAtFirstSurface,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n2,n1,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,False]]&,rays],raysObject["wavelength"]]]]),
"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[ParallelMap[(*WE ASSUME THAT A RAY CAN CROSS ONLY TWO SURFACES OF THE LENS *)With[{refractedAtFirstSurface=refractOnArbitrarySphericalLens3D[#,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n1,n2,True]},refractOnArbitrarySphericalLens3D[refractedAtFirstSurface,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n2,n1,False]]&,rays],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShiftInZ},createArbitrarySphericalLens[centralPoint+{vertexShiftInZ,0},normalAtVertex,R1,R2,centerThickness, lensDiameter,glass,opts]]]}]]]]


(* ::Input::Initialization::Bold:: *)
Options[createAsphericLens]=Join[Options[createAbstractLens],Options[drawAsphericPlaneLens],Options[drawAsphericPlaneLens3D]];


(* ::Input::Initialization::Bold:: *)
createAsphericLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,asphericCoefficients1_List,centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createAsphericLens]]:=createAsphericLens[vertex,R1,k,getValue[1,asphericCoefficients1,0],getValue[2,asphericCoefficients1,0],getValue[3,asphericCoefficients1,0],getValue[4,asphericCoefficients1,0],getValue[5,asphericCoefficients1,0],getValue[6,asphericCoefficients1,0],getValue[7,asphericCoefficients1,0],Infinity,centerThickness, lensDiameter,glass,opts]


(* ::Input::Initialization::Bold:: *)
createAsphericLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,asphericCoefficients1_List,R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createAsphericLens]]:=createAsphericLens[vertex,R1,k,getValue[1,asphericCoefficients1,0],getValue[2,asphericCoefficients1,0],getValue[3,asphericCoefficients1,0],getValue[4,asphericCoefficients1,0],getValue[5,asphericCoefficients1,0],getValue[6,asphericCoefficients1,0],getValue[7,asphericCoefficients1,0],R2,centerThickness, lensDiameter,glass,opts]


(* ::Input::Initialization::Bold:: *)
createAsphericLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createAsphericLens]]:=createAsphericLens[vertex,R1,k,A4,A6,A8,A10,A12,A14,A16,Infinity,centerThickness, lensDiameter,glass,opts]


(* ::Input::Initialization::Bold:: *)
createAsphericLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness_?NumericQ, lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createAsphericLens]]:=Module[{self},self=Association[{createAbstractLens[self,{vertex,0,0},FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->vertex,"radius1"->R1,"conicConstant"->k,"diameter"->lensDiameter,"glass"->glass,"reverse"->OptionValue[Reverse],"draw2D"->(drawAsphericPlaneLens[vertex,R1,k,A4,A6,A8,A10,A12,A14,A16,centerThickness,lensDiameter,FilterRules[{opts},Options[drawAsphericPlaneLens]]]&),"draw3D"->(drawAsphericPlaneLens3D[vertex,R1,k,A4,A6,A8,A10,A12,A14,A16,centerThickness,lensDiameter,FilterRules[{opts},Options[drawAsphericPlaneLens3D]]]&),"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],ParallelMap[With[{rayRefracted=subjectRayToRefractionOnSphericalLensSurface[#,-R2,vertex,lensDiameter,n1,n2]},subjectRayToRefractionOnAsphericalLensSurface[rayRefracted,-R1,k,-A4,-A6,-A8,-A10,-A12,-A14,-A16,vertex+centerThickness,lensDiameter,n2,n1]]&,rays],ParallelMap[With[{rayRefracted=subjectRayToRefractionOnAsphericalLensSurface[#,R1,k,A4,A6,A8,A10,A12,A14,A16,vertex,lensDiameter,n1,n2]},subjectRayToRefractionOnSphericalLensSurface[rayRefracted,R2,vertex+centerThickness,lensDiameter,n2,n1]]&,rays]],raysObject["wavelength"]]]]),
"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],ParallelMap[With[{rayRefracted=subjectRayToRefractionOnSphericalLensSurface3D[#,-R2,vertex,lensDiameter,n1,n2]},subjectRayToRefractionOnAsphericalLensSurface3D[rayRefracted,-R1,k,-A4,-A6,-A8,-A10,-A12,-A14,-A16,vertex+centerThickness,lensDiameter,n2,n1]]&,rays],ParallelMap[With[{rayRefracted=subjectRayToRefractionOnAsphericalLensSurface3D[#,R1,k,A4,A6,A8,A10,A12,A14,A16,vertex,lensDiameter,n1,n2]},subjectRayToRefractionOnSphericalLensSurface3D[rayRefracted,R2,vertex+centerThickness,lensDiameter,n2,n1]]&,rays]],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createAsphericLens[vertex+vertexShift,R1,k,A4,A6,A8,A10,A12,A14,A16,centerThickness, lensDiameter,glass,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createArbitraryAsphericPlanarLens]=Join[Options[createAbstractLens],Options[drawArbitrarilyOrientedAsphericPlaneLens]];


(* ::Input::Initialization::Bold:: *)
createArbitraryAsphericPlanarLens[centralPoint_List,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,asphericCoefficients1_List,centerThickness_?NumericQ,lensDiameter_?NumericQ,glass_List,opts:OptionsPattern[createArbitraryAsphericPlanarLens]]:=createArbitraryAsphericPlanarLens[centralPoint,normalAtVertex,R1,k,getValue[1,asphericCoefficients1,0],getValue[2,asphericCoefficients1,0],getValue[3,asphericCoefficients1,0],getValue[4,asphericCoefficients1,0],getValue[5,asphericCoefficients1,0],getValue[6,asphericCoefficients1,0],getValue[7,asphericCoefficients1,0],centerThickness, lensDiameter,glass,opts]


(* ::Code::Initialization::Bold:: *)
createArbitraryAsphericPlanarLens[vertex_?NumericQ,normalAtVertex_List, R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&), k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,centerThickness_?NumericQ,lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitraryAsphericPlanarLens]]:=createArbitraryAsphericPlanarLens[{vertex,0,0},normalAtVertex,R1,k,A4,A6,A8,A10,A12,A14,A16,centerThickness,lensDiameter,glass,opts]


(* ::Input::Initialization::Bold:: *)
createArbitraryAsphericPlanarLens[centralPoint_List,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,centerThickness_?NumericQ,lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitraryAsphericPlanarLens]]:=Module[{self},With[{centraPointAspheric=If[OptionValue[Reverse],centralPoint+centerThickness*(-normalAtVertex),centralPoint],centralPointPlanar=If[OptionValue[Reverse],centralPoint,centralPoint+centerThickness*(-normalAtVertex)],R1Eff=If[OptionValue[Reverse],-R1,R1],ACoefficientsEff=If[OptionValue[Reverse],-{A4,A6,A8,A10,A12,A14,A16},{A4,A6,A8,A10,A12,A14,A16}]},With[{edgeBottom1=getAsphericalSurfaceCoordinatesAsFunctionOfCanonicalPosition\[Rho][-(lensDiameter/2),R1Eff,k,ACoefficientsEff,centraPointAspheric,normalAtVertex],edgeBottom2=getPlanarSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][-(lensDiameter/2),centralPointPlanar,normalAtVertex],edgeTop1=getAsphericalSurfaceCoordinatesAsFunctionOfCanonicalPosition\[Rho][lensDiameter/2,R1Eff,k,ACoefficientsEff,centraPointAspheric,normalAtVertex],edgeTop2=getPlanarSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][lensDiameter/2,centralPointPlanar,normalAtVertex]},self=Association[{createAbstractLens[self,centralPoint,FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->centralPoint[[1]],"radius1"->R1,"conicConstant"->k,"diameter"->lensDiameter,"glass"->glass,"reverse"->OptionValue[Reverse],"draw2D"->(drawArbitrarilyOrientedAsphericPlaneLens[centralPoint,normalAtVertex,R1,k,A4,A6,A8,A10,A12,A14,A16,centerThickness,lensDiameter,FilterRules[{opts},Options[drawArbitrarilyOrientedAsphericPlaneLens]]]&),"draw3D"->(drawArbitrarilyOrientedAsphericPlaneLens3D[centralPoint,normalAtVertex,R1,k,A4,A6,A8,A10,A12,A14,A16,centerThickness,lensDiameter,FilterRules[{opts},Options[drawArbitrarilyOrientedAsphericPlaneLens3D]]]&),"interactWithRays2D"->Function[{raysObject,surroundingMedium},self["refractRays2D"][raysObject,surroundingMedium]],"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[ParallelMap[(*WE ASSUME THAT A RAY CAN CROSS ONLY TWO SURFACES OF THE LENS *)(*refractOnArbitraryAsphericPlanarLens[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertexAspheric_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfaces_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]*)With[{refractedAtFirstSurface=refractOnArbitraryAsphericPlanarLens[#,centraPointAspheric,centralPointPlanar,normalAtVertex,R1Eff,k,ACoefficientsEff,lensDiameter,n1,n2,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,True]},refractOnArbitraryAsphericPlanarLens[refractedAtFirstSurface,centraPointAspheric,centralPointPlanar,normalAtVertex,R1Eff,k,ACoefficientsEff,lensDiameter,n2,n1,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,False]]&,rays],raysObject["wavelength"]]]]),
"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[ParallelMap[(*WE ASSUME THAT A RAY CAN CROSS ONLY TWO SURFACES OF THE LENS *)(*refractOnArbitraryAsphericPlanarLens[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertexAspheric_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfaces_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]*)With[{refractedAtFirstSurface=refractOnArbitraryAsphericPlanarLens3D[#,centraPointAspheric,centralPointPlanar,normalAtVertex,R1Eff,k,ACoefficientsEff,lensDiameter,n1,n2,True]},With[{refractedAtSecondSurface=refractOnArbitraryAsphericPlanarLens3D[refractedAtFirstSurface,centraPointAspheric,centralPointPlanar,normalAtVertex,R1Eff,k,ACoefficientsEff,lensDiameter,n2,n1,False]},refractedAtSecondSurface]]&,rays],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShiftInZ},createArbitraryAsphericPlanarLens[centralPoint+{vertexShiftInZ,0},normalAtVertex,R1,k,A4,A6,A8,A10,A12,A14,A16,centerThickness, lensDiameter,glass,opts]]]}]]]]


(* ::Input::Initialization::Bold:: *)
Options[createBiAsphericLens]=Join[Options[createAbstractLens],Options[drawBiAsphericLens],Options[drawBiAsphericLens3D]];


(* ::Input::Initialization::Bold:: *)
createBiAsphericLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k1_?NumericQ,asphericCoefficients1_List,R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k2_?NumericQ,asphericCoefficients2_List,centerThickness_?NumericQ,lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createBiAsphericLens]]:=Module[{self},self=Association[{createAbstractLens[self,{vertex,0,0},FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->vertex,"radius1"->R1,"radius2"->R2,"conicConstant1"->k1,"conicConstant2"->k2,"diameter"->lensDiameter,"glass"->glass,"draw2D"->(drawBiAsphericLens[vertex,R1,k1,asphericCoefficients1,R2,k2,asphericCoefficients2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawBiAsphericLens]]]&),"draw3D"->(drawBiAsphericLens3D[vertex,R1,k1,asphericCoefficients1,R2,k2,asphericCoefficients2,centerThickness,lensDiameter,FilterRules[{opts},Options[drawBiAsphericLens3D]]]&),"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnAsphericalLensSurface[#,-R2,k2,-asphericCoefficients2,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnAsphericalLensSurface[#,-R1,k1,-asphericCoefficients1,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnAsphericalLensSurface[#,R1,k1,asphericCoefficients1,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnAsphericalLensSurface[#,R2,k2,asphericCoefficients2,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]]],raysObject["wavelength"]]]]),
"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnAsphericalLensSurface3D[#,-R2,k2,-asphericCoefficients2,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnAsphericalLensSurface3D[#,-R1,k1,-asphericCoefficients1,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]],With[{raysAfterFirstSurface=ParallelMap[subjectRayToRefractionOnAsphericalLensSurface3D[#,R1,k1,asphericCoefficients1,vertex,lensDiameter,n1,n2]&,rays]},ParallelMap[subjectRayToRefractionOnAsphericalLensSurface3D[#,R2,k2,asphericCoefficients2,vertex+centerThickness,lensDiameter,n2,n1]&,raysAfterFirstSurface]]],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createBiAsphericLens[vertex+vertexShift,R1,k1,asphericCoefficients1,R2,k2,asphericCoefficients2,centerThickness, lensDiameter,glass,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createCementedSphericalDoubletLens]=Join[Options[createAbstractLens],Options[drawCementedSphericalDoubletLens2D],Options[drawCementedSphericalDoubletLens3D]];


(* ::Input::Initialization::Bold:: *)
createCementedSphericalDoubletLens[vertex_?NumericQ,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R3_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),centerThickness1_?NumericQ,centerThickness2_?NumericQ, lensDiameter_?NumericQ,glass1_String,glass2_String,opts:OptionsPattern[createCementedSphericalDoubletLens]]:=Module[{self},self=Association[{createAbstractLens[self,{vertex,0,0},3,FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->vertex,"vertex"->vertex,"radius1"->R1,"radius2"->R2,"radius3"->R3,"diameter"->lensDiameter,"glass1"->glass1,"glass2"->glass2,"reverse"->OptionValue[Reverse],"draw2D"->(drawCementedSphericalDoubletLens2D[vertex,R1,R2,R3,centerThickness1,centerThickness2,lensDiameter,FilterRules[{opts},Options[drawCementedSphericalDoubletLens2D]]]&),"draw3D"->(drawCementedSphericalDoubletLens3D[vertex,R1,R2,R3,centerThickness1,centerThickness2,lensDiameter,FilterRules[{opts},Options[drawCementedSphericalDoubletLens3D]]]&),"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],nMedium=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],nGlass1=getGlassRefractiveIndex[raysObject["wavelength"],glass1],nGlass2=getGlassRefractiveIndex[raysObject["wavelength"],glass2]},createRaysObject[If[OptionValue[Reverse],ParallelMap[With[{rayRefractedS3=subjectRayToRefractionOnSphericalLensSurface[#,-R3,vertex,lensDiameter,nMedium,nGlass2]},With[{rayRefractedS2=subjectRayToRefractionOnSphericalLensSurface[rayRefractedS3,-R2,vertex+centerThickness2,lensDiameter,nGlass2,nGlass1]},subjectRayToRefractionOnSphericalLensSurface[rayRefractedS2,-R1,vertex+centerThickness2+centerThickness1,lensDiameter,nGlass1,nMedium]]]&,rays],ParallelMap[With[{rayRefractedS1=subjectRayToRefractionOnSphericalLensSurface[#,R1,vertex,lensDiameter,nMedium,nGlass1]},With[{rayRefractedS2=subjectRayToRefractionOnSphericalLensSurface[rayRefractedS1,R2,vertex+centerThickness1,lensDiameter,nGlass1,nGlass2]},subjectRayToRefractionOnSphericalLensSurface[rayRefractedS2,R3,vertex+centerThickness1+centerThickness2,lensDiameter,nGlass2,nMedium]]]&,rays]],raysObject["wavelength"]]]]),
"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],nMedium=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],nGlass1=getGlassRefractiveIndex[raysObject["wavelength"],glass1],nGlass2=getGlassRefractiveIndex[raysObject["wavelength"],glass2]},createRaysObject[If[OptionValue[Reverse],ParallelMap[With[{rayRefractedS3=subjectRayToRefractionOnSphericalLensSurface3D[#,-R3,vertex,lensDiameter,nMedium,nGlass2]},With[{rayRefractedS2=subjectRayToRefractionOnSphericalLensSurface3D[rayRefractedS3,-R2,vertex+centerThickness2,lensDiameter,nGlass2,nGlass1]},subjectRayToRefractionOnSphericalLensSurface3D[rayRefractedS2,-R1,vertex+centerThickness2+centerThickness1,lensDiameter,nGlass1,nMedium]]]&,rays],ParallelMap[With[{rayRefractedS1=subjectRayToRefractionOnSphericalLensSurface3D[#,R1,vertex,lensDiameter,nMedium,nGlass1]},With[{rayRefractedS2=subjectRayToRefractionOnSphericalLensSurface3D[rayRefractedS1,R2,vertex+centerThickness1,lensDiameter,nGlass1,nGlass2]},subjectRayToRefractionOnSphericalLensSurface3D[rayRefractedS2,R3,vertex+centerThickness1+centerThickness2,lensDiameter,nGlass2,nMedium]]]&,rays]],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createCementedSphericalDoubletLens[vertex+vertexShift,R1,R1,R2,R3,centerThickness1,centerThickness2, lensDiameter,glass1,glass2,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createArbitraryCementedAspherizedDoubletLens]=Join[Options[createAbstractLens],Options[drawArbitrarilyOrientedAsphericPlaneLens]];


(* ::Code::Initialization::Bold:: *)
createArbitraryCementedAspherizedDoubletLens[vertex_?NumericQ,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,asphericCoefficients1_List,centerThickness_?NumericQ,lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitraryCementedAspherizedDoubletLens]]:=createArbitraryCementedAspherizedDoubletLens[{vertex,0,0},normalAtVertex,R1,k,asphericCoefficients1,centerThickness,lensDiameter,glass,opts]


(* ::Input::Initialization::Bold:: *)
createArbitraryCementedAspherizedDoubletLens[centralPoint_List,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,asphericCoefficients1_List,centerThickness_?NumericQ,lensDiameter_?NumericQ,glass_String,opts:OptionsPattern[createArbitraryCementedAspherizedDoubletLens]]:=createArbitraryCementedAspherizedDoubletLens[centralPoint,normalAtVertex,R1,k,getValue[1,asphericCoefficients1,0],getValue[2,asphericCoefficients1,0],getValue[3,asphericCoefficients1,0],getValue[4,asphericCoefficients1,0],getValue[5,asphericCoefficients1,0],getValue[6,asphericCoefficients1,0],getValue[7,asphericCoefficients1,0],centerThickness, lensDiameter,glass,opts]


(* ::Code::Initialization::Bold:: *)
createArbitraryCementedAspherizedDoubletLens[vertex_?NumericQ,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),RAspheric_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,centerThicknessSpherical_?NumericQ,centerThicknessAspherical_?NumericQ, lensDiameter_?NumericQ,glass1_String,glass2_String,opts:OptionsPattern[createArbitraryCementedAspherizedDoubletLens]]:=createArbitraryCementedAspherizedDoubletLens[{vertex,0,0},normalAtVertex,R1,R2,RAspheric,k,A4,A6,A8,A10,A12,A14,A16,centerThicknessSpherical,centerThicknessAspherical,lensDiameter,glass1,glass2,opts]


(* ::Input::Initialization:: *)
(*first is the spherical lens then glue to it an anspherical lens*)createArbitraryCementedAspherizedDoubletLens[centralPoint_List,normalAtVertex_List,R1_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),R2_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),RAspheric_?(MatchQ[#,_?NumericQ|Infinity|(-Infinity)]&),k_?NumericQ,A4_?NumericQ,A6_?NumericQ,A8_?NumericQ,A10_?NumericQ,A12_?NumericQ,A14_?NumericQ,A16_?NumericQ,centerThicknessSpherical_?NumericQ,centerThicknessAspherical_?NumericQ, lensDiameter_?NumericQ,glass1_String,glass2_String,opts:OptionsPattern[createArbitraryCementedAspherizedDoubletLens]]:=Module[{self},With[{centralPointAspheric=If[OptionValue[Reverse],centralPoint,centralPoint+(centerThicknessSpherical+centerThicknessAspherical)*(-normalAtVertex)],centralPointS1=If[OptionValue[Reverse],centralPoint+(centerThicknessAspherical+centerThicknessSpherical)*(-normalAtVertex),centralPoint],centralPointS2=If[OptionValue[Reverse],centralPoint+centerThicknessAspherical*(-normalAtVertex),centralPoint+centerThicknessSpherical*(-normalAtVertex)],R1Eff=If[OptionValue[Reverse],-R1,R1],R2Eff=If[OptionValue[Reverse],-R2,R2],RAsphEff=If[OptionValue[Reverse],-RAspheric,RAspheric],ACoefficientsEff=If[OptionValue[Reverse],-{A4,A6,A8,A10,A12,A14,A16},{A4,A6,A8,A10,A12,A14,A16}]},With[{edgeBottom1=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][-(lensDiameter/2),R1Eff,centralPointS1,normalAtVertex],edgeBottom2=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][-(lensDiameter/2),R2Eff,centralPointS2,normalAtVertex],edgeBottom3=getAsphericalSurfaceCoordinatesAsFunctionOfCanonicalPosition\[Rho][-(lensDiameter/2),RAsphEff,k,ACoefficientsEff,centralPointAspheric,normalAtVertex],edgeTop1=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][lensDiameter/2,R1Eff,centralPointS1,normalAtVertex],edgeTop2=getSphericalSurfaceCoordinatesAsFactionOfCanonicalPosition\[Rho][lensDiameter/2,R2Eff,centralPointS2,normalAtVertex],edgeTop3=getAsphericalSurfaceCoordinatesAsFunctionOfCanonicalPosition\[Rho][lensDiameter/2,RAsphEff,k,ACoefficientsEff,centralPointAspheric,normalAtVertex]},self=Association[{createAbstractLens[self,centralPoint,3,FilterRules[{opts},Options[createAbstractLens]]],Association["minimalCenterZ"->centralPoint[[1]],"radius1"->R1,"radius2"->R2,"radius3"->RAspheric,"conicConstant"->k,"diameter"->lensDiameter,"glass1"->glass1,"glass2"->glass2,"reverse"->OptionValue[Reverse],"draw2D"->(drawArbitrarilyOrientedAspherizedAchromaticLens[centralPoint,normalAtVertex,R1,R2,RAspheric,k,A4,A6,A8,A10,A12,A14,A16,centerThicknessSpherical,centerThicknessAspherical,lensDiameter,FilterRules[{opts},Options[drawArbitrarilyOrientedAspherizedAchromaticLens]]]&),"draw3D"->(drawArbitrarilyOrientedAspherizedAchromaticLens3D[centralPoint,normalAtVertex,R1,R2,RAspheric,k,A4,A6,A8,A10,A12,A14,A16,centerThicknessSpherical,centerThicknessAspherical,lensDiameter,FilterRules[{opts},Options[drawArbitrarilyOrientedAspherizedAchromaticLens3D]]]&),"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass1],n3=getGlassRefractiveIndex[raysObject["wavelength"],glass2]},createRaysObject[With[{raysRefracted=ParallelMap[(*WE ASSUME THAT A RAY CAN CROSS ONLY TWO SURFACES OF THE LENS *)(With[{dMinSpherical=findLowestDiastanceScalarFactorForArbitrarySphericalLens[#,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2],dMinAspherical=findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens[#,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2]},

Which[dMinSpherical!=\[Infinity]&&dMinSpherical<= dMinAspherical,With[{refractedAtFirstSurfaceOfSphericalLens=refractOnArbitrarySphericalLens[#,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n1,n2,n2,n2,n2,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,True]},With[{refractedAtSecondSurfaceOfSphericalLens=refractOnArbitrarySphericalLens[refractedAtFirstSurfaceOfSphericalLens,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n2,n1,n3,n1,n1,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,False]},refractOnArbitraryAsphericSphericalLens[refractedAtSecondSurfaceOfSphericalLens,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter,n3,n1,n2,n1,n1,edgeBottom2,edgeBottom3,edgeTop2,edgeTop3,False]]],


dMinAspherical!=\[Infinity]&&dMinAspherical<= dMinSpherical,With[{refractedAtAsphericalSurface=refractOnArbitraryAsphericSphericalLens[#,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter,n1,n3,n3,n3,n3,edgeBottom2,edgeBottom3,edgeTop2,edgeTop3,True]},With[{refractedAtSphericalSurfaceOfAsphericLens=refractOnArbitraryAsphericSphericalLens[refractedAtAsphericalSurface,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter,n3,n1,n2,n1,n1,edgeBottom2,edgeBottom3,edgeTop2,edgeTop3,False]},refractOnArbitrarySphericalLens[refractedAtSphericalSurfaceOfAsphericLens,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n2,n1,n3,n1,n1,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,False]]],True,#]])&,rays]},raysRefracted],raysObject["wavelength"]]]]),
"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass1],n3=getGlassRefractiveIndex[raysObject["wavelength"],glass2]},createRaysObject[With[{raysRefracted=ParallelMap[(*WE ASSUME THAT A RAY CAN CROSS ONLY TWO SURFACES OF THE LENS *)(With[{dMinSpherical=findLowestDiastanceScalarFactorForArbitrarySphericalLens3D[#,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter],dMinAspherical=findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens3D[#,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter]},

Which[dMinSpherical!=\[Infinity]&&dMinSpherical<= dMinAspherical,With[{refractedAtFirstSurfaceOfSphericalLens=refractOnArbitrarySphericalLens3D[#,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n1,n2,n2,n2,True]},With[{refractedAtSecondSurfaceOfSphericalLens=refractOnArbitrarySphericalLens3D[refractedAtFirstSurfaceOfSphericalLens,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n2,n1,n3,n1,False]},refractOnArbitraryAsphericSphericalLens3D[refractedAtSecondSurfaceOfSphericalLens,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter,n3,n1,n2,n1,False]]],


dMinAspherical!=\[Infinity]&&dMinAspherical<= dMinSpherical,With[{refractedAtAsphericalSurface=refractOnArbitraryAsphericSphericalLens3D[#,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter,n1,n3,n3,n3,True]},With[{refractedAtSphericalSurfaceOfAsphericLens=refractOnArbitraryAsphericSphericalLens3D[refractedAtAsphericalSurface,centralPointAspheric,centralPointS2,normalAtVertex,RAsphEff,k,ACoefficientsEff,R2Eff,lensDiameter,n3,n1,n2,n1,False]},refractOnArbitrarySphericalLens3D[refractedAtSphericalSurfaceOfAsphericLens,centralPointS1,centralPointS2,normalAtVertex,R1Eff,R2Eff,lensDiameter,n2,n1,n3,n1,False]]],True,#]])&,rays]},raysRefracted],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createArbitraryCementedAspherizedDoubletLens[centralPoint+{vertexShift,0},normalAtVertex,R1,R2,RAspheric,k,A4,A6,A8,A10,A12,A14,A16,centerThicknessSpherical,centerThicknessAspherical, lensDiameter,glass1,glass2,opts]]]}]]]]


(* ::Subsubsection::Bold:: *)
(*LENS REFRACTION*)


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitrarySphericalLens[ray_,centralPointS1_,centralPointS2_,normalAtVertices_,R1_,R2_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondS1Face_,refractiveIndexOfMediumBeyondS2Face_,refractiveIndexBeyondTopEdge_,refractiveIndexBeyondBottomEdge_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]],toleranceOnDAfterSecondContactWithLens=10^-6},With[{intersectionS1Face=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R1,lensDiameter,centralPointS1,normalAtVertices,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionS2Face=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R2,lensDiameter,centralPointS2,normalAtVertices,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtBottomEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeBottom1[[1]]-edgeBottom2[[1]])^2+(edgeBottom1[[2]]-edgeBottom2[[2]])^2],(edgeBottom1+edgeBottom2)/2,{normalAtVertices[[2]],-normalAtVertices[[1]]},If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtTopEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeTop1[[1]]-edgeTop2[[1]])^2+(edgeTop1[[2]]-edgeTop2[[2]])^2],(edgeTop1+edgeTop2)/2,{-normalAtVertices[[2]],normalAtVertices[[1]]},If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]},With[{dEffectiveS1Surface=If[Length[intersectionS1Face]<1,\[Infinity],intersectionS1Face[[1,1]]],dEffectiveS2Surface=If[Length[intersectionS2Face]<1,\[Infinity],intersectionS2Face[[1,1]]],dEffectiveBottomEdge=If[Length[intersectionAtBottomEdge]<1,\[Infinity],intersectionAtBottomEdge[[1,1]]],dEffectiveTopEdge=If[Length[intersectionAtTopEdge]<1,\[Infinity],intersectionAtTopEdge[[1,1]]]},

Which[(dEffectiveS1Surface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveS1Surface<= dEffectiveS2Surface&&dEffectiveS1Surface<=dEffectiveBottomEdge&& dEffectiveS1Surface<= dEffectiveTopEdge,(*ray hits the S1 surface*)With[{incidentZ=sz+dEffectiveS1Surface*\[CapitalDelta]z,incidentR=sr+dEffectiveS1Surface*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionS1Face[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondS1Face],ray[[-1,-1]]}]],(*ray hits the S2 surface*)(dEffectiveS2Surface!=\[Infinity])&&dEffectiveS2Surface<= dEffectiveS1Surface&&dEffectiveS2Surface<=dEffectiveBottomEdge&& dEffectiveS2Surface<= dEffectiveTopEdge,With[{incidentZ=sz+dEffectiveS2Surface*\[CapitalDelta]z,incidentR=sr+dEffectiveS2Surface*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionS2Face[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondS2Face],ray[[-1,-1]]}]],(*ray hits the bottom edge*)(dEffectiveBottomEdge!=\[Infinity])&&dEffectiveBottomEdge<= dEffectiveS1Surface&&dEffectiveBottomEdge<=dEffectiveS2Surface&& dEffectiveBottomEdge<= dEffectiveTopEdge,With[{incidentZ=sz+dEffectiveBottomEdge*\[CapitalDelta]z,incidentR=sr+dEffectiveBottomEdge*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtBottomEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondTopEdge],ray[[-1,-1]]}]],(*ray hits the top edge*)(dEffectiveTopEdge!=\[Infinity])&&dEffectiveTopEdge<= dEffectiveS1Surface&&dEffectiveTopEdge<=dEffectiveS2Surface&& dEffectiveTopEdge<= dEffectiveBottomEdge,With[{incidentZ=sz+dEffectiveTopEdge*\[CapitalDelta]z,incidentR=sr+dEffectiveTopEdge*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtTopEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondBottomEdge],ray[[-1,-1]]}],ray[[-1,-1]]}]],(*ray misses the lens*)True,ray]]]]


(* ::Input::Initialization::Bold:: *)
refractOnArbitrarySphericalLens[ray_,centralPointS1_,centralPointS2_,normalAtS1Vertex_,R1_,R2_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfaces_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=refractOnArbitrarySphericalLens[ray,centralPointS1,centralPointS2,normalAtS1Vertex,R1,R2,lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitrarySphericalLens3D[ray_,centralPointS1_,centralPointS2_,normalAtVertex_,R1_,R2_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondS1Face_,refractiveIndexOfMediumBeyondS2Face_,refractiveIndexBeyondSideEdge_,firstContactWithLens_]:=With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],toleranceOnDAfterSecondContactWithLens=10^-6,sagS1=getSphericalSag[lensDiameter/2,R1],sagS2=getSphericalSag[lensDiameter/2,R2],vertexS1ToVertexS2Vector=centralPointS1-centralPointS2},With[{intersectionS1Face=If[Abs[R1] != \[Infinity],findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,R1,lensDiameter,centralPointS1,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter,centralPointS1,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]],intersectionAtS2Face=If[Abs[R2] != \[Infinity],findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,R2,lensDiameter,centralPointS2,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter,centralPointS2,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]],intersectionAtEdge=findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter/2,Norm[centralPointS1+sagS1*(-normalAtVertex)-(centralPointS2+sagS2*(-normalAtVertex))],centralPointS1+sagS1*(-normalAtVertex)(*needs to be -normalAtVertex, do not change*),vertexS1ToVertexS2Vector/Norm[vertexS1ToVertexS2Vector](*it is either normalAtVertex or -normalAtVertex*),If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]},With[{dEffectiveAsphericSurface=If[Length[intersectionS1Face]<1,\[Infinity],intersectionS1Face[[1,1]]],dEffectiveSphericalSurface=If[Length[intersectionAtS2Face]<1,\[Infinity],intersectionAtS2Face[[1,1]]],dEffectiveEdge=If[Length[intersectionAtEdge]<1,\[Infinity],intersectionAtEdge[[1,1]]]},

Which[(dEffectiveAsphericSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveAsphericSurface<= dEffectiveSphericalSurface&&dEffectiveAsphericSurface<=dEffectiveEdge,(*ray hits the aspheric surface*)With[{incidentZ=sz+dEffectiveAsphericSurface*\[CapitalDelta]z,incidentX=sx+dEffectiveAsphericSurface*\[CapitalDelta]x,incidentY=sy+dEffectiveAsphericSurface*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},intersectionS1Face[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondS1Face],ray[[-1,-1]]}]],(*ray hits the planar surface*)(dEffectiveSphericalSurface!=\[Infinity])&&dEffectiveSphericalSurface<= dEffectiveAsphericSurface&&dEffectiveSphericalSurface<=dEffectiveEdge,With[{incidentZ=sz+dEffectiveSphericalSurface*\[CapitalDelta]z,incidentX=sx+dEffectiveSphericalSurface*\[CapitalDelta]x,incidentY=sy+dEffectiveSphericalSurface*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},intersectionAtS2Face[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondS2Face],ray[[-1,-1]]}]],(*ray hits the bottom edge*)(dEffectiveEdge!=\[Infinity])&&dEffectiveEdge<= dEffectiveAsphericSurface&&dEffectiveEdge<=dEffectiveSphericalSurface,With[{incidentZ=sz+dEffectiveEdge*\[CapitalDelta]z,incidentX=sx+dEffectiveEdge*\[CapitalDelta]x,incidentY=sy+dEffectiveEdge*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},intersectionAtEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondSideEdge],ray[[-1,-1]]}]],(*ray misses the lens*)True,ray]]]]


(* ::Input::Initialization::Bold:: *)
refractOnArbitrarySphericalLens3D[ray_,centralPointS1_,centralPointS2_,normalAtVertex_,R1_,R2_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondS1Face_,refractiveIndexOfMediumBeyondRefractiveFaces_,firstContactWithLens_]:=refractOnArbitrarySphericalLens3D[ray,centralPointS1,centralPointS2,normalAtVertex,R1,R2,lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondS1Face,refractiveIndexOfMediumBeyondRefractiveFaces,refractiveIndexOfMediumBeyondRefractiveFaces,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
findLowestDiastanceScalarFactorForArbitrarySphericalLens[ray_,centralPointS1_,centralPointS2_,normalAtVertex_,R1_,R2_,lensDiameter_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},With[{intersectionS1Face=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R1,lensDiameter,centralPointS1,normalAtVertex,0],intersectionS2Face=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R2,lensDiameter,centralPointS2,normalAtVertex,0],intersectionAtBottomEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeBottom1[[1]]-edgeBottom2[[1]])^2+(edgeBottom1[[2]]-edgeBottom2[[2]])^2],(edgeBottom1+edgeBottom2)/2,{normalAtVertex[[2]],-normalAtVertex[[1]]},0],intersectionAtTopEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeTop1[[1]]-edgeTop2[[1]])^2+(edgeTop1[[2]]-edgeTop2[[2]])^2],(edgeTop1+edgeTop2)/2,{-normalAtVertex[[2]],normalAtVertex[[1]]},0]},With[{dEffectiveS1Surface=If[Length[intersectionS1Face]<1,\[Infinity],intersectionS1Face[[1,1]]],dEffectiveS2Surface=If[Length[intersectionS2Face]<1,\[Infinity],intersectionS2Face[[1,1]]],dEffectiveBottomEdge=If[Length[intersectionAtBottomEdge]<1,\[Infinity],intersectionAtBottomEdge[[1,1]]],dEffectiveTopEdge=If[Length[intersectionAtTopEdge]<1,\[Infinity],intersectionAtTopEdge[[1,1]]]},

Min[dEffectiveS1Surface,dEffectiveS2Surface,dEffectiveBottomEdge,dEffectiveTopEdge]]]]


(* ::Input::Initialization::Bold:: *)
findLowestDiastanceScalarFactorForArbitrarySphericalLens3D[ray_,centralPointS1_,centralPointS2_,normalAtVertex_,R1_,R2_,lensDiameter_]:=With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],sagS1=getSphericalSag[lensDiameter/2,R1],sagS2=getSphericalSag[lensDiameter/2,R2],vertexS1ToVertexS2Vector=centralPointS1-centralPointS2},With[{intersectionS1Face=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,R1,lensDiameter,centralPointS1,normalAtVertex,0],intersectionS2Face=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,R2,lensDiameter,centralPointS2,normalAtVertex,0],intersectionAtEdge=findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter/2,Norm[centralPointS1+sagS1*(-normalAtVertex)-(centralPointS2+sagS2*(-normalAtVertex))],centralPointS1+sagS1*(-normalAtVertex)(*needs to be -normalAtVertex, do not change*),vertexS1ToVertexS2Vector/Norm[vertexS1ToVertexS2Vector](*it is either normalAtVertex or -normalAtVertex*),0]},With[{dEffectiveS1Surface=If[Length[intersectionS1Face]<1,\[Infinity],intersectionS1Face[[1,1]]],dEffectiveS2Surface=If[Length[intersectionS2Face]<1,\[Infinity],intersectionS2Face[[1,1]]],dEffectiveEdge=If[Length[intersectionAtEdge]<1,\[Infinity],intersectionAtEdge[[1,1]]]},

Min[dEffectiveS1Surface,dEffectiveS2Surface,dEffectiveEdge]]]]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericPlanarLens[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertexAspheric_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondAsphericFace_,refractiveIndexOfMediumBeyondPlanarFace_,refractiveIndexBeyondTopEdge_,refractiveIndexBeyondBottomEdge_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]],toleranceOnDAfterSecondContactWithLens=10^-6},With[{intersectionAsphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R1,k,A4,A6,A8,A10,A12,A14,A16,lensDiameter,centralPointAspheric,normalAtVertexAspheric,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtPlanarFace=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,lensDiameter,centralPointPlanar,-normalAtVertexAspheric,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtBottomEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeBottom1[[1]]-edgeBottom2[[1]])^2+(edgeBottom1[[2]]-edgeBottom2[[2]])^2],(edgeBottom1+edgeBottom2)/2,{normalAtVertexAspheric[[2]],-normalAtVertexAspheric[[1]]},If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtTopEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeTop1[[1]]-edgeTop2[[1]])^2+(edgeTop1[[2]]-edgeTop2[[2]])^2],(edgeTop1+edgeTop2)/2,{-normalAtVertexAspheric[[2]],normalAtVertexAspheric[[1]]},If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]},With[{dEffectiveAsphericSurface=If[Length[intersectionAsphericalFace]<1,\[Infinity],intersectionAsphericalFace[[1,1]]],dEffectivePlanarSurface=If[Length[intersectionAtPlanarFace]<1,\[Infinity],intersectionAtPlanarFace[[1,1]]],dEffectiveBottomEdge=If[Length[intersectionAtBottomEdge]<1,\[Infinity],intersectionAtBottomEdge[[1,1]]],dEffectiveTopEdge=If[Length[intersectionAtTopEdge]<1,\[Infinity],intersectionAtTopEdge[[1,1]]]},

Which[(dEffectiveAsphericSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveAsphericSurface<= dEffectivePlanarSurface&&dEffectiveAsphericSurface<=dEffectiveBottomEdge&& dEffectiveAsphericSurface<= dEffectiveTopEdge,(*ray hits the aspheric surface*)With[{incidentZ=sz+dEffectiveAsphericSurface*\[CapitalDelta]z,incidentR=sr+dEffectiveAsphericSurface*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAsphericalFace[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondAsphericFace],ray[[-1,-1]]}]],(*ray hits the planar surface*)(dEffectivePlanarSurface!=\[Infinity])&&dEffectivePlanarSurface<= dEffectiveAsphericSurface&&dEffectivePlanarSurface<=dEffectiveBottomEdge&& dEffectivePlanarSurface<= dEffectiveTopEdge,With[{incidentZ=sz+dEffectivePlanarSurface*\[CapitalDelta]z,incidentR=sr+dEffectivePlanarSurface*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtPlanarFace[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondPlanarFace],ray[[-1,-1]]}]],(*ray hits the bottom edge*)(dEffectiveBottomEdge!=\[Infinity])&&dEffectiveBottomEdge<= dEffectiveAsphericSurface&&dEffectiveBottomEdge<=dEffectivePlanarSurface&& dEffectiveBottomEdge<= dEffectiveTopEdge,With[{incidentZ=sz+dEffectiveBottomEdge*\[CapitalDelta]z,incidentR=sr+dEffectiveBottomEdge*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtBottomEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondBottomEdge],ray[[-1,-1]]}]],(*ray hits the top edge*)(dEffectiveTopEdge!=\[Infinity])&&dEffectiveTopEdge<= dEffectiveAsphericSurface&&dEffectiveTopEdge<=dEffectivePlanarSurface&& dEffectiveTopEdge<= dEffectiveBottomEdge,With[{incidentZ=sz+dEffectiveTopEdge*\[CapitalDelta]z,incidentR=sr+dEffectiveTopEdge*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtTopEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondTopEdge],ray[[-1,-1]]}],ray[[-1,-1]]}]],(*ray misses the lens*)True,ray]]]]


(* ::Input::Initialization::Bold:: *)
refractOnArbitraryAsphericPlanarLens[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertexAspheric_,R1_,k_,AsphericCoefficients_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfaces_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=refractOnArbitraryAsphericPlanarLens[ray,centralPointAspheric,centralPointPlanar,normalAtVertexAspheric,R1,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
refractOnArbitraryAsphericPlanarLens[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertexAspheric_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfaces_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=refractOnArbitraryAsphericPlanarLens[ray,centralPointAspheric,centralPointPlanar,normalAtVertexAspheric,R1,k,A4,A6,A8,A10,A12,A14,A16,lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
findLowestDistanceScalarFactorForArbitraryAsphericPlanarLens[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertexAspheric_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},With[{intersectionAsphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R1,k,A4,A6,A8,A10,A12,A14,A16,lensDiameter,centralPointAspheric,normalAtVertexAspheric,0],intersectionAtPlanarFace=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,lensDiameter,centralPointPlanar,-normalAtVertexAspheric,0],intersectionAtBottomEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeBottom1[[1]]-edgeBottom2[[1]])^2+(edgeBottom1[[2]]-edgeBottom2[[2]])^2],(edgeBottom1+edgeBottom2)/2,{normalAtVertexAspheric[[2]],-normalAtVertexAspheric[[1]]},0],intersectionAtTopEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeTop1[[1]]-edgeTop2[[1]])^2+(edgeTop1[[2]]-edgeTop2[[2]])^2],(edgeTop1+edgeTop2)/2,{-normalAtVertexAspheric[[2]],normalAtVertexAspheric[[1]]},0]},With[{dEffectiveAsphericSurface=If[Length[intersectionAsphericalFace]<1,\[Infinity],intersectionAsphericalFace[[1,1]]],dEffectivePlanarSurface=If[Length[intersectionAtPlanarFace]<1,\[Infinity],intersectionAtPlanarFace[[1,1]]],dEffectiveBottomEdge=If[Length[intersectionAtBottomEdge]<1,\[Infinity],intersectionAtBottomEdge[[1,1]]],dEffectiveTopEdge=If[Length[intersectionAtTopEdge]<1,\[Infinity],intersectionAtTopEdge[[1,1]]]},

Min[dEffectiveAsphericSurface,dEffectivePlanarSurface,dEffectiveBottomEdge,dEffectiveTopEdge]]]]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericSphericalLens[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertex_,RAspherical_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,RSpherical_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondAsphericFace_,refractiveIndexOfMediumBeyondSphericalFace_,refractiveIndexBeyondTopEdge_,refractiveIndexBeyondBottomEdge_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]],toleranceOnDAfterSecondContactWithLens=10^-6},With[{intersectionAsphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,RAspherical,k,A4,A6,A8,A10,A12,A14,A16,lensDiameter,centralPointAspheric,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtSphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,RSpherical,lensDiameter,centralPointSpherical,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtBottomEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeBottom1[[1]]-edgeBottom2[[1]])^2+(edgeBottom1[[2]]-edgeBottom2[[2]])^2],(edgeBottom1+edgeBottom2)/2,{normalAtVertex[[2]],-normalAtVertex[[1]]},If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtTopEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeTop1[[1]]-edgeTop2[[1]])^2+(edgeTop1[[2]]-edgeTop2[[2]])^2],(edgeTop1+edgeTop2)/2,{-normalAtVertex[[2]],normalAtVertex[[1]]},If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]},With[{dEffectiveAsphericSurface=If[Length[intersectionAsphericalFace]<1,\[Infinity],intersectionAsphericalFace[[1,1]]],dEffectiveSphericalSurface=If[Length[intersectionAtSphericalFace]<1,\[Infinity],intersectionAtSphericalFace[[1,1]]],dEffectiveBottomEdge=If[Length[intersectionAtBottomEdge]<1,\[Infinity],intersectionAtBottomEdge[[1,1]]],dEffectiveTopEdge=If[Length[intersectionAtTopEdge]<1,\[Infinity],intersectionAtTopEdge[[1,1]]]},

Which[(dEffectiveAsphericSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveAsphericSurface<= dEffectiveSphericalSurface&&dEffectiveAsphericSurface<=dEffectiveBottomEdge&& dEffectiveAsphericSurface<= dEffectiveTopEdge,(*ray hits the aspheric surface*)With[{incidentZ=sz+dEffectiveAsphericSurface*\[CapitalDelta]z,incidentR=sr+dEffectiveAsphericSurface*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAsphericalFace[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondAsphericFace],ray[[-1,-1]]}]],(*ray hits the planar surface*)(dEffectiveSphericalSurface!=\[Infinity])&&dEffectiveSphericalSurface<= dEffectiveAsphericSurface&&dEffectiveSphericalSurface<=dEffectiveBottomEdge&& dEffectiveSphericalSurface<= dEffectiveTopEdge,With[{incidentZ=sz+dEffectiveSphericalSurface*\[CapitalDelta]z,incidentR=sr+dEffectiveSphericalSurface*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtSphericalFace[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondSphericalFace],ray[[-1,-1]]}]],(*ray hits the bottom edge*)(dEffectiveBottomEdge!=\[Infinity])&&dEffectiveBottomEdge<= dEffectiveAsphericSurface&&dEffectiveBottomEdge<=dEffectiveSphericalSurface&& dEffectiveBottomEdge<= dEffectiveTopEdge,With[{incidentZ=sz+dEffectiveBottomEdge*\[CapitalDelta]z,incidentR=sr+dEffectiveBottomEdge*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtBottomEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondBottomEdge],ray[[-1,-1]]}]],(*ray hits the top edge*)(dEffectiveTopEdge!=\[Infinity])&&dEffectiveTopEdge<= dEffectiveAsphericSurface&&dEffectiveTopEdge<=dEffectiveSphericalSurface&& dEffectiveTopEdge<= dEffectiveBottomEdge,With[{incidentZ=sz+dEffectiveTopEdge*\[CapitalDelta]z,incidentR=sr+dEffectiveTopEdge*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Append[ray,{{incidentZ,incidentR},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},intersectionAtTopEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondTopEdge],ray[[-1,-1]]}],ray[[-1,-1]]}]],(*ray misses the lens*)True,ray]]]]


(* ::Input::Initialization::Bold:: *)
refractOnArbitraryAsphericSphericalLens[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertexAspheric_,RAspherical_,k_,AsphericCoefficients_List,RSpherical_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondAsphericFace_,refractiveIndexOfMediumBeyondSphericalFace_,refractiveIndexBeyondTopEdge_,refractiveIndexBeyondBottomEdge_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=refractOnArbitraryAsphericSphericalLens[ray,centralPointAspheric,centralPointSpherical,normalAtVertexAspheric,RAspherical,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],RSpherical,lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondAsphericFace,refractiveIndexOfMediumBeyondSphericalFace,refractiveIndexBeyondTopEdge,refractiveIndexBeyondBottomEdge,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
refractOnArbitraryAsphericSphericalLens[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertexAspheric_,RAspherical_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,RSpherical_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfaces_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_,firstContactWithLens_]:=refractOnArbitraryAsphericSphericalLens[ray,centralPointAspheric,centralPointSpherical,normalAtVertexAspheric,RAspherical,k,A4,A6,A8,A10,A12,A14,A16,RSpherical,lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertexAspheric_,R1_,k_,AsphericCoefficients_,R2_,lensDiameter_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_]:=findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens[ray,centralPointAspheric,centralPointSpherical,normalAtVertexAspheric,R1,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],R2,lensDiameter,edgeBottom1,edgeBottom2,edgeTop1,edgeTop2]


(* ::Input::Initialization::Bold:: *)
findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertex_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,R2_,lensDiameter_,edgeBottom1_,edgeBottom2_,edgeTop1_,edgeTop2_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},With[{intersectionAsphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R1,k,A4,A6,A8,A10,A12,A14,A16,lensDiameter,centralPointAspheric,normalAtVertex,0],intersectionAtSphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R2,lensDiameter,centralPointSpherical,normalAtVertex,0],intersectionAtBottomEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeBottom1[[1]]-edgeBottom2[[1]])^2+(edgeBottom1[[2]]-edgeBottom2[[2]])^2],(edgeBottom1+edgeBottom2)/2,{normalAtVertex[[2]],-normalAtVertex[[1]]},0],intersectionAtTopEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,Sqrt[(edgeTop1[[1]]-edgeTop2[[1]])^2+(edgeTop1[[2]]-edgeTop2[[2]])^2],(edgeTop1+edgeTop2)/2,{-normalAtVertex[[2]],normalAtVertex[[1]]},0]},With[{dEffectiveAsphericSurface=If[Length[intersectionAsphericalFace]<1,\[Infinity],intersectionAsphericalFace[[1,1]]],dEffectiveSphericalSurface=If[Length[intersectionAtSphericalFace]<1,\[Infinity],intersectionAtSphericalFace[[1,1]]],dEffectiveBottomEdge=If[Length[intersectionAtBottomEdge]<1,\[Infinity],intersectionAtBottomEdge[[1,1]]],dEffectiveTopEdge=If[Length[intersectionAtTopEdge]<1,\[Infinity],intersectionAtTopEdge[[1,1]]]},

Min[dEffectiveAsphericSurface,dEffectiveSphericalSurface,dEffectiveBottomEdge,dEffectiveTopEdge]]]]


(* ::Input::Initialization::Bold:: *)
findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens3D[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertex_,R1_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,R2_,lensDiameter_]:=With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],sagAspherical=getAsphericalSag[lensDiameter/2,R1,k,A4,A6,A8,A10,A12,A14,A16],sagSpherical=getSphericalSag[lensDiameter/2,R2],asphericToSphericVector=centralPointAspheric-centralPointSpherical},With[{intersectionAsphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,R1,k,A4,A6,A8,A10,A12,A14,A16,lensDiameter,centralPointAspheric,normalAtVertex,0],intersectionAtSphericalFace=If[Abs[R2] != \[Infinity],findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,R2,lensDiameter,centralPointSpherical,normalAtVertex,0],findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter,centralPointSpherical,normalAtVertex,0]],intersectionAtEdge=findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter/2,Norm[centralPointAspheric+sagAspherical*(-normalAtVertex)-(centralPointSpherical+sagSpherical*(-normalAtVertex))],centralPointAspheric+sagAspherical*(-normalAtVertex)(*needs to be -normalAtVertex, do not change*),asphericToSphericVector/Norm[asphericToSphericVector](*it is either normalAtVertex or -normalAtVertex*),0]},With[{dEffectiveAsphericSurface=If[Length[intersectionAsphericalFace]<1,\[Infinity],intersectionAsphericalFace[[1,1]]],dEffectiveSphericalSurface=If[Length[intersectionAtSphericalFace]<1,\[Infinity],intersectionAtSphericalFace[[1,1]]],dEffectiveEdge=If[Length[intersectionAtEdge]<1,\[Infinity],intersectionAtEdge[[1,1]]]},

Min[dEffectiveAsphericSurface,dEffectiveSphericalSurface,dEffectiveEdge]]]]


(* ::Input::Initialization::Bold:: *)
findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens3D[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertex_,R1_,k_,AsphericCoefficients_,R2_,lensDiameter_]:=findLowestDistanceScalarFactorForArbitraryAsphericSphericalLens3D[ray,centralPointAspheric,centralPointSpherical,normalAtVertex,R1,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],R2,lensDiameter]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericSphericalLens3D[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertex_,RAspherical_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,RSpherical_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondAsphericFace_,refractiveIndexOfMediumBeyondSphericalFace_,refractiveIndexBeyondSideEdge_,firstContactWithLens_]:=With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],toleranceOnDAfterSecondContactWithLens=10^-6,sagAspherical=getAsphericalSag[lensDiameter/2,RAspherical,k,A4,A6,A8,A10,A12,A14,A16],sagSpherical=getSphericalSag[lensDiameter/2,RSpherical],asphericToSphericVector=centralPointAspheric-centralPointSpherical},With[{intersectionAsphericalFace=findPositiveScalarFactorsAndNormalsAtIncidenceRayAsphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,RAspherical,k,A4,A6,A8,A10,A12,A14,A16,lensDiameter,centralPointAspheric,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],intersectionAtSphericalFace=If[Abs[RSpherical] != \[Infinity],findPositiveScalarFactorsAndNormalsAtIncidenceRaySphericalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,RSpherical,lensDiameter,centralPointSpherical,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]],findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter,centralPointSpherical,normalAtVertex,If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]],intersectionAtEdge=findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,lensDiameter/2,Norm[centralPointAspheric+sagAspherical*(-normalAtVertex)-(centralPointSpherical+sagSpherical*(-normalAtVertex))],centralPointAspheric+sagAspherical*(-normalAtVertex)(*needs to be -normalAtVertex, do not change*),asphericToSphericVector/Norm[asphericToSphericVector](*it is either normalAtVertex or -normalAtVertex*),If[firstContactWithLens,0,toleranceOnDAfterSecondContactWithLens]]},With[{dEffectiveAsphericSurface=If[Length[intersectionAsphericalFace]<1,\[Infinity],intersectionAsphericalFace[[1,1]]],dEffectiveSphericalSurface=If[Length[intersectionAtSphericalFace]<1,\[Infinity],intersectionAtSphericalFace[[1,1]]],dEffectiveEdge=If[Length[intersectionAtEdge]<1,\[Infinity],intersectionAtEdge[[1,1]]]},

Which[(dEffectiveAsphericSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveAsphericSurface<= dEffectiveSphericalSurface&&dEffectiveAsphericSurface<=dEffectiveEdge,(*ray hits the aspheric surface*)With[{incidentZ=sz+dEffectiveAsphericSurface*\[CapitalDelta]z,incidentX=sx+dEffectiveAsphericSurface*\[CapitalDelta]x,incidentY=sy+dEffectiveAsphericSurface*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},intersectionAsphericalFace[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondAsphericFace],ray[[-1,-1]]}]],(*ray hits the planar surface*)(dEffectiveSphericalSurface!=\[Infinity])&&dEffectiveSphericalSurface<= dEffectiveAsphericSurface&&dEffectiveSphericalSurface<=dEffectiveEdge,With[{incidentZ=sz+dEffectiveSphericalSurface*\[CapitalDelta]z,incidentX=sx+dEffectiveSphericalSurface*\[CapitalDelta]x,incidentY=sy+dEffectiveSphericalSurface*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},intersectionAtSphericalFace[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondSphericalFace],ray[[-1,-1]]}]],(*ray hits the bottom edge*)(dEffectiveEdge!=\[Infinity])&&dEffectiveEdge<= dEffectiveAsphericSurface&&dEffectiveEdge<=dEffectiveSphericalSurface,With[{incidentZ=sz+dEffectiveEdge*\[CapitalDelta]z,incidentX=sx+dEffectiveEdge*\[CapitalDelta]x,incidentY=sy+dEffectiveEdge*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},intersectionAtEdge[[1,2]],refractiveIndexOfmediumAtRayOrigin,refractiveIndexBeyondSideEdge],ray[[-1,-1]]}]],(*ray misses the lens*)True,ray]]]]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericSphericalLens3D[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertex_,RAspherical_,k_,AsphericCoefficients_List,RSpherical_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondAsphericFace_,refractiveIndexOfMediumBeyondSphericalFace_,refractiveIndexBeyondSideEdge_,firstContactWithLens_]:=refractOnArbitraryAsphericSphericalLens3D[ray,centralPointAspheric,centralPointSpherical,normalAtVertex,RAspherical,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],RSpherical,lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondAsphericFace,refractiveIndexOfMediumBeyondSphericalFace,refractiveIndexBeyondSideEdge,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericSphericalLens3D[ray_,centralPointAspheric_,centralPointSpherical_,normalAtVertex_,RAspherical_,k_,AsphericCoefficients_List,RSpherical_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfacesfirstContactWithLens_,firstContactWithLens_]:=refractOnArbitraryAsphericSphericalLens3D[ray,centralPointAspheric,centralPointSpherical,normalAtVertex,RAspherical,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],RSpherical,lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondTheRefractiveSurfacesfirstContactWithLens,refractiveIndexOfMediumBeyondTheRefractiveSurfacesfirstContactWithLens,refractiveIndexOfMediumBeyondTheRefractiveSurfacesfirstContactWithLens,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericPlanarLens3D[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertex_,RAspherical_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondAsphericFace_,refractiveIndexOfMediumBeyondPlanarFace_,refractiveIndexBeyondSideEdge_,firstContactWithLens_]:=refractOnArbitraryAsphericSphericalLens3D[ray,centralPointAspheric,centralPointPlanar,normalAtVertex,RAspherical,k,A4,A6,A8,A10,A12,A14,A16,\[Infinity],lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondAsphericFace,refractiveIndexOfMediumBeyondPlanarFace,refractiveIndexBeyondSideEdge,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericPlanarLens3D[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertex_,RAspherical_,k_,AsphericCoefficients_List,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondAsphericFace_,refractiveIndexOfMediumBeyondPlanarFace_,refractiveIndexBeyondSideEdge_,firstContactWithLens_]:=refractOnArbitraryAsphericPlanarLens3D[ray,centralPointAspheric,centralPointPlanar,normalAtVertex,RAspherical,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondAsphericFace,refractiveIndexOfMediumBeyondPlanarFace,refractiveIndexBeyondSideEdge,firstContactWithLens]


(* ::Input::Initialization::Bold:: *)
(*Terminology of refractive index variables refers to the fact that the ray origin may be either inside the lens or outside. In the simplest case of a lens int air" If the ray origin is outside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the remaining indices can be set to refractive indices of glass. If the origin of the ray is inside the lens, then refractiveIndexOfmediumAtRayOrigin is the refractive index of air, while the raming index varaibles should be set to the refractive index of air. In the case of doublet lenses, one needs to take into account both glass refractive indices*)refractOnArbitraryAsphericPlanarLens3D[ray_,centralPointAspheric_,centralPointPlanar_,normalAtVertex_,RAspherical_,k_,AsphericCoefficients_List,lensDiameter_,refractiveIndexOfmediumAtRayOrigin_,refractiveIndexOfMediumBeyondTheRefractiveSurfaces_,firstContactWithLens_]:=refractOnArbitraryAsphericPlanarLens3D[ray,centralPointAspheric,centralPointPlanar,normalAtVertex,RAspherical,k,getValue[1,AsphericCoefficients,0],getValue[2,AsphericCoefficients,0],getValue[3,AsphericCoefficients,0],getValue[4,AsphericCoefficients,0],getValue[5,AsphericCoefficients,0],getValue[6,AsphericCoefficients,0],getValue[7,AsphericCoefficients,0],lensDiameter,refractiveIndexOfmediumAtRayOrigin,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,refractiveIndexOfMediumBeyondTheRefractiveSurfaces,firstContactWithLens]


(* ::Subsubsection::Bold:: *)
(*LENS REFRACTION*)


(* ::Input::Initialization::Bold:: *)
(*see Gatland 2002, http://dx.doi.org/10.1119/1.1507789*)subjectRayToRefractionOnSphericalThinLens[ray_List,R1_,R2_,vertex_,centerThickness_,lensDiameter_,n1_,n2_]:=With[{principalPlaneZ=vertex+centerThickness/2,z0=ray[[-1,1,1]],r0=ray[[-1,1,2]],vz=ray[[-1,2,1]],vr=ray[[-1,2,2]]},With[{f=thinLensMakerEquationEFL[R1,R2,n1,n2]},With[{rayIncidencePoint={principalPlaneZ,r0+(principalPlaneZ-z0) vr/vz}},With[{refractedVector={f,-rayIncidencePoint[[2]]+f*vr/vz}},Append[ray,{rayIncidencePoint,refractedVector/Norm[refractedVector],ray[[-1,-1]]}]]]]]


(* ::Input::Initialization::Bold:: *)
(*see Gatland 2002, http://dx.doi.org/10.1119/1.1507789*)subjectRayToRefractionOnSphericalThinLens[ray_List,f_,vertex_,lensDiameter_,n1_,n2_]:=With[{principalPlaneZ=vertex,z0=ray[[-1,1,1]],r0=ray[[-1,1,2]],vz=ray[[-1,2,1]],vr=ray[[-1,2,2]]},With[{rayIncidencePoint={principalPlaneZ,r0+(principalPlaneZ-z0) vr/vz}},With[{refractedVector={f,-rayIncidencePoint[[2]]+f*vr/vz}},Append[ray,{rayIncidencePoint,refractedVector/Norm[refractedVector],ray[[-1,-1]]}]]]]


(* ::Input::Initialization::Bold:: *)
(*see Gatland 2002, http://dx.doi.org/10.1119/1.1507789*)subjectRayToRefractionOnSphericalThinLens3D[ray_List,R1_,R2_,vertex_,centerThickness_,lensDiameter_,n1_,n2_]:=With[{principalPlaneZ=vertex+centerThickness/2,z0=ray[[-1,1,1]],x0=ray[[-1,1,2]],y0=ray[[-1,1,3]],vz=ray[[-1,2,1]],vx=ray[[-1,2,2]],vy=ray[[-1,2,3]]},With[{rayIncidencePoint={principalPlaneZ,x0+(principalPlaneZ-z0) vx/vz,y0+(principalPlaneZ-z0) vy/vz},s1={1,0,0}-1/R1 {0,x0+(principalPlaneZ-z0) vx/vz,y0+(principalPlaneZ-z0) vy/vz},n=n1*ray[[-1,2]],s2={1,0,0}-1/R2 {0,x0+(principalPlaneZ-z0) vx/vz,y0+(principalPlaneZ-z0) vy/vz}},With[{nPrim=n+(n2-n1)*s1},With[{nPrimPrim=nPrim+(n1-n2)*s2},Append[ray,{rayIncidencePoint,nPrimPrim/Norm[nPrimPrim],ray[[-1,-1]]}]]]]]


(* ::Input::Initialization::Bold:: *)
(*based on Kingslake*)subjectRayToParaAxialRefractionOnSphericalSurface[ray_List,R_,vertex_,lensDiameter_,n1_,n2_]:=If[Abs[R] == \[Infinity],subjectRayToRefractionOnVerticalPlanarLensSurface[ray,vertex,lensDiameter,n1,n2],If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{z0=ray[[-1,1,1]],r0=ray[[-1,1,2]],vz=ray[[-1,2,1]],vr=ray[[-1,2,2]]},With[{u=ArcTan[vr/vz]},With[{rayIncidencePoint=With[{d=(vertex+1/R*r0^2/(1+Sqrt[1-r0^2/R^2]))-z0},{z0+d,r0+d*u}]},If[Length[rayIncidencePoint]<1||rayIncidencePoint[[2]]>lensDiameter/2,Append[ray,{Null,Null,0}],With[{angleOfIncidence=rayIncidencePoint[[2]]/R+u},With[{angleOfRefractedRay=angleOfIncidence*n1/n2},With[{angleformedByRefractedRayWithOpticalAxis=angleOfRefractedRay-rayIncidencePoint[[2]]/R},Append[ray,{rayIncidencePoint,1/Sqrt[1+Tan[angleformedByRefractedRayWithOpticalAxis]^2] {1,Tan[angleformedByRefractedRayWithOpticalAxis]},ray[[-1,-1]]}]]]]]]]]]]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnSphericalLensSurface[ray_List,R_,vertex_,lensDiameter_,n1_,n2_]:=If[Abs[R] == \[Infinity],subjectRayToRefractionOnVerticalPlanarLensSurface[ray,vertex,lensDiameter,n1,n2],If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRaySphericalSurfaceIntersection[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],R,vertex]},If[Length[rayIncidencePoint]<1||rayIncidencePoint[[2]]>lensDiameter/2,Append[ray,{Null,Null,0}],With[{normalToSurface=findNormalToSphericalSurface2D[rayIncidencePoint[[2]],R]},With[{refractedRayUnitVector=findRefractedRayUnitVector[ray[[-1,2]],normalToSurface,n1,n2]},If[refractedRayUnitVector===Null,(*we don't handle total internal reflection*)Append[ray,{rayIncidencePoint,refractedRayUnitVector,0}],Append[ray,{rayIncidencePoint,refractedRayUnitVector,ray[[-1,-1]]}]]]]]]]]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnSphericalLensSurface3D[ray_List,R_,vertex_,lensDiameter_,n1_,n2_]:=If[Abs[R] == \[Infinity],subjectRayToRefractionOnVerticalPlanarLensSurface3D[ray,vertex,lensDiameter,n1,n2],If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRaySphericalSurfaceIntersection3D[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,1,3]],ray[[-1,2,1]],ray[[-1,2,2]],ray[[-1,2,3]],R,vertex,lensDiameter]},If[Length[rayIncidencePoint]<1||Sqrt[rayIncidencePoint[[2]]^2+rayIncidencePoint[[3]]^2]>lensDiameter/2,Append[ray,{Null,Null,0}],With[{normalToSurface=findNormalToSphericalSurface3D[rayIncidencePoint[[2]],rayIncidencePoint[[3]],R]},With[{refractedRayUnitVector=findRefractedRayUnitVector[ray[[-1,2]],normalToSurface,n1,n2]},Append[ray,{rayIncidencePoint,refractedRayUnitVector,ray[[-1,-1]]}]]]]]]]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnAsphericalLensSurface[ray_List,R_,k_,surface1AsphericCoefficients_List,vertex_,lensDiameter_,n1_,n2_]:=subjectRayToRefractionOnAsphericalLensSurface[ray,R,k,getValue[1,surface1AsphericCoefficients,0],getValue[2,surface1AsphericCoefficients,0],getValue[3,surface1AsphericCoefficients,0],getValue[4,surface1AsphericCoefficients,0],getValue[5,surface1AsphericCoefficients,0],getValue[6,surface1AsphericCoefficients,0],getValue[7,surface1AsphericCoefficients,0],vertex,lensDiameter,n1,n2]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnAsphericalLensSurface[ray_List,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_,lensDiameter_,n1_,n2_]:=(If[R == \[Infinity] ||R==-\[Infinity],subjectRayToRefractionOnVerticalPlanarLensSurface[ray,vertex,lensDiameter,n1,n2],If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRayAsphericalSurfaceIntersection[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],R,k,A4,A6,A8,A10,A12,A14,A16,vertex]},If[Length[rayIncidencePoint]<1||rayIncidencePoint[[2]]>lensDiameter/2,Append[ray,{Null,Null,0}],With[{normalToSurface=findNormalToAsphericalSurface2D[rayIncidencePoint[[2]],R,k,A4,A6,A8,A10,A12,A14,A16]},With[{refractedRayUnitVector=findRefractedRayUnitVector[ray[[-1,2]],normalToSurface,n1,n2]},Append[ray,{rayIncidencePoint,refractedRayUnitVector,ray[[-1,-1]]}]]]]]]])


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnAsphericalLensSurface3D[ray_List,R_,k_,surface1AsphericCoefficients_List,vertex_,lensDiameter_,n1_,n2_]:=subjectRayToRefractionOnAsphericalLensSurface3D[ray,R,k,getValue[1,surface1AsphericCoefficients,0],getValue[2,surface1AsphericCoefficients,0],getValue[3,surface1AsphericCoefficients,0],getValue[4,surface1AsphericCoefficients,0],getValue[5,surface1AsphericCoefficients,0],getValue[6,surface1AsphericCoefficients,0],getValue[7,surface1AsphericCoefficients,0],vertex,lensDiameter,n1,n2]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnAsphericalLensSurface3D[ray_List,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,vertex_,lensDiameter_,n1_,n2_]:=If[R == \[Infinity] ||R==-\[Infinity],subjectRayToRefractionOnVerticalPlanarLensSurface3D[ray,vertex,lensDiameter,n1,n2],If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRayAsphericalSurfaceIntersection3DFast[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,1,3]],ray[[-1,2,1]],ray[[-1,2,2]],ray[[-1,2,3]],R,k,A4,A6,A8,A10,A12,A14,A16,vertex,lensDiameter]},If[Length[rayIncidencePoint]<1||Sqrt[rayIncidencePoint[[2]]^2+rayIncidencePoint[[3]]^2]>lensDiameter/2,Append[ray,{Null,Null,0}],With[{normalToSurface=findNormalToAsphericalSurface3D[rayIncidencePoint[[2]],rayIncidencePoint[[3]],R,k,A4,A6,A8,A10,A12,A14,A16]},With[{refractedRayUnitVector=findRefractedRayUnitVector[ray[[-1,2]],normalToSurface,n1,n2]},Append[ray,{rayIncidencePoint,refractedRayUnitVector,ray[[-1,-1]]}]]]]]]]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnVerticalPlanarLensSurface[ray_List,vertex_,lensDiameter_,n1_,n2_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],vertex]},If[Length[rayIncidencePoint]<1||rayIncidencePoint[[2]]>lensDiameter/2,Append[ray,{Null,Null,0}],With[{normalToSurface={-1,0}},With[{refractedRayUnitVector=findRefractedRayUnitVector[ray[[-1,2]],normalToSurface,n1,n2]},Append[ray,{rayIncidencePoint,refractedRayUnitVector,ray[[-1,-1]]}]]]]]]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnVerticalPlanarLensSurface3D[ray_List,vertex_,lensDiameter_,n1_,n2_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection3D[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,1,3]],ray[[-1,2,1]],ray[[-1,2,2]],ray[[-1,2,3]],vertex]},If[Length[rayIncidencePoint]<1||Sqrt[rayIncidencePoint[[2]]^2+rayIncidencePoint[[3]]^2]>lensDiameter/2,Append[ray,{Null,Null,0}],With[{normalToSurface={-1,0,0}},With[{refractedRayUnitVector=findRefractedRayUnitVector[ray[[-1,2]],normalToSurface,n1,n2]},Append[ray,{rayIncidencePoint,refractedRayUnitVector,ray[[-1,-1]]}]]]]]]


(* ::Input::Initialization::Bold:: *)
subjectRayToRefractionOnArbitraryPlanarLensSurface[ray_List,lensCenterPoint_,lensDiameter_,lensNormalTowardIncomingRay_,n1_,n2_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePointScalarFactorList=findRayLineIntersectionsScalarFactors[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],lensCenterPoint[[1]],lensCenterPoint[[2]],-lensNormalTowardIncomingRay[[2]],lensNormalTowardIncomingRay[[1]]]},If[Length[rayIncidencePointScalarFactorList]<1,(*ray doesn't hit the lens surface, at least not from the incoming direction*)Append[ray,{Null,Null,0}],With[{d=rayIncidencePointScalarFactorList[[1]]},With[{rayIncidencePoint={ray[[-1,1,1]]+d*ray[[-1,2,1]],ray[[-1,1,2]]+d*ray[[-1,2,2]]}},If[Sqrt[(rayIncidencePoint[[1]]-lensCenterPoint[[1]])^2+(rayIncidencePoint[[2]]-lensCenterPoint[[2]])^2]>lensDiameter,(*ray doesn't hit the lens surface*)Append[ray,{Null,Null,0}],With[{},With[{refractedRayUnitVector=findRefractedRayUnitVector[ray[[-1,2]],lensNormalTowardIncomingRay,n1,n2]},Append[ray,{rayIncidencePoint,refractedRayUnitVector,ray[[-1,-1]]}]]]]]]]]]


(* ::Subsubsection::Bold:: *)
(*LENS DRAWING*)


(* ::Input::Initialization::Bold:: *)
drawSphericalSurface[vertex_,R_,diameter_]:=With[{sagExtremum=1/R*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/R^2])},ContourPlot[z==vertex+1/R*r^2/(1+Sqrt[1-r^2/R^2]),{z,vertex,vertex+sagExtremum},{r,-diameter/2,diameter/2},AspectRatio->Automatic,PlotRangeClipping->False,PlotRange->{{vertex,vertex+sagExtremum},{-diameter/2,diameter/2}},ContourStyle->lensSurfaceStyle]]


(* ::Input::Initialization::Bold:: *)
Options[drawSphericalLens]=Join[{Reverse->False,Visible->True,LensStyle->{Opacity[0.5],GrayLevel[0.9]}},Options[RegionPlot]];


(* ::Input::Initialization::Bold:: *)
drawSphericalLens[vertex_,R1_,R2_,centerThickness_,diameter_,opts:OptionsPattern[drawSphericalLens]]:=If[OptionValue[Visible],With[{RLeft=If[OptionValue[Reverse],-R2,R1],RRight=If[OptionValue[Reverse],-R1,R2]},With[{sagExtremumLeft=1/RLeft*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RLeft^2]),sagExtremumRight=1/RRight*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RRight^2])},With[{optsRegionPlot=FilterRules[{opts},Options[RegionPlot]]},RegionPlot[z>= vertex+If[Abs[RLeft]!=Infinity,1/RLeft*r^2/(1+Sqrt[1-r^2/RLeft^2]),0]&&z<= vertex+centerThickness+If[Abs[RRight]!=Infinity,1/RRight*r^2/(1+Sqrt[1-r^2/RRight^2]),0]&&r>=-diameter/2&&r<=diameter/2 ,{z,Min[vertex,vertex+sagExtremumLeft],Max[vertex+centerThickness,vertex+centerThickness+sagExtremumRight]},{r,-diameter/2,diameter/2},AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[LensStyle],optsRegionPlot]]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawSphericalLens3D]=Join[{Reverse->False,Visible->True,LensStyle->lens3DStyle},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
drawSphericalLens3D[vertex_,R1_,R2_,centerThickness_,diameter_,opts:OptionsPattern[drawSphericalLens3D]]:=If[OptionValue[Visible],With[{RLeft=If[OptionValue[Reverse],-R2,R1],RRight=If[OptionValue[Reverse],-R1,R2]},With[{sagExtremumLeft=1/RLeft*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RLeft^2]),sagExtremumRight=1/RRight*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RRight^2])},With[{optsRegionPlot3D=FilterRules[{opts},Options[RegionPlot3D]]},Print[optsRegionPlot3D];RegionPlot3D[With[{r=Sqrt[x^2+y^2]},r>=-diameter/2&&r<=diameter/2&&z>=vertex+If[Abs[RLeft]!=Infinity,1/RLeft*r^2/(1+Sqrt[1-r^2/RLeft^2]),0]&&z<=vertex+centerThickness+If[Abs[RRight]!=Infinity,1/RRight*r^2/(1+Sqrt[1-r^2/RRight^2]),0]] ,{z,Min[vertex,vertex+sagExtremumLeft],Max[vertex+centerThickness,vertex+centerThickness+sagExtremumRight]},{x,-diameter/2,diameter/2},{y,-diameter/2,diameter/2},BoxRatios->Automatic,BoundaryStyle->None,PlotPoints->80,PlotStyle->OptionValue[LensStyle],Mesh->None,PlotTheme->"Monochrome",optsRegionPlot3D]]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawCementedSphericalDoubletLens2D]=Join[{Reverse->False,Visible->True,LensStyleFirstComponent->{Opacity[0.5],GrayLevel[0.9]},LensStyleSecondComponent->defaultAchromaticFirstLensStyle2D},Options[RegionPlot]];


(* ::Input::Initialization::Bold:: *)
drawCementedSphericalDoubletLens2D[vertex_,R1_,R2_,R3_,centerThickness1_,centerThickness2_,diameter_,opts:OptionsPattern[drawCementedSphericalDoubletLens2D]]:=If[OptionValue[Visible],With[{RLeft1=If[OptionValue[Reverse],-R3,R1],RLeft2=If[OptionValue[Reverse],-R2,R2],RRight1=If[OptionValue[Reverse],-R2,R2],RRight2=If[OptionValue[Reverse],-R1,R3],centrumThicknessLeft=If[OptionValue[Reverse],centerThickness2,centerThickness1],centrumThicknessRight=If[OptionValue[Reverse],centerThickness1,centerThickness2],lensStyleLeft=If[OptionValue[Reverse],OptionValue[LensStyleFirstComponent],OptionValue[LensStyleSecondComponent]],lensStyleRight=If[OptionValue[Reverse],OptionValue[LensStyleSecondComponent],OptionValue[LensStyleFirstComponent]]},With[{optsRegionPlot=FilterRules[{opts},Options[RegionPlot]]},Show[drawSphericalLens[vertex,RLeft1,RLeft2,centrumThicknessLeft,diameter,LensStyle->lensStyleLeft,optsRegionPlot],drawSphericalLens[vertex+centrumThicknessLeft,RRight1,RRight2,centrumThicknessRight,diameter,LensStyle->lensStyleRight,optsRegionPlot],PlotRange->All]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawCementedSphericalDoubletLens3D]=Join[{Reverse->False,Visible->True,LensStyleFirstComponent->lens3DStyle,LensStyleSecondComponent->defaultAchromaticFirstLensStyle3D},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
drawCementedSphericalDoubletLens3D[vertex_,R1_,R2_,R3_,centerThickness1_,centerThickness2_,diameter_,opts:OptionsPattern[drawCementedSphericalDoubletLens3D]]:=If[OptionValue[Visible],With[{RLeft1=If[OptionValue[Reverse],-R3,R1],RLeft2=If[OptionValue[Reverse],-R2,R2],RRight1=If[OptionValue[Reverse],-R2,R2],RRight2=If[OptionValue[Reverse],-R1,R3],centrumThicknessLeft=If[OptionValue[Reverse],centerThickness2,centerThickness1],centrumThicknessRight=If[OptionValue[Reverse],centerThickness1,centerThickness2],lensStyleLeft=If[OptionValue[Reverse],OptionValue[LensStyleFirstComponent],OptionValue[LensStyleSecondComponent]],lensStyleRight=If[OptionValue[Reverse],OptionValue[LensStyleSecondComponent],OptionValue[LensStyleFirstComponent]]},With[{optsRegionPlot3D=FilterRules[{opts},Options[RegionPlot3D]]},Show[drawSphericalLens3D[vertex,RLeft1,RLeft2,centrumThicknessLeft,diameter,LensStyle->lensStyleLeft,optsRegionPlot3D],drawSphericalLens3D[vertex+centrumThicknessLeft,RRight1,RRight2,centrumThicknessRight,diameter,LensStyle->lensStyleRight,optsRegionPlot3D],PlotRange->All]]],{}]


(* ::Input::Initialization::Bold:: *)
drawAsphericSurface[vertex_,R_,k_,diameter_,A4_,A6_,A8_,A10_,A12_,A14_,A16_]:=With[{sagExtremum=1/R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2])+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16},ContourPlot[z==vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16,{z,vertex,vertex+sagExtremum},{r,-diameter/2,diameter/2},AspectRatio->Automatic,PlotRangeClipping->False,PlotRange->{{vertex,vertex+sagExtremum},{-diameter/2,diameter/2}},ContourStyle->lensSurfaceStyle]]


(* ::Input::Initialization::Bold:: *)
Options[drawAsphericPlaneLens]={Reverse->False,Visible->True,LensStyle->defaultAsphericPlaneLensStyle2D};


(* ::Input::Initialization::Bold:: *)
drawAsphericPlaneLens[vertex_,R_,k_,asphericCoefficients_List _,centerThickness_,diameter_,opts:OptionsPattern[drawAsphericPlaneLens]]:=drawAsphericPlaneLens[vertex,R,k,getValue[1,asphericCoefficients,0],getValue[2,asphericCoefficients,0],getValue[3,asphericCoefficients,0],getValue[4,asphericCoefficients,0],getValue[5,asphericCoefficients,0],getValue[6,asphericCoefficients,0],getValue[7,asphericCoefficients,0],centerThickness,diameter,opts]


(* ::Input::Initialization::Bold:: *)
defaultAsphericPlaneLensStyle2D={Opacity[0.5],GrayLevel[0.9]};


(* ::Input::Initialization::Bold:: *)
drawAsphericPlaneLens[vertex_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centerThickness_,diameter_,opts:OptionsPattern[drawAsphericPlaneLens]]:=If[OptionValue[Visible],If[OptionValue[Reverse],With[{sagExtremum=1/-R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2])-A4*(diameter/2)^4-A6*(diameter/2)^6-A8*(diameter/2)^8-A10*(diameter/2)^10-A12*(diameter/2)^12-A14*(diameter/2)^14-A16*(diameter/2)^16},RegionPlot[z>=vertex&&r>=-diameter/2&&r<=diameter/2&&z<=vertex+centerThickness+1/-R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16 ,{z,vertex,Max[vertex+centerThickness,vertex+centerThickness+sagExtremum]},{r,-diameter/2,diameter/2},AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[LensStyle]]],With[{sagExtremum=1/R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2])+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16},RegionPlot[r>=-diameter/2&&r<=diameter/2&&z>=vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16&&z<=vertex+centerThickness ,{z,Min[vertex,vertex+sagExtremum],vertex+centerThickness},{r,-diameter/2,diameter/2},AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[LensStyle]]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedAsphericPlaneLens]={Reverse->False,Visible->True,LensStyle->defaultAsphericPlaneLensStyle2D};


(* ::Input::Initialization::Bold:: *)
drawArbitrarilyOrientedAsphericPlaneLens[centralPoint_,normalAtVertex_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centerThickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedAsphericPlaneLens]]:=If[OptionValue[Visible],With[{vertex=centralPoint[[1]],Rfinite=(Abs[R]!=\[Infinity])},If[OptionValue[Reverse],With[{sagExtremum=If[Rfinite,1/-R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2]),0]-A4*(diameter/2)^4-A6*(diameter/2)^6-A8*(diameter/2)^8-A10*(diameter/2)^10-A12*(diameter/2)^12-A14*(diameter/2)^14-A16*(diameter/2)^16},RegionPlot[TransformedRegion[ImplicitRegion[z>=vertex&&r>=-diameter/2&&r<=diameter/2&&z<=vertex+centerThickness+If[Rfinite,1/-R*r^2/(1+Sqrt[1-(1+k) r^2/R^2]),0]-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16 ,{{z,vertex,Max[vertex+centerThickness,vertex+centerThickness+sagExtremum]},{r,-diameter/2,diameter/2}}],Composition[TranslationTransform[{0,centralPoint[[2]]}],RotationTransform[{{-1,0}, normalAtVertex},{vertex,0}]]],AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[LensStyle]]],With[{sagExtremum=If[Rfinite,1/R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2]),0]+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16},RegionPlot[TransformedRegion[ImplicitRegion[r>=-diameter/2&&r<=diameter/2&&z>=vertex+If[Rfinite,1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2]),0]+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16&&z<=vertex+centerThickness ,{{z,Min[vertex,vertex+sagExtremum],vertex+centerThickness},{r,-diameter/2,diameter/2}}],Composition[TranslationTransform[{0,centralPoint[[2]]}],RotationTransform[{{-1,0}, normalAtVertex},{vertex,0}]]],AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[LensStyle]]]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedSphericalLens3D]=Join[{Reverse->False,Visible->True,(*there are problems when PlotStyle is used, Mathematica uses its defaults instead of the value specified here*)LensStyle->lens3DStyle},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
(*If we were to use TransformedRegion,as in 2D case, the drawing would take ages*)drawArbitrarilyOrientedSphericalLens3D[centralPoint_,normalAtVertex_,R1_,R2_,centerThickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedSphericalLens3D]]:=If[OptionValue[Visible],With[{vertex=centralPoint[[1]],x0=centralPoint[[2]],y0=centralPoint[[3]],normalAtVertex1=normalAtVertex[[1]],normalAtVertex2=normalAtVertex[[2]],normalAtVertex3=normalAtVertex[[3]]},With[{sagExtremum1=If[Abs[R1]!=\[Infinity],1/R1*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/R1^2]),0],sagExtremum2=If[Abs[R2]!=\[Infinity],1/R1*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/R1^2]),0]},With[{coordinateExtremum=Max[Sqrt[((diameter/2)^2+If[sagExtremum1>0,centerThickness+sagExtremum1,centerThickness]^2)],Abs[sagExtremum1],centerThickness+sagExtremum2]},With[{region=ImplicitRegion[With[{zRot=normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0)-normalAtVertex1 z+vertex+normalAtVertex1 *vertex,xRot=Which[Abs[Abs[normalAtVertex1]-1]>10^-10,1/(normalAtVertex2^2+normalAtVertex3^2) (normalAtVertex2 normalAtVertex3 (-y+y0)+normalAtVertex1 normalAtVertex2 (normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0))+normalAtVertex3^2 (x+normalAtVertex2 z-normalAtVertex2 *vertex)+normalAtVertex2^2 (x0+normalAtVertex2 z-normalAtVertex2 *vertex)),Abs[1-normalAtVertex1]<10^-10,-x+2 x0,(*no rotation*)True,x],yRot=Which[Abs[Abs[normalAtVertex1]-1]>10^-10,1/(normalAtVertex2^2+normalAtVertex3^2) (-(1+normalAtVertex1) normalAtVertex2 normalAtVertex3 (x-x0)+normalAtVertex2^2 (y+normalAtVertex3 (z-vertex))+normalAtVertex3^2 (y0+normalAtVertex1 (-y+y0)+normalAtVertex3 z-normalAtVertex3 *vertex)),True,y]},If[OptionValue[Reverse],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot<= vertex+centerThickness+If[Abs[R1]!= Infinity,1/-R1*r^2/(1+Sqrt[1-r^2/R1^2]),0]&&zRot>= vertex+If[Abs[R2]!= Infinity,1/-R2*r^2/(1+Sqrt[1-r^2/R2^2]),0]],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot>=vertex+If[Abs[R1]!= Infinity,1/R1*r^2/(1+Sqrt[1-r^2/R1^2]),0]&&zRot<=vertex+centerThickness+If[Abs[R2]!= Infinity,1/R2*r^2/(1+Sqrt[1-r^2/R2^2]),0]]]] ,{{z,vertex-coordinateExtremum,vertex+coordinateExtremum},{x,x0-coordinateExtremum,x0+coordinateExtremum},{y,y0-coordinateExtremum,y0+coordinateExtremum}}],plotOptions=FilterRules[{opts},Options[RegionPlot3D]]},RegionPlot3D[region,AspectRatio->Automatic,PlotPoints->120,BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->OptionValue[LensStyle],Mesh->None,PlotTheme->"Monochrome",plotOptions]]]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedAsphericPlaneLens3D]=Join[{Reverse->False,Visible->True,(*there are problems when PlotStyle is used, Mathematica uses its defaults instead of the value specified here*)LensStyle->lens3DStyle},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
(*If we were to use TransformedRegion,as in 2D case, the drawing would take ages*)drawArbitrarilyOrientedAsphericPlaneLens3D[centralPoint_,normalAtVertex_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centerThickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedAsphericPlaneLens3D]]:=If[OptionValue[Visible],With[{vertex=centralPoint[[1]],x0=centralPoint[[2]],y0=centralPoint[[3]],normalAtVertex1=normalAtVertex[[1]],normalAtVertex2=normalAtVertex[[2]],normalAtVertex3=normalAtVertex[[3]]},With[{sagExtremum=If[Abs[R]!= \[Infinity],1/R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2]),0]+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16},With[{coordinateExtremum=Max[Sqrt[((diameter/2)^2+(centerThickness+sagExtremum)^2)],Abs[sagExtremum],centerThickness]},With[{region=ImplicitRegion[With[{zRot=normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0)-normalAtVertex1 z+vertex+normalAtVertex1 *vertex,xRot=Which[Abs[Abs[normalAtVertex1]-1]>10^-10,1/(normalAtVertex2^2+normalAtVertex3^2) (normalAtVertex2 normalAtVertex3 (-y+y0)+normalAtVertex1 normalAtVertex2 (normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0))+normalAtVertex3^2 (x+normalAtVertex2 z-normalAtVertex2 *vertex)+normalAtVertex2^2 (x0+normalAtVertex2 z-normalAtVertex2 *vertex)),Abs[1-normalAtVertex1]<10^-10,-x+2 x0,(*no rotation*)True,x],yRot=Which[Abs[Abs[normalAtVertex1]-1]>10^-10,1/(normalAtVertex2^2+normalAtVertex3^2) (-(1+normalAtVertex1) normalAtVertex2 normalAtVertex3 (x-x0)+normalAtVertex2^2 (y+normalAtVertex3 (z-vertex))+normalAtVertex3^2 (y0+normalAtVertex1 (-y+y0)+normalAtVertex3 z-normalAtVertex3 *vertex)),True,y]},If[OptionValue[Reverse],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot<= vertex+centerThickness+If[Abs[R]!= \[Infinity],1/-R*r^2/(1+Sqrt[1-(1+k) r^2/R^2]),0]-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16&&zRot>= vertex],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot>=vertex+If[Abs[R]!= \[Infinity],1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2]),0]+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16&&zRot<=vertex+centerThickness]]] ,{{z,vertex-coordinateExtremum,vertex+coordinateExtremum},{x,x0-coordinateExtremum,x0+coordinateExtremum},{y,y0-coordinateExtremum,y0+coordinateExtremum}}]},With[{rulesRegionPlot=FilterRules[{opts},Options[RegionPlot3D]]},RegionPlot3D[region,AspectRatio->Automatic,PlotPoints->120,BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->OptionValue[LensStyle],Mesh->None,PlotTheme->"Monochrome",rulesRegionPlot]]]]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawAsphericPlaneLens3D]={Reverse->False,Visible->True};


(* ::Input::Initialization::Bold:: *)
drawAsphericPlaneLens3D[vertex_,R_,k_,asphericCoefficients_List,centerThickness_,diameter_,opts:OptionsPattern[drawAsphericPlaneLens3D]]:=drawAsphericPlaneLens3D[vertex,R,k,getValue[1,asphericCoefficients,0],getValue[2,asphericCoefficients,0],getValue[3,asphericCoefficients,0],getValue[4,asphericCoefficients,0],getValue[5,asphericCoefficients,0],getValue[6,asphericCoefficients,0],getValue[7,asphericCoefficients,0],centerThickness,diameter,opts]


(* ::Input::Initialization::Bold:: *)
drawAsphericPlaneLens3D[vertex_,R_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centerThickness_,diameter_,opts:OptionsPattern[drawAsphericPlaneLens3D]]:=If[OptionValue[Visible],If[OptionValue[Reverse],With[{sagExtremum=1/-R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2])-A4*(diameter/2)^4-A6*(diameter/2)^6-A8*(diameter/2)^8-A10*(diameter/2)^10-A12*(diameter/2)^12-A14*(diameter/2)^14-A16*(diameter/2)^16},RegionPlot3D[With[{r=Sqrt[x^2+y^2]},z>=vertex&&r>=-diameter/2&&r<=diameter/2 &&z<=vertex+centerThickness+1/-R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16],{z,vertex,Max[vertex+centerThickness,vertex+centerThickness+sagExtremum]},{x,-diameter/2,diameter/2},{y,-diameter/2,diameter/2},BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->lens3DStyle,Mesh->None,PlotTheme->"Monochrome"]],With[{sagExtremum=1/R*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/R^2])+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16},RegionPlot3D[With[{r=Sqrt[x^2+y^2]},z<=vertex+centerThickness&&r>=-diameter/2&&r<=diameter/2&&z>=vertex+1/R*r^2/(1+Sqrt[1-(1+k) r^2/R^2])+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16 ],{z,Min[vertex,vertex+sagExtremum],vertex+centerThickness},{x,-diameter/2,diameter/2},{y,-diameter/2,diameter/2},BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->lens3DStyle,Mesh->None,PlotTheme->"Monochrome"]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawBiAsphericLens]={Reverse->False,Visible->True};


(* ::Input::Initialization::Bold:: *)
drawBiAsphericLens[vertex_,R1_,k1_,surface1AsphericCoefficients_,R2_,k2_,surface2AsphericCoefficients_,centerThickness_,diameter_,opts:OptionsPattern[drawBiAsphericLens]]:=drawBiAsphericLens[vertex,R1,k1,getValue[1,surface1AsphericCoefficients,0],getValue[2,surface1AsphericCoefficients,0],getValue[3,surface1AsphericCoefficients,0],getValue[4,surface1AsphericCoefficients,0],getValue[5,surface1AsphericCoefficients,0],getValue[6,surface1AsphericCoefficients,0],getValue[7,surface1AsphericCoefficients,0],R2,k2,getValue[1,surface2AsphericCoefficients,0],getValue[2,surface2AsphericCoefficients,0],getValue[3,surface2AsphericCoefficients,0],getValue[4,surface2AsphericCoefficients,0],getValue[5,surface2AsphericCoefficients,0],getValue[6,surface2AsphericCoefficients,0],getValue[7,surface2AsphericCoefficients,0],centerThickness,diameter,opts]


(* ::Input::Initialization::Bold:: *)
drawBiAsphericLens[vertex_,R1_,k1_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,R2_,k2_,B4_,B6_,B8_,B10_,B12_,B14_,B16_,centerThickness_,diameter_,opts:OptionsPattern[drawBiAsphericLens]]:=If[OptionValue[Visible],If[OptionValue[Reverse],With[{sagExtremum1=If[R1===Infinity||R1===-Infinity,0,1/-R1*(diameter/2)^2/(1+Sqrt[1-(1+k1) (diameter/2)^2/R1^2])-A4*(diameter/2)^4-A6*(diameter/2)^6-A8*(diameter/2)^8-A10*(diameter/2)^10-A12*(diameter/2)^12-A14*(diameter/2)^14-A16*(diameter/2)^16],sagExtremum2=If[R2===Infinity||R2===-Infinity,0,1/-R2*(diameter/2)^2/(1+Sqrt[1-(1+k2) (diameter/2)^2/R2^2])-B4*(diameter/2)^4-B6*(diameter/2)^6-B8*(diameter/2)^8-B10*(diameter/2)^10-B12*(diameter/2)^12-B14*(diameter/2)^14-B16*(diameter/2)^16]},RegionPlot[r>=-diameter/2&&r<=diameter/2&&z<=vertex+centerThickness+If[R1===Infinity||R1===-Infinity,0,1/-R1*r^2/(1+Sqrt[1-(1+k1) r^2/R1^2])-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16]&&z>=vertex+If[R2==Infinity||R2==-Infinity ,0,1/-R2*r^2/(1+Sqrt[1-(1+k2) r^2/R2^2])-B4*r^4-B6*r^6-B8*r^8-B10*r^10-B12*r^12-B14*r^14-B16*r^16 ],{z,Min[vertex,vertex+sagExtremum2],Max[vertex+centerThickness,vertex+centerThickness+sagExtremum1]},{r,-diameter/2,diameter/2},AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->{Opacity[0.5],GrayLevel[0.9]}]],With[{sagExtremum1=If[R1===Infinity||R1===-Infinity,0,1/R1*(diameter/2)^2/(1+Sqrt[1-(1+k1) (diameter/2)^2/R1^2])+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16],sagExtremum2=If[R2===Infinity||R2===-Infinity,0,1/R2*(diameter/2)^2/(1+Sqrt[1-(1+k2) (diameter/2)^2/R2^2])+B4*(diameter/2)^4+B6*(diameter/2)^6+B8*(diameter/2)^8+B10*(diameter/2)^10+B12*(diameter/2)^12+B14*(diameter/2)^14+B16*(diameter/2)^16]},RegionPlot[r>=-diameter/2&&r<=diameter/2&&z>=vertex+If[R1==Infinity||R1==-Infinity ,0,1/R1*r^2/(1+Sqrt[1-(1+k1) r^2/R1^2])+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16]&&z<=vertex+centerThickness+If[R2==Infinity||R2==-Infinity ,0,1/R2*r^2/(1+Sqrt[1-(1+k2) r^2/R1^2])+B4*r^4+B6*r^6+B8*r^8*B10*r^10+B12*r^12+B14*r^14+B16*r^16] ,{z,Min[vertex,vertex+sagExtremum1],Max[vertex+centerThickness,vertex+centerThickness+sagExtremum2]},{r,-diameter/2,diameter/2},AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->{Opacity[0.5],GrayLevel[0.9]}]]],{}]


(* ::Input::Initialization::Bold:: *)
drawBiAsphericLens3D[vertex_,R1_,k1_,surface1AsphericCoefficients_,R2_,k2_,surface2AsphericCoefficients_,centerThickness_,diameter_,opts:OptionsPattern[drawBiAsphericLens]]:=drawBiAsphericLens3D[vertex,R1,k1,getValue[1,surface1AsphericCoefficients,0],getValue[2,surface1AsphericCoefficients,0],getValue[3,surface1AsphericCoefficients,0],getValue[4,surface1AsphericCoefficients,0],getValue[5,surface1AsphericCoefficients,0],getValue[6,surface1AsphericCoefficients,0],getValue[7,surface1AsphericCoefficients,0],R2,k2,getValue[1,surface2AsphericCoefficients,0],getValue[2,surface2AsphericCoefficients,0],getValue[3,surface2AsphericCoefficients,0],getValue[4,surface2AsphericCoefficients,0],getValue[5,surface2AsphericCoefficients,0],getValue[6,surface2AsphericCoefficients,0],getValue[7,surface2AsphericCoefficients,0],centerThickness,diameter,opts]


(* ::Input::Initialization::Bold:: *)
drawBiAsphericLens3D[vertex_,R1_,k1_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,R2_,k2_,B4_,B6_,B8_,B10_,B12_,B14_,B16_,centerThickness_,diameter_,opts:OptionsPattern[drawAsphericPlaneLens3D]]:=If[OptionValue[Visible],If[OptionValue[Reverse],With[{sagExtremum1=If[R1==Infinity||R1==-Infinity,0,1/-R1*(diameter/2)^2/(1+Sqrt[1-(1+k1) (diameter/2)^2/R1^2])-A4*(diameter/2)^4-A6*(diameter/2)^6-A8*(diameter/2)^8-A10*(diameter/2)^10-A12*(diameter/2)^12-A14*(diameter/2)^14-A16*(diameter/2)^16],sagExtremum2=If[R2==Infinity||R2==-Infinity,0,1/-R2*(diameter/2)^2/(1+Sqrt[1-(1+k2) (diameter/2)^2/R2^2])-B4*(diameter/2)^4-B6*(diameter/2)^6-B8*(diameter/2)^8-B10*(diameter/2)^10-B12*(diameter/2)^12-B14*(diameter/2)^14-B16*(diameter/2)^16]},RegionPlot3D[With[{r=Sqrt[x^2+y^2]},r>=-diameter/2&&r<=diameter/2 &&z<=vertex+centerThickness+If[R1===Infinity||R1===-Infinity,0,1/-R1*r^2/(1+Sqrt[1-(1+k1) r^2/R1^2])-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16]&&z>=vertex+If[R2==Infinity||R2==-Infinity,0,1/-R2*r^2/(1+Sqrt[1-(1+k2) r^2/R2^2])-B4*r^4-B6*r^6-B8*r^8-B10*r^10-B12*r^12-B14*r^14-B16*r^16]],{z,Min[vertex,vertex+sagExtremum2],Max[vertex+centerThickness,vertex+centerThickness+sagExtremum1]},{x,-diameter/2,diameter/2},{y,-diameter/2,diameter/2},BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->lens3DStyle,Mesh->None,PlotPoints->30,PlotTheme->"Monochrome"]],With[{sagExtremum1=If[R1==Infinity||R1==-Infinity,0,1/R1*(diameter/2)^2/(1+Sqrt[1-(1+k1) (diameter/2)^2/R1^2])+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16],sagExtremum2=If[R2==Infinity||R2==-Infinity,0,1/R2*(diameter/2)^2/(1+Sqrt[1-(1+k2) (diameter/2)^2/R2^2])+B4*(diameter/2)^4+B6*(diameter/2)^6+B8*(diameter/2)^8+B10*(diameter/2)^10+B12*(diameter/2)^12+B14*(diameter/2)^14+B16*(diameter/2)^16]},RegionPlot3D[With[{r=Sqrt[x^2+y^2]},r>=-diameter/2&&r<=diameter/2&&z>=vertex+If[R1===Infinity||R1===-Infinity,0,1/R1*r^2/(1+Sqrt[1-(1+k1) r^2/R1^2])+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16 ]&&z<=vertex+centerThickness+If[R2==Infinity||R2==-Infinity,0,1/R2*r^2/(1+Sqrt[1-(1+k2) r^2/R2^2])+B4*r^4+B6*r^6+B8*r^8*B10*r^10+B12*r^12+B14*r^14+B16*r^16 ]],{z,Min[vertex,vertex+sagExtremum1],Max[vertex+centerThickness,vertex+centerThickness+sagExtremum2]},{x,-diameter/2,diameter/2},{y,-diameter/2,diameter/2},BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->lens3DStyle,Mesh->None,PlotPoints->30,PlotTheme->"Monochrome"]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedAsphericSphericalLens3D]={Reverse->False,Visible->True,(*there are problems when PlotStyle is used, Mathematica uses its defaults instead of the value specified here*)LensStyle->lens3DStyle};


(* ::Input::Initialization::Bold:: *)
(*If we were to use TransformedRegion,as in 2D case, the drawing would take ages,

in the canonical orientation i.e. normal at vertex is {-1,0,0}, aspherical surface is on the left*)drawArbitrarilyOrientedAsphericSphericalLens3D[centralPoint_,normalAtVertex_,RAsph_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,R2_,centerThickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedAsphericSphericalLens3D]]:=If[OptionValue[Visible],If[Abs[R2]==\[Infinity],drawArbitrarilyOrientedAsphericPlaneLens3D[centralPoint,normalAtVertex,RAsph,k,A4,A6,A8,A10,A12,A14,A16,centerThickness,diameter],With[{vertex=centralPoint[[1]],x0=centralPoint[[2]],y0=centralPoint[[3]],normalAtVertex1=normalAtVertex[[1]],normalAtVertex2=normalAtVertex[[2]],normalAtVertex3=normalAtVertex[[3]]},With[{sagExtremumAspheric=If[Abs[RAsph]!= \[Infinity],1/RAsph*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/RAsph^2]),0]+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16,sagExtremumSpherical=If[Abs[R2]!= \[Infinity],1/R2*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/R2^2]),0]},With[{coordinateExtremum=Max[Sqrt[(diameter/2)^2+centerThickness^2],Abs[sagExtremumAspheric],centerThickness]},With[{region=ImplicitRegion[With[{zRot=normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0)-normalAtVertex1 z+vertex+normalAtVertex1 *vertex,xRot=Which[Abs[Abs[normalAtVertex1]-1]>10^-10,1/(normalAtVertex2^2+normalAtVertex3^2) (normalAtVertex2 normalAtVertex3 (-y+y0)+normalAtVertex1 normalAtVertex2 (normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0))+normalAtVertex3^2 (x+normalAtVertex2 z-normalAtVertex2 *vertex)+normalAtVertex2^2 (x0+normalAtVertex2 z-normalAtVertex2 *vertex)),Abs[1-normalAtVertex1]<10^-10,-x+2 x0,(*no rotation*)True,x],yRot=Which[Abs[Abs[normalAtVertex1]-1]>10^-10,1/(normalAtVertex2^2+normalAtVertex3^2) (-(1+normalAtVertex1) normalAtVertex2 normalAtVertex3 (x-x0)+normalAtVertex2^2 (y+normalAtVertex3 (z-vertex))+normalAtVertex3^2 (y0+normalAtVertex1 (-y+y0)+normalAtVertex3 z-normalAtVertex3 *vertex)),True,y]},If[OptionValue[Reverse],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot<= vertex+centerThickness+If[Abs[RAsph]!= \[Infinity],1/-RAsph*r^2/(1+Sqrt[1-(1+k) r^2/RAsph^2]),0]-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16&&zRot>= vertex+If[Abs[R2]!= \[Infinity],1/-R2*r^2/(1+Sqrt[1-r^2/R2^2]),0]],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot>=vertex+If[Abs[RAsph]!= \[Infinity],1/RAsph*r^2/(1+Sqrt[1-(1+k) r^2/RAsph^2]),0]+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16&&zRot<=vertex+centerThickness+If[Abs[R2]!= \[Infinity],1/R2*r^2/(1+Sqrt[1-r^2/R2^2]),0]]]] ,{{z,vertex-coordinateExtremum,vertex+coordinateExtremum},{x,x0-coordinateExtremum,x0+coordinateExtremum},{y,y0-coordinateExtremum,y0+coordinateExtremum}}]},RegionPlot3D[region,AspectRatio->Automatic,PlotPoints->120,BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->OptionValue[LensStyle],Mesh->None,PlotTheme->"Monochrome"]]]]]],{}]


(* ::Input::Initialization::Bold:: *)
defaultAchromaticFirstLensStyle3D={Opacity[0.8],Darker[Darker[RGBColor[0.839216, 0.811765, 0.627451]]]};


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedAspherizedAchromaticLens3D]={Reverse->False,Visible->True,(*there are problems when PlotStyle is used, Mathematica uses its defaults instead of the value specified here*)LensStyleSphericalComponent->defaultAchromaticFirstLensStyle3D,LensStyleAsphericalComponent->lens3DStyle};


(* ::Input::Initialization::Bold:: *)
drawArbitrarilyOrientedAspherizedAchromaticLens3D[centralPoint_,normalAtVertex_,RS1_,RS2_,RAsph_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centerThicknessSpherical_,centerThicknessAspherical_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedAspherizedAchromaticLens3D]]:=If[OptionValue[Visible],With[{centralPointSpherical=If[OptionValue[Reverse],centralPoint+centerThicknessAspherical*(-normalAtVertex),centralPoint],centralPointAspheric=If[OptionValue[Reverse],centralPoint,centralPoint+centerThicknessSpherical*(-normalAtVertex)]},Show[drawArbitrarilyOrientedSphericalLens3D[centralPointSpherical,normalAtVertex,RS1,RS2,centerThicknessSpherical,diameter,Reverse->OptionValue[Reverse],LensStyle->OptionValue[LensStyleSphericalComponent]],drawArbitrarilyOrientedAsphericSphericalLens3D[centralPointAspheric,normalAtVertex,RAsph,k,A4,A6,A8,A10,A12,A14,A16,-RS2,centerThicknessAspherical,diameter,Reverse->(!OptionValue[Reverse]),LensStyle->OptionValue[LensStyleAsphericalComponent]],PlotRange->All]],{}]


(* ::Input::Initialization::Bold:: *)
defaultSpericalPlaneLensStyle2D={Opacity[0.5],GrayLevel[0.9]};


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedSphericalLens]={Reverse->False,Visible->True,PlotStyle->defaultSpericalPlaneLensStyle2D};


(* ::Input::Initialization::Bold:: *)
drawArbitrarilyOrientedSphericalLens[centralPoint_,normalAtVertex_,R1_,R2_,centerThickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedSphericalLens]]:=With[{vertex=centralPoint[[1]]},If[OptionValue[Reverse],drawArbitrarilyOrientedSphericalLensCanonicalOrientation[centralPoint,normalAtVertex,-R2,-R1,centerThickness,diameter,opts],drawArbitrarilyOrientedSphericalLensCanonicalOrientation[centralPoint,normalAtVertex,R1,R2,centerThickness,diameter,opts]]]


(* ::Input::Initialization::Bold:: *)
drawArbitrarilyOrientedSphericalLensCanonicalOrientation[centralPoint_,normalAtVertex_,R1_,R2_,centerThickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedSphericalLens]]:=If[OptionValue[Visible],With[{vertex=centralPoint[[1]]},With[{sagS1Extremum=If[R1!=Infinity,1/R1*(diameter/2)^2/(1+Sqrt[1-(Min[diameter/2,Abs[R1]])^2/R1^2]),0],sagS2Extremum=If[R2!=Infinity,1/R2*(diameter/2)^2/(1+Sqrt[1-(Min[diameter/2,Abs[R2]])^2/R2^2]),0]},RegionPlot[TransformedRegion[ImplicitRegion[r>=-diameter/2&&r<=diameter/2&&z>=vertex+If[R1!=Infinity,1/R1*r^2/(1+Sqrt[1-r^2/R1^2]),0]&&z<=vertex+centerThickness +If[R2!=Infinity,1/R2*r^2/(1+Sqrt[1-r^2/R2^2])],{{z,Min[vertex,vertex+sagS1Extremum],Max[vertex+centerThickness,vertex+centerThickness+sagS2Extremum]},{r,-diameter/2,diameter/2}}],Composition[TranslationTransform[{0,centralPoint[[2]]}],RotationTransform[{{-1,0}, normalAtVertex},{vertex,0}]]],AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[PlotStyle]]]],{}]


(* ::Input::Initialization::Bold:: *)
defaultAchromaticFirstLensStyle2D={Opacity[0.5],RGBColor[0.839216, 0.811765, 0.627451]};


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedAspherizedAchromaticLens]={Reverse->False,Visible->True,PlotStyleSphericalComponent->defaultAchromaticFirstLensStyle2D,PlotStyleAsphericalComponent->defaultAsphericPlaneLensStyle2D};


(* ::Input::Initialization::Bold:: *)
drawArbitrarilyOrientedAspherizedAchromaticLens[centralPoint_,normalAtVertex_,RS1_,RS2_,RAsph_,k_,A4_,A6_,A8_,A10_,A12_,A14_,A16_,centerThicknessSpherical_,centerThicknessAspherical_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedAspherizedAchromaticLens]]:=If[OptionValue[Visible],With[{vertex=centralPoint[[1]],finiteRS1=(Abs[RS1]!=Infinity),finiteRS2=(Abs[RS2]!=Infinity),finiteRAsph=(Abs[RAsph]!= \[Infinity])},If[OptionValue[Reverse],With[{sagExtremumSphericalS1=If[finiteRS1,1/-RS1*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RS1^2]),0],sagExtremumSphericalS2=If[finiteRS2,1/-RS2*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RS2^2]),0],sagExtremumAsph=If[finiteRAsph,1/-RAsph*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/RAsph^2]),0]-A4*(diameter/2)^4-A6*(diameter/2)^6-A8*(diameter/2)^8-A10*(diameter/2)^10-A12*(diameter/2)^12-A14*(diameter/2)^14-A16*(diameter/2)^16},Show[RegionPlot[TransformedRegion[ImplicitRegion[r>=-diameter/2&&r<=diameter/2&&z>=  vertex+centerThicknessAspherical+If[finiteRS2,1/-RS2*r^2/(1+Sqrt[1-r^2/RS2^2]),0]&&z<=vertex+centerThicknessAspherical+centerThicknessSpherical+If[finiteRS1,1/-RS1*r^2/(1+Sqrt[1-r^2/RS1^2]),0],{{z,Min[vertex+centerThicknessAspherical,vertex+centerThicknessAspherical+sagExtremumSphericalS2],Max[vertex+centerThicknessAspherical+centerThicknessSpherical,vertex+centerThicknessAspherical+centerThicknessSpherical+sagExtremumSphericalS1]},{r,-diameter/2,diameter/2}}],Composition[TranslationTransform[{0,centralPoint[[2]]}],RotationTransform[{{-1,0}, normalAtVertex},{vertex,0}]]],AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[PlotStyleSphericalComponent]],RegionPlot[TransformedRegion[ImplicitRegion[r>=-diameter/2&&r<=diameter/2&&z>=  vertex+If[finiteRAsph,1/-RAsph*r^2/(1+Sqrt[1-(1+k) r^2/RAsph^2]),0]-A4*r^4-A6*r^6-A8*r^8-A10*r^10-A12*r^12-A14*r^14-A16*r^16&&z<=  vertex+centerThicknessAspherical+If[finiteRS2,1/(-RS2)*r^2/(1+Sqrt[1-r^2/RS2^2]),0],{{z,Min[vertex,vertex+sagExtremumAsph],Max[vertex+centerThicknessAspherical,vertex+centerThicknessAspherical+sagExtremumSphericalS2]},{r,-diameter/2,diameter/2}}],Composition[TranslationTransform[{0,centralPoint[[2]]}],RotationTransform[{{-1,0}, normalAtVertex},{vertex,0}]]],AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[PlotStyleAsphericalComponent]],PlotRange->All]],With[{sagExtremumSphericalS1=If[finiteRS1, 1/RS1*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RS1^2]),0],sagExtremumSphericalS2=If[finiteRS2,1/RS2*(diameter/2)^2/(1+Sqrt[1-(diameter/2)^2/RS2^2]),0],sagExtremumAsph=If[Abs[RAsph]!=\[Infinity],1/RAsph*(diameter/2)^2/(1+Sqrt[1-(1+k) (diameter/2)^2/RAsph^2]),0]+A4*(diameter/2)^4+A6*(diameter/2)^6+A8*(diameter/2)^8+A10*(diameter/2)^10+A12*(diameter/2)^12+A14*(diameter/2)^14+A16*(diameter/2)^16},Show[RegionPlot[TransformedRegion[ImplicitRegion[r>=-diameter/2&&r<=diameter/2&&z>=  vertex+If[finiteRS1,1/RS1*r^2/(1+Sqrt[1-r^2/RS1^2]),0]&&z<=vertex+centerThicknessSpherical+If[finiteRS2,1/RS2*r^2/(1+Sqrt[1-r^2/RS2^2]),0],{{z,Min[vertex,vertex+sagExtremumSphericalS1],Max[vertex+centerThicknessSpherical,vertex+centerThicknessSpherical+sagExtremumSphericalS2]},{r,-diameter/2,diameter/2}}],Composition[TranslationTransform[{0,centralPoint[[2]]}],RotationTransform[{{-1,0}, normalAtVertex},{vertex,0}]]],AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[PlotStyleSphericalComponent]],RegionPlot[TransformedRegion[ImplicitRegion[r>=-diameter/2&&r<=diameter/2&&z<= vertex+centerThicknessSpherical+centerThicknessAspherical+If[Abs[RAsph]!=\[Infinity],1/RAsph*r^2/(1+Sqrt[1-(1+k) r^2/RAsph^2]),0]+A4*r^4+A6*r^6+A8*r^8*A10*r^10+A12*r^12+A14*r^14+A16*r^16&&z>= vertex+centerThicknessSpherical+If[finiteRS2,1/(RS2)*r^2/(1+Sqrt[1-r^2/RS2^2]),0],{{z,Min[vertex+centerThicknessSpherical,vertex+centerThicknessSpherical+sagExtremumSphericalS2],Max[vertex+centerThicknessSpherical+centerThicknessAspherical,vertex+centerThicknessSpherical+centerThicknessAspherical+sagExtremumAsph]},{r,-diameter/2,diameter/2}}],Composition[TranslationTransform[{0,centralPoint[[2]]}],RotationTransform[{{-1,0}, normalAtVertex},{vertex,0}]]],AspectRatio->Automatic,PlotRangeClipping->False,BoundaryStyle->lensSurfaceStyle,PlotStyle->OptionValue[PlotStyleAsphericalComponent]],PlotRange->All]]]],{}]


(* ::Subsubsection::Bold:: *)
(*SCREENS AND DIAPHRAGMS*)


(* ::Input::Initialization::Bold:: *)
Options[drawArbitraryPlanarScreen2D]={Reverse->False,Visible->True};


(* ::Input::Initialization::Bold:: *)
drawArbitraryPlanarScreen2D[centralPoint_,diameter_,thickness_,normal_,opts:OptionsPattern[drawArbitraryPlanarScreen2D]]:=If[OptionValue[Visible],With[{effectiveNormal=If[OptionValue[Reverse],{-normal[[1]],normal[[2]]},normal]},With[{unitVectorParallelToSurface={-effectiveNormal[[2]],effectiveNormal[[1]]}},Graphics[{EdgeForm[Black],FaceForm[Black],Polygon[{centralPoint+diameter/2*unitVectorParallelToSurface,centralPoint+diameter/2*unitVectorParallelToSurface+thickness*(-effectiveNormal),centralPoint-diameter/2*unitVectorParallelToSurface+thickness*(-effectiveNormal),centralPoint-diameter/2*unitVectorParallelToSurface}]}]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToInteractionWithArbitraryPlanarScreen2D]={Reverse->False};


(* ::Input::Initialization::Bold:: *)
(*we assume that the ray does nor start inside the screen*)(*this is almost the same as the code for mirr, just no surface is reflective*)subjectRayToInteractionWithArbitraryPlanarScreen2D[ray_List,centralPoint_,diameter_,thickness_,normal_,opts:OptionsPattern[subjectRayToInteractionWithArbitraryPlanarScreen2D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{cz=centralPoint[[1]],cr=centralPoint[[2]]},With[{effectiveNormal=If[OptionValue[Reverse],{-normal[[1]],normal[[2]]},normal]},With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]],surfaceBCenter={cz-thickness*effectiveNormal[[1]],cr-thickness*effectiveNormal[[2]]},edgeACenter={centralPoint[[1]]-0.5*thickness*effectiveNormal[[1]]+0.5*diameter*(-effectiveNormal[[2]]),cr-0.5*thickness*effectiveNormal[[2]]+0.5*diameter*(effectiveNormal[[1]])},edgeBCenter={centralPoint[[1]]-0.5*thickness*effectiveNormal[[1]]-0.5*diameter*(-effectiveNormal[[2]]),cr-0.5*thickness*effectiveNormal[[2]]-0.5*diameter*(effectiveNormal[[1]])}},With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,diameter,centralPoint,effectiveNormal,0],rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,diameter,surfaceBCenter,effectiveNormal,0],rayIncidencePointScalarFactorListEdgeA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,thickness,edgeACenter,{-effectiveNormal[[2]],effectiveNormal[[1]]},0],rayIncidencePointScalarFactorListEdgeB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,thickness,edgeBCenter,{effectiveNormal[[2]],-effectiveNormal[[1]]},0]},With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveEdgeA = If[Length[rayIncidencePointScalarFactorListEdgeA]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeA[[1,1]]],dEffectiveEdgeB = If[Length[rayIncidencePointScalarFactorListEdgeB]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeB[[1,1]]]},Which[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveEdgeA&& dEffectiveSurfaceA<= dEffectiveEdgeB,(*ray hits the first surface of the screen*)With[{incidentZ=sz+dEffectiveSurfaceA*\[CapitalDelta]z,incidentR=sr+dEffectiveSurfaceA*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray hits the bottom surface of the screen*)(dEffectiveSurfaceB!=\[Infinity])&&dEffectiveSurfaceB<= dEffectiveSurfaceA&&dEffectiveSurfaceB<=dEffectiveEdgeA&& dEffectiveSurfaceB<= dEffectiveEdgeB,With[{incidentZ=sz+dEffectiveSurfaceB*\[CapitalDelta]z,incidentR=sr+dEffectiveSurfaceB*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray hits the first edge*)(dEffectiveEdgeA!=\[Infinity])&&dEffectiveEdgeA<= dEffectiveSurfaceA&&dEffectiveEdgeA<=dEffectiveSurfaceB&& dEffectiveEdgeA<= dEffectiveEdgeB,With[{incidentZ=sz+dEffectiveEdgeA*\[CapitalDelta]z,incidentR=sr+dEffectiveEdgeA*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray hits the second edge*)(dEffectiveEdgeB!=\[Infinity])&&dEffectiveEdgeB<= dEffectiveSurfaceA&&dEffectiveEdgeB<=dEffectiveSurfaceB&& dEffectiveEdgeB<= dEffectiveEdgeA,With[{incidentZ=sz+dEffectiveEdgeB*\[CapitalDelta]z,incidentR=sr+dEffectiveEdgeB*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray misses the screen*)True,ray]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedPlanarCircularScreen3D]=Join[{Reverse->False,(*there are problems when PlotStyle is used, Mathematica uses its defaults instead of the value specified here*)ScreenStyle->Black,Visible->True},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
(*If we were to use TransformedRegion,as in 2D case, the drawing would take ages*)drawArbitrarilyOrientedPlanarCircularScreen3D[centralPoint_,normalAtVertex_,centerThickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedPlanarCircularScreen3D]]:=If[OptionValue[Visible],With[{vertex=centralPoint[[1]],x0=centralPoint[[2]],y0=centralPoint[[3]],normalAtVertex1=normalAtVertex[[1]],normalAtVertex2=normalAtVertex[[2]],normalAtVertex3=normalAtVertex[[3]]},With[{coordinateExtremum=Sqrt[(diameter/2)^2+centerThickness^2]},With[{region=ImplicitRegion[With[{zRot=normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0)-normalAtVertex1 z+vertex+normalAtVertex1 *vertex,xRot=If[normalAtVertex2^2+normalAtVertex3^2>10^-12,1/(normalAtVertex2^2+normalAtVertex3^2) (normalAtVertex2 normalAtVertex3 (-y+y0)+normalAtVertex1 normalAtVertex2 (normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0))+normalAtVertex3^2 (x+normalAtVertex2 z-normalAtVertex2 *vertex)+normalAtVertex2^2 (x0+normalAtVertex2 z-normalAtVertex2 *vertex)),x0+normalAtVertex1 (-x+x0)],yRot=If[normalAtVertex2^2+normalAtVertex3^2>10^-12,1/(normalAtVertex2^2+normalAtVertex3^2) (-(1+normalAtVertex1) normalAtVertex2 normalAtVertex3 (x-x0)+normalAtVertex2^2 (y+normalAtVertex3 (z-vertex))+normalAtVertex3^2 (y0+normalAtVertex1 (-y+y0)+normalAtVertex3 z-normalAtVertex3 *vertex)),y]},If[OptionValue[Reverse],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot<= vertex+centerThickness&&zRot>= vertex],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot>=vertex&&zRot<=vertex+centerThickness]]] ,{{z,vertex-coordinateExtremum,vertex+coordinateExtremum},{x,x0-coordinateExtremum,x0+coordinateExtremum},{y,y0-coordinateExtremum,y0+coordinateExtremum}}],plotOptions=FilterRules[{opts},Options[RegionPlot3D]]},RegionPlot3D[region,AspectRatio->Automatic,PlotPoints->70,BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->OptionValue[ScreenStyle],Mesh->None,PlotTheme->"Monochrome",plotOptions]]]],{}]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToInteractionWithArbitraryPlanarCircularScreen3D]={Reverse->False};


(* ::Input::Initialization::Bold:: *)
(*we assume that the ray does nor start inside the screen*)(*this is almost the same as the code for mirr, just no surface is reflective*)subjectRayToInteractionWithArbitraryPlanarCircularScreen3D[ray_List,centralPoint_,diameter_,thickness_,normal_,opts:OptionsPattern[subjectRayToInteractionWithArbitraryPlanarCircularScreen3D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{effectiveNormal=If[OptionValue[Reverse],{-normal[[1]],normal[[2]],normal[[3]]},normal]},With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],surfaceBCenter=centralPoint-thickness*effectiveNormal},With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter,centralPoint,effectiveNormal,0],rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter,surfaceBCenter,effectiveNormal,0],rayIncidencePointScalarFactorListEdge=findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter/2,thickness,centralPoint,normal,0]},With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveEdge = If[Length[rayIncidencePointScalarFactorListEdge]<1,\[Infinity],rayIncidencePointScalarFactorListEdge[[1,1]]]},Which[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveEdge,(*ray hits the first surface of the screen*)With[{incidentZ=sz+dEffectiveSurfaceA*\[CapitalDelta]z,incidentX=sx+dEffectiveSurfaceA*\[CapitalDelta]x,incidentY=sy+dEffectiveSurfaceA*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},Null,ray[[-1,-1]]}]],(*ray hits the bottom surface of the scree*)(dEffectiveSurfaceB!=\[Infinity])&&dEffectiveSurfaceB<= dEffectiveSurfaceA&&dEffectiveSurfaceB<=dEffectiveEdge,With[{incidentZ=sz+dEffectiveSurfaceB*\[CapitalDelta]z,incidentX=sx+dEffectiveSurfaceB*\[CapitalDelta]x,incidentY=sy+dEffectiveSurfaceB*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},Null,ray[[-1,-1]]}]],(*ray hits the first edge*)(dEffectiveEdge!=\[Infinity])&&dEffectiveEdge<= dEffectiveSurfaceA&&dEffectiveEdge<=dEffectiveSurfaceB,With[{incidentZ=sz+dEffectiveEdge*\[CapitalDelta]z,incidentX=sx+dEffectiveEdge*\[CapitalDelta]x,incidentY=sy+dEffectiveEdge*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},Null,ray[[-1,-1]]}]],(*ray misses the screen*)True,ray]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[createArbitraryPlanarScreen]=Join[{Reverse->False,Visible->True},Options[GeneralOptomechanicalPart]];


(* ::Code::Initialization::Bold:: *)
createArbitraryPlanarScreen[vertex_?NumericQ,diameter_?NumericQ,thickness_?NumericQ, normal_List,opts:OptionsPattern[createArbitraryPlanarScreen]]:=createArbitraryPlanarScreen[{vertex,0,0},diameter,thickness,normal,opts]


(* ::Input::Initialization::Bold:: *)
createArbitraryPlanarScreen[centralPoint_List,diameter_?NumericQ,thickness_?NumericQ,normal_List,opts:OptionsPattern[createArbitraryPlanarScreen]]:=Module[{self,unitVectorParallelToSurface=If[OptionValue[Reverse],{normal[[2]],-normal[[1]]},{-normal[[2]],normal[[1]]}]},With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal]},self=Association["objectType"->"screen","objectId"->OptionValue[PartId],"surfaceCount"->1,"minimalCenterZ"->centralPoint[[1]],"vertex"->centralPoint[[1]],"thickness"->thickness,"reflectance"->0,"draw2D"->(drawArbitraryPlanarScreen2D[centralPoint,diameter,thickness,normal,FilterRules[{opts},Options[drawArbitraryPlanarScreen2D]]]&),"draw3D"->((drawArbitrarilyOrientedPlanarCircularScreen3D[centralPoint,normal,thickness,diameter,FilterRules[{opts},Options[drawArbitrarilyOrientedPlanarCircularScreen3D]]])&),"interactWithRays2D"->Function[{rays,surroundingMedium},self["reflectRays2D"][rays,surroundingMedium]],"reflectRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],wavelength=raysObject["wavelength"],optsInteraction=FilterRules[{opts},Options[subjectRayToInteractionWithArbitraryPlanarScreen2D]]},createRaysObject[ParallelMap[subjectRayToInteractionWithArbitraryPlanarScreen2D[#,centralPoint,diameter,thickness,normal,optsInteraction]&,rays],raysObject["wavelength"]]]]),"reflectRays2DAndDraw"->Function[{raysObject,surroundingMedium},With[{reflectedRays=(self["reflectRays2D"][raysObject,surroundingMedium])["traces"]},Show[Graphics[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw2D"][]]]],"reflectRaysUpToScreen2D"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{raysAfterSecondSurface=self["reflectRays2D"][raysObject,surroundingMedium]},ParallelMap[subjectRayToInteractionWithVerticalScreen[#,screenZPosition,screenDiameter]&,raysAfterSecondSurface]]],"reflectRaysUpToScreen2DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=self["reflectRaysUpToScreen2D"][raysObject,surroundingMedium,screenZPosition,screenDiameter]},Show[Graphics[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw2D"][]]]],"interactWithRays3D"->Function[{raysObject,surroundingMedium},self["reflectRays3D"][raysObject,surroundingMedium]],"reflectRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],optsInteraction=FilterRules[{opts},Options[subjectRayToInteractionWithArbitraryPlanarCircularScreen3D]]},createRaysObject[ParallelMap[subjectRayToInteractionWithArbitraryPlanarCircularScreen3D[#,centralPoint,diameter,thickness,normal,optsInteraction]&,rays],raysObject["wavelength"]]]]),"reflectRaysUpToScreen3D"->(Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=self["reflectRays3D"][raysObject,surroundingMedium]},Table[subjectRayToInteractionWithVerticalScreen3D[reflectedRays[[l]],screenZPosition,screenDiameter],{l,1,Length[reflectedRays]}]]]),"reflectRays3DAndDraw"->Function[{raysObject,surroundingMedium},With[{reflectedRays=self["reflectRays3D"][raysObject,surroundingMedium]},Show[Graphics3D[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw3D"][]]]],"reflectRaysUpToScreen3DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=self["reflectRaysUpToScreen3D"][raysObject,surroundingMedium,screenZPosition,screenDiameter]},Show[Graphics3D[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw3D"][]]]],"createShiftedCopy"->Function[{vertexShift},createThinLens[centralPoint + {vertexShift,0,0},diameter,thickness,normal,opts]]]]]


(* ::Code::Initialization::Bold:: *)
createCircularVerticalScreen[vertex_?NumericQ,diameter_?NumericQ]:=createCircularVerticalScreen[{vertex,0,0},diameter]


(* ::Input::Initialization::Bold:: *)
createCircularVerticalScreen[centerPoint_List,diameter_?NumericQ]:=Module[{self},self=Association["objectType"->"screen","surfaceCount"->1,"minimalCenterZ"->centerPoint[[1]],"vertex"->centerPoint[[1]],"diameter"->diameter,"draw2D"->(With[{centerZ=centerPoint[[1]],centerR=centerPoint[[2]]},(Graphics[{screen2DStyle,Line[{{centerZ,-diameter/2+centerR},{centerZ,diameter/2+centerR}}]},AspectRatio->Automatic])]&),"draw3D"->((With[{centerZ=centerPoint[[1]],centerX=centerPoint[[2]],centerY=centerPoint[[3]]},RegionPlot3D[With[{r=Sqrt[(x-centerX)^2+(y-centerY)^2]},z==centerZ&&r<=diameter/2 ],{z,centerZ-1,centerZ+1},{x,-diameter/2+centerX,diameter/2+centerX},{y,-diameter/2+centerY,diameter/2+centerY},BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->screen3DStyle,Mesh->None,PlotTheme->"Monochrome"]])&),"interactWithRays2D"->Function[{raysObject},createRaysObject[With[{rays=raysObject["traces"]},Table[subjectRayToInteractionWithVerticalScreen[rays[[i]],centerPoint,diameter],{i,1,Length[rays]}]],raysObject["wavelength"]]],"interactWithRays3D"->Function[{raysObject},createRaysObject[With[{rays=raysObject["traces"]},Table[subjectRayToInteractionWithVerticalScreen3D[rays[[i]],centerPoint,diameter],{i,1,Length[rays]}]],raysObject["wavelength"]]],"createShiftedCopy"->Function[{vertexShift},createCircularVerticalScreen[centerPoint+{vertexShift,0,0},diameter]]]]


(* ::Code::Initialization::Bold:: *)
createCircularVerticalDiaphragm[vertex_?NumericQ,innerDiameter_?NumericQ,outerDiameter_?NumericQ]:=createCircularVerticalDiaphragm[{vertex,0,0},innerDiameter,outerDiameter]


(* ::Input::Initialization::Bold:: *)
createCircularVerticalDiaphragm[centerPoint_List,innerDiameter_?NumericQ,outerDiameter_?NumericQ]:=Module[{self},self=Association["objectType"->"diaphragm","surfaceCount"->1,"minimalCenterZ"->centerPoint[[1]],"vertex"->centerPoint[[1]],"diameter"->outerDiameter,"innerDiameter"->innerDiameter,"outerDiameter"->outerDiameter,"draw2D"->((With[{centerZ=centerPoint[[1]],centerR=centerPoint[[2]]},Graphics[{Line[{{centerZ,-outerDiameter/2+centerR},{centerZ,-innerDiameter/2+centerR}}],Line[{{centerZ,innerDiameter/2+centerR},{centerZ,outerDiameter/2+centerR}}]},AspectRatio->Automatic]])&),"draw3D"->((With[{centerZ=centerPoint[[1]],centerX=centerPoint[[2]],centerY=centerPoint[[3]]},RegionPlot3D[With[{r=Sqrt[(x-centerX)^2+(y-centerY)^2]},z==centerZ&&r>=innerDiameter/2&&r<=outerDiameter/2 ],{z,centerZ-1,centerZ+1},{x,-outerDiameter/2+centerX,outerDiameter/2+centerX},{y,-outerDiameter/2+centerY,outerDiameter/2+centerY},BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->screen3DStyle,Mesh->None,PlotTheme->"Monochrome"]])&),"interactWithRays2D"->Function[{raysObject},createRaysObject[With[{rays=raysObject["traces"]},Table[subjectRayToInteractionWithCircularDiaphragm2D[rays[[i]],centerPoint,innerDiameter,outerDiameter],{i,1,Length[rays]}]],raysObject["wavelength"]]],"interactWithRays3D"->Function[{raysObject},createRaysObject[With[{rays=raysObject["traces"]},Table[subjectRayToInteractionWithCircularDiaphragm3D[rays[[i]],centerPoint,innerDiameter,outerDiameter],{i,1,Length[rays]}]],raysObject["wavelength"]]],"createShiftedCopy"->Function[{vertexShift},createCircularVerticalDiaphragm[centerPoint+{vertexShift,0,0},innerDiameter,outerDiameter]]]]


(* ::Subsubsection::Bold:: *)
(*INTERACTION WITH SCREENS AND DIAPHRAGMS*)


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithVerticalScreen[ray_List,screenZPosition_?NumericQ,screenDiameter_?NumericQ]:=subjectRayToInteractionWithVerticalScreen[ray,{screenZPosition,0},screenDiameter]


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithVerticalScreen[ray_List,screenCenter_List,screenDiameter_?NumericQ]:=(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{scz=screenCenter[[1]],scr=screenCenter[[2]]},With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],scz]},If[rayIncidencePoint===Null||Length[rayIncidencePoint]<= 1||Abs[(rayIncidencePoint[[2]]-scr)]>screenDiameter/2,ray,Append[ray,{rayIncidencePoint,Null,ray[[-1,-1]]}]]]]])


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithVerticalScreen3D[ray_List,screenZPosition_?NumericQ,screenDiameter_?NumericQ]:=subjectRayToInteractionWithVerticalScreen3D[ray,{screenZPosition,0,0},screenDiameter]


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithVerticalScreen3D[ray_List,screenCenter_List,screenDiameter_?NumericQ]:=(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{scz=screenCenter[[1]],scx=screenCenter[[2]],scy=screenCenter[[3]]},With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection3D[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,1,3]],ray[[-1,2,1]],ray[[-1,2,2]],ray[[-1,2,3]],scz]},If[Length[rayIncidencePoint]<= 2||Sqrt[(rayIncidencePoint[[2]]-scx)^2+(rayIncidencePoint[[3]]-scy)^2]>screenDiameter/2,ray,Append[ray,{rayIncidencePoint,Null,ray[[-1,-1]]}]]]]])


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithCircularDiaphragm2D[ray_List,center_List,innerDiameter_?NumericQ,outerDiameter_?NumericQ]:=(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{cz=center[[1]],cr=center[[2]]},With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],cz]},If[Length[rayIncidencePoint]<= 1||Abs[rayIncidencePoint[[2]]-cr]>outerDiameter/2||Abs[rayIncidencePoint[[2]]-cr]<innerDiameter/2,ray,Append[ray,{rayIncidencePoint,Null,ray[[-1,-1]]}]]]]])


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithCircularDiaphragm2D[ray_List,centerZPosition_?NumericQ,innerDiameter_?NumericQ,outerDiameter_?NumericQ]:=subjectRayToInteractionWithCircularDiaphragm2D[ray,{centerZPosition,0,0},innerDiameter,outerDiameter]


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithCircularDiaphragm3D[ray_List,center_List,innerDiameter_?NumericQ,outerDiameter_?NumericQ]:=(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{cz=center[[1]],cx=center[[2]],cy=center[[3]]},With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection3D[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,1,3]],ray[[-1,2,1]],ray[[-1,2,2]],ray[[-1,2,3]],cz]},If[Length[rayIncidencePoint]<= 2||With[{r=Sqrt[(rayIncidencePoint[[2]]-cx)^2+(rayIncidencePoint[[3]]-cy)^2]},r>outerDiameter/2||r<innerDiameter/2],ray,Append[ray,{rayIncidencePoint,Null,ray[[-1,-1]]}]]]]])


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithCircularDiaphragm3D[ray_List,centerZPosition_?NumericQ,innerDiameter_?NumericQ,outerDiameter_?NumericQ]:=subjectRayToInteractionWithCircularDiaphragm3D[ray,{centerZPosition,0,0},innerDiameter,outerDiameter]


(* ::Subsubsection::Bold:: *)
(*MIRRORS*)


(* ::Input::Initialization::Bold:: *)
Options[createAbstractMirror]=Join[{Reverse->False},Options[GeneralOptomechanicalPart]];


(* ::Input::Initialization::Bold:: *)
createAbstractMirror[self_,centralPoint_List,reflectanceFunction_Function,opts:OptionsPattern[createAbstractMirror]]:=Association["objectType"->"mirror","objectId"->OptionValue[PartId],"surfaceCount"->1,"vertex"->centralPoint[[1]],"reflectance"->reflectanceFunction,"interactWithRays2D"->Function[{rays,surroundingMedium},self["reflectRays2D"][rays,surroundingMedium]],"reflectRays2DAndDraw"->Function[{raysObject,surroundingMedium},With[{reflectedRays=(self["reflectRays2D"][raysObject,surroundingMedium])["traces"]},Show[Graphics[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw2D"][]]]],"reflectRaysUpToScreen2D"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{raysAfterSecondSurface=self["reflectRays2D"][raysObject,surroundingMedium]},ParallelMap[subjectRayToInteractionWithVerticalScreen[#,screenZPosition,screenDiameter]&,raysAfterSecondSurface]]],"reflectRaysUpToScreen2DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=self["reflectRaysUpToScreen2D"][raysObject,surroundingMedium,screenZPosition,screenDiameter]},Show[Graphics[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw2D"][]]]],"interactWithRays3D"->Function[{raysObject,surroundingMedium},self["reflectRays3D"][raysObject,surroundingMedium]],"reflectRaysUpToScreen3D"->(Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=(self["reflectRays3D"][raysObject,surroundingMedium])["traces"]},createRaysObject[ParallelMap[(If[#===Null,Null,subjectRayToInteractionWithVerticalScreen3D[#,screenZPosition,screenDiameter]])&,reflectedRays],raysObject["wavelength"]]]]),"reflectRays3DAndDraw"->Function[{raysObject,surroundingMedium},With[{reflectedRays=(self["reflectRays3D"][raysObject,surroundingMedium])["traces"]},Show[Graphics3D[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw3D"][]]]],"reflectRaysUpToScreen3DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=(self["reflectRaysUpToScreen3D"][raysObject,surroundingMedium,screenZPosition,screenDiameter])["traces"]},Show[Graphics3D[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw3D"][]]]]]


(* ::Input::Initialization::Bold:: *)
Options[createPlanarCircularMirror]=Join[Options[createAbstractMirror],Options[subjectRayToInteractionWithArbitraryPlanarCircularMirror3D]];


(* ::Code::Initialization::Bold:: *)
createPlanarCircularMirror[vertex_?NumericQ,normal_List,diameter_?NumericQ,thickness_?NumericQ,reflectance_?NumericQ,opts:OptionsPattern[createPlanarCircularMirror]]:=createPlanarCircularMirror[{vertex,0,0},normal,diameter,thickness,(reflectance&),opts]


(* ::Code::Initialization::Bold:: *)
createPlanarCircularMirror[vertex_?NumericQ,normal_List,diameter_?NumericQ,thickness_?NumericQ,reflectanceFunction_Function,opts:OptionsPattern[createPlanarCircularMirror]]:=createPlanarCircularMirror[{vertex,0,0},normal,diameter,thickness,reflectanceFunction,opts]


(* ::Code::Initialization::Bold:: *)
createPlanarCircularMirror[centralPoint_List, normal_List, diameter_?NumericQ, thickness_?NumericQ,reflectance_?NumericQ,opts:OptionsPattern[createPlanarCircularMirror]]:=createPlanarCircularMirror[centralPoint, normal, diameter, thickness,(reflectance&), opts]


(* ::Input::Initialization::Bold:: *)
createPlanarCircularMirror[centerPoint_List,normal_List,diameter_?NumericQ,thickness_?NumericQ,reflectanceFunction_Function,opts:OptionsPattern[createPlanarCircularMirror]]:=Module[{self},self=Association[{createAbstractMirror[self,centerPoint,reflectanceFunction,FilterRules[{opts},Options[createAbstractMirror]]],Association["minimalCenterZ"->centerPoint[[1]],"thickness"->thickness,"draw2D"->(drawPlanarMirror2D[centerPoint,diameter,thickness,normal,FilterRules[{opts},Options[drawPlanarMirror2D]]]&),"draw3D"->(drawArbitrarilyOrientedPlanarCircularMirror3D[centerPoint,normal,thickness,diameter,FilterRules[{opts},Options[drawArbitrarilyOrientedPlanarCircularMirror3D]]]&),"reflectRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],reflectance=reflectanceFunction[raysObject["wavelength"]],optsReflection=FilterRules[{opts},Options[subjectRayToReflectionOnArbitraryPlanarMirror2D]]},createRaysObject[With[{raysAfterReflection=ParallelMap[subjectRayToReflectionOnArbitraryPlanarMirror2D[#,centerPoint,diameter,thickness,normal,reflectance,optsReflection]&,rays]},raysAfterReflection],raysObject["wavelength"]]]]),"reflectRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],reflectance=reflectanceFunction[raysObject["wavelength"]],optsReflection=FilterRules[{opts},Options[subjectRayToInteractionWithArbitraryPlanarCircularMirror3D]]},createRaysObject[With[{raysAfterReflection=ParallelMap[subjectRayToInteractionWithArbitraryPlanarCircularMirror3D[#,centerPoint,diameter,thickness,normal,reflectance,optsReflection]&,rays]},raysAfterReflection],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createPlanarCircularMirror[centerPoint+{vertexShift,0,0},diameter,thickness,normal,reflectanceFunction,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createPlanarRectangularMirror]=Join[Options[createAbstractMirror],Options[subjectRayToInteractionWithArbitraryPlanarRectangularMirror3D]];


(* ::Code::Initialization::Bold:: *)
createPlanarRectangularMirror[vertex_?NumericQ, normal_List,xLength_?NumericQ,yLength_?NumericQ,thickness_?NumericQ,reflectance_?NumericQ,opts:OptionsPattern[createPlanarRectangularMirror]]:=createPlanarRectangularMirror[{vertex,0,0},normal,xLength,yLength,thickness,(reflectance&),opts]


(* ::Code::Initialization::Bold:: *)
createPlanarRectangularMirror[vertex_?NumericQ, normal_List,xLength_?NumericQ,yLength_?NumericQ,thickness_?NumericQ,reflectanceFunction_Function,opts:OptionsPattern[createPlanarRectangularMirror]]:=createPlanarRectangularMirror[{vertex,0,0},normal,xLength,yLength,thickness,reflectanceFunction,opts]


(* ::Code::Initialization::Bold:: *)
createPlanarRectangularMirror[centerPoint_List,normal_List,xLength_?NumericQ,yLength_?NumericQ,thickness_?NumericQ,reflectance_?NumericQ,opts:OptionsPattern[createPlanarRectangularMirror]]:=createPlanarRectangularMirror[centerPoint,normal,xLength,yLength,thickness,(reflectance&),opts]


(* ::Input::Initialization::Bold:: *)
createPlanarRectangularMirror[centerPoint_List,normal_List,xLength_?NumericQ,yLength_?NumericQ,thickness_?NumericQ,reflectanceFunction_Function,opts:OptionsPattern[createPlanarRectangularMirror]]:=Module[{self},self=Association[{createAbstractMirror[self,centerPoint,reflectanceFunction,FilterRules[{opts},Options[createAbstractMirror]]],Association["minimalCenterZ"->centerPoint[[1]],"thickness"->thickness,"xLength"->xLength,"yLength"->yLength,"draw2D"->(drawPlanarMirror2D[centerPoint,yLength,thickness,normal,FilterRules[{opts},Options[drawPlanarMirror2D]]]&),"draw3D"->(drawArbitrarilyOrientedPlanarRectangularMirror3D[centerPoint,normal,thickness,xLength,yLength,FilterRules[{opts},Options[drawArbitrarilyOrientedPlanarRectangularMirror3D]]]&),"reflectRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],reflectance=reflectanceFunction[raysObject["wavelength"]],optsReflection=FilterRules[{opts},Options[subjectRayToReflectionOnArbitraryPlanarMirror2D]]},createRaysObject[With[{raysAfterReflection=ParallelMap[subjectRayToReflectionOnArbitraryPlanarMirror2D[#,centerPoint,yLength,thickness,normal,reflectance,optsReflection]&,rays]},raysAfterReflection],raysObject["wavelength"]]]]),"reflectRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],reflectance=reflectanceFunction[raysObject["wavelength"]],optsReflection=FilterRules[{opts},Options[subjectRayToInteractionWithArbitraryPlanarRectangularMirror3D]]},createRaysObject[With[{raysAfterReflection=ParallelMap[subjectRayToInteractionWithArbitraryPlanarRectangularMirror3D[#,centerPoint,normal,thickness,xLength,yLength,reflectance,optsReflection]&,rays]},raysAfterReflection],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createPlanarRectangularMirror[centerPoint + {vertexShift,0,0},normal,thickness,xLength,yLength,reflectanceFunction,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createPrismMirror]=Join[Options[createAbstractMirror],Options[subjectRayToInteractionWithArbitraryPlanarPrismMirror3D]];


(* ::Code::Initialization::Bold:: *)
createPrismMirror[vertex_?NumericQ, normal_List,xSideLength_?NumericQ,zlegLength_?NumericQ,yLegLength_?NumericQ,reflectance_?NumericQ,opts:OptionsPattern[createPrismMirror]]:=createPrismMirror[{vertex,0,0},normal,xSideLength,zlegLength,yLegLength,(reflectance&), opts]


(* ::Code::Initialization::Bold:: *)
createPrismMirror[vertex_?NumericQ, normal_List,xSideLength_?NumericQ,zlegLength_?NumericQ,yLegLength_?NumericQ,reflectanceFunction_Function,opts:OptionsPattern[createPrismMirror]]:=createPrismMirror[{vertex,0,0},normal,xSideLength,zlegLength,yLegLength,reflectanceFunction,opts]


(* ::Code::Initialization::Bold:: *)
createPrismMirror[centralPoint_List,normal_List,xSideLength_?NumericQ,zlegLength_?NumericQ,yLegLength_?NumericQ,reflectance_?NumericQ,opts:OptionsPattern[createPrismMirror]]:=createPrismMirror[centralPoint,normal,xSideLength,zlegLength,yLegLength,(reflectance&),opts]


(* ::Input::Initialization::Bold:: *)
createPrismMirror[centralPoint_List,normal_List,xSideLength_?NumericQ,zLegLength_?NumericQ,yLegLength_?NumericQ,reflectanceFunction_Function,opts:OptionsPattern[createPrismMirror]]:=Module[{self},self=Association[{createAbstractMirror[self,centralPoint,reflectanceFunction,FilterRules[{opts},Options[createAbstractMirror]]],Association["minimalCenterZ"->centralPoint[[1]],"zLength"->zLegLength,"xLength"->xSideLength,"yLength"->yLegLength,"draw2D"->(drawPrismMirror2D[centralPoint,normal,0.02*zLegLength,zLegLength,yLegLength,FilterRules[{opts},Options[drawPrismMirror2D]]]&),"draw3D"->(drawPrismMirror3D[centralPoint,normal,0.02*zLegLength,xSideLength,zLegLength,yLegLength,FilterRules[{opts},Options[drawPrismMirror3D]]]&),"reflectRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],reflectance=reflectanceFunction[raysObject["wavelength"]],optsReflection=FilterRules[{opts},Options[subjectRayToInteractionWithArbitraryPlanarPrismMirror2D]]},createRaysObject[With[{raysAfterReflection=ParallelMap[subjectRayToInteractionWithArbitraryPlanarPrismMirror2D[#,centralPoint,normal,zLegLength,yLegLength,reflectance,optsReflection]&,rays]},raysAfterReflection],raysObject["wavelength"]]]]),"reflectRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],reflectance=reflectanceFunction[raysObject["wavelength"]],optsReflection=FilterRules[{opts},Options[subjectRayToInteractionWithArbitraryPlanarPrismMirror3D]]},createRaysObject[With[{raysAfterReflection=ParallelMap[subjectRayToInteractionWithArbitraryPlanarPrismMirror3D[#,centralPoint,normal,xSideLength,zLegLength,yLegLength,reflectance,optsReflection]&,rays]},raysAfterReflection],raysObject["wavelength"]]]]),"createShiftedCopy"->Function[{vertexShift},createPrismMirror[centralPoint + {vertexShift,0,0},normal,xSideLength,zLegLength,yLegLength,reflectanceFunction,opts]]]}]]


(* ::Input::Initialization::Bold:: *)
Options[createDichroicCircularPlanarMirror]=Join[{Reverse->False},Options[subjectRayToReflectionOnArbitraryPlanarDichroicMirror2D],Options[GeneralOptomechanicalPart]];


(* ::Code::Initialization::Bold:: *)
createDichroicCircularPlanarMirror[vertex_?NumericQ,normal_List,diameter_?NumericQ,thickness_?NumericQ,(*pure function of wavelength*)reflectanceFunction_Function,transmittanceFunction_Function,glass_String,opts:OptionsPattern[createDichroicCircularPlanarMirror]]:=createDichroicCircularPlanarMirror[{vertex,0,0},normal,diameter,thickness,reflectanceFunction,transmittanceFunction,glass,opts]


(* ::Code::Initialization::Bold:: *)
createDichroicCircularPlanarMirror[vertex_?NumericQ,normal_List,diameter_?NumericQ,thickness_?NumericQ,reflectance_?NumericQ,transmittance_?NumericQ,glass_String,opts:OptionsPattern[createDichroicCircularPlanarMirror]]:=createDichroicCircularPlanarMirror[{vertex,0,0},normal,diameter,thickness,(reflectance&),(transmittance&),glass,opts]


(* ::Code::Initialization::Bold:: *)
createDichroicCircularPlanarMirror[centerPoint_List,normal_List,diameter_?NumericQ,thickness_?NumericQ,reflectance_?NumericQ,transmittance_?NumericQ,glass_String,opts:OptionsPattern[createDichroicCircularPlanarMirror]]:=createDichroicCircularPlanarMirror[centerPoint,normal,diameter,thickness,(reflectance&),(transmittance&),glass,opts]


(* ::Input::Initialization::Bold:: *)
createDichroicCircularPlanarMirror[centerPoint_List,normal_List,diameter_?NumericQ,thickness_?NumericQ,(*pure function of wavelength*)reflectanceFunction_Function,transmittanceFunction_Function,glass_String,opts:OptionsPattern[createDichroicCircularPlanarMirror]]:=Module[{self},self=Association["objectType"->"combiningMirror","objectId"->OptionValue[PartId],"surfaceCount"->1,"minimalCenterZ"->centerPoint[[1]],"vertex"->centerPoint[[1]],"thickness"->thickness,"reflectanceFunction"->reflectanceFunction,"transmittanceFunction"->transmittanceFunction,"draw2D"->(drawPlanarMirror2D[centerPoint,diameter,thickness,normal,BothSidesTransparent->True,FilterRules[{opts},Options[drawPlanarMirror2D]]]&),"draw3D"->(drawArbitrarilyOrientedPlanarCircularFlat3D[centerPoint,normal,thickness,diameter,PlotStyle->{Opacity[0.5],GrayLevel[0.6]}]&),"interactWithRays2D"->Function[{rays,surroundingMedium},self["reflectRays2D"][rays,surroundingMedium]],"reflectRays2D"->(Function[{raysObject,surroundingMedium},With[{wavelength=raysObject["wavelength"]},With[{rays=raysObject["traces"],optsReflection=FilterRules[{opts},Options[subjectRayToReflectionOnArbitraryPlanarDichroicMirror2D]],n1=getGlassRefractiveIndex[wavelength,surroundingMedium],n2=getGlassRefractiveIndex[wavelength,glass],reflectance=reflectanceFunction[wavelength],transmittance=transmittanceFunction[wavelength]},createRaysObject[With[{raysAfterReflection=ParallelMap[releaseHold[subjectRayToReflectionOnArbitraryPlanarDichroicMirror2D[#,centerPoint,diameter,thickness,normal,reflectance,transmittance,n1,n2,optsReflection]]&,rays]},raysAfterReflection],wavelength]]]]),"reflectRays2DAndDraw"->Function[{raysObject,surroundingMedium},With[{reflectedRays=(self["reflectRays2D"][raysObject,surroundingMedium])["traces"]},Show[Graphics[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw2D"][]]]],"reflectRaysUpToScreen2D"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{raysAfterSecondSurface=self["reflectRays2D"][raysObject,surroundingMedium]},ParallelMap[subjectRayToInteractionWithVerticalScreen[#,screenZPosition,screenDiameter]&,raysAfterSecondSurface]]],"reflectRaysUpToScreen2DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=self["reflectRaysUpToScreen2D"][raysObject,surroundingMedium,screenZPosition,screenDiameter]},Show[Graphics[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw2D"][]]]],"interactWithRays3D"->Function[{raysObject,surroundingMedium},self["reflectRays3D"][raysObject,surroundingMedium]],"reflectRays3D"->(Function[{raysObject,surroundingMedium},With[{wavelength=raysObject["wavelength"]},With[{rays=raysObject["traces"],optsReflection=FilterRules[{opts},Options[subjectRayToReflectionOnArbitraryPlanarDichroicMirror3D]],n1=getGlassRefractiveIndex[wavelength,surroundingMedium],n2=getGlassRefractiveIndex[wavelength,glass],reflectance=reflectanceFunction[wavelength],transmittance=transmittanceFunction[wavelength]},createRaysObject[With[{raysAfterReflection=ParallelMap[releaseHold[subjectRayToReflectionOnArbitraryPlanarDichroicMirror3D[#,centerPoint,diameter,thickness,normal,reflectance,transmittance,n1,n2,optsReflection]]&,rays]},raysAfterReflection],wavelength]]]]),"reflectRaysUpToScreen3D"->(Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=self["reflectRays3D"][raysObject,surroundingMedium]},Table[subjectRayToInteractionWithVerticalScreen3D[reflectedRays[[l]],screenZPosition,screenDiameter],{l,1,Length[reflectedRays]}]]]),"reflectRays3DAndDraw"->Function[{raysObject,surroundingMedium},With[{reflectedRays=self["reflectRays3D"][raysObject,surroundingMedium]},Show[Graphics3D[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw3D"][]]]],"reflectRaysUpToScreen3DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{reflectedRays=self["reflectRaysUpToScreen3D"][raysObject,surroundingMedium,screenZPosition,screenDiameter]},Show[Graphics3D[Table[Table[Line[{reflectedRays[[i,j,1]],reflectedRays[[i,j+1,1]]}],{j,1,Length[reflectedRays[[i]]]-1}],{i,1,Length[reflectedRays]}]],self["draw3D"][]]]],"createShiftedCopy"->Function[{vertexShift},createDichroicCircularPlanarMirror[centerPoint + {vertexShift,0},normal,diameter,thickness,reflectanceFunction,transmittanceFunction,glass,opts]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawPlanarMirror2D]={Reverse->False,BothSidesTransparent->False};


(* ::Input::Initialization::Bold:: *)
drawPlanarMirror2D[centralPoint_,diameter_,thickness_,normal_,opts:OptionsPattern[drawPlanarMirror2D]]:=With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-thickness*normal,centralPoint],reflectiveLayerThicknessFactor=0.4},With[{unitVectorParallelToSurface={-effectiveNormal[[2]],effectiveNormal[[1]]}},Graphics[{EdgeForm[Black],If[!OptionValue[BothSidesTransparent],{FaceForm[GrayLevel[0.1]],Polygon[{effectiveCentralPoint+diameter/2*unitVectorParallelToSurface,effectiveCentralPoint+diameter/2*unitVectorParallelToSurface+thickness*(-effectiveNormal),effectiveCentralPoint-diameter/2*unitVectorParallelToSurface+thickness*(-effectiveNormal),effectiveCentralPoint-diameter/2*unitVectorParallelToSurface}]},{}],FaceForm[GrayLevel[0.8]],With[{reflectiveLayerThickness=If[!OptionValue[BothSidesTransparent],reflectiveLayerThicknessFactor*thickness,thickness]},Polygon[{effectiveCentralPoint+diameter/2*unitVectorParallelToSurface,effectiveCentralPoint+diameter/2*unitVectorParallelToSurface+reflectiveLayerThickness*(-effectiveNormal),effectiveCentralPoint-diameter/2*unitVectorParallelToSurface+reflectiveLayerThickness*(-effectiveNormal),effectiveCentralPoint-diameter/2*unitVectorParallelToSurface}]]}]]]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedPlanarCircularMirror3D]=Join[{Reverse->False,ReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.4]],NonReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.05]]},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
(*If we were to use TransformedRegion,as in 2D case, the drawing would take ages*)drawArbitrarilyOrientedPlanarCircularMirror3D[centralPoint_,normalAtVertex_,thickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedPlanarCircularMirror3D]]:=With[{effectiveNormal=If[OptionValue[Reverse],-normalAtVertex,normalAtVertex],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-thickness*normalAtVertex,centralPoint]},With[{vertex=effectiveCentralPoint[[1]],x0=effectiveCentralPoint[[2]],y0=effectiveCentralPoint[[3]],normalAtVertex1=effectiveNormal[[1]],normalAtVertex2=effectiveNormal[[2]],normalAtVertex3=effectiveNormal[[3]]},With[{coordinateExtremum=Sqrt[(diameter/2)^2+thickness^2],reflectiveLayerThickness=0.2*thickness,nonReflectiveLayerThickness=0.8*thickness,plotOptions=FilterRules[{opts},Options[RegionPlot3D]]},With[{zRot=normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0)-normalAtVertex1 z+vertex+normalAtVertex1 *vertex,xRot=If[normalAtVertex2^2+normalAtVertex3^2>10^-12,1/(normalAtVertex2^2+normalAtVertex3^2) (normalAtVertex2 normalAtVertex3 (-y+y0)+normalAtVertex1 normalAtVertex2 (normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0))+normalAtVertex3^2 (x+normalAtVertex2 z-normalAtVertex2 *vertex)+normalAtVertex2^2 (x0+normalAtVertex2 z-normalAtVertex2 *vertex)),x0+normalAtVertex1 (-x+x0)],yRot=If[normalAtVertex2^2+normalAtVertex3^2>10^-12,1/(normalAtVertex2^2+normalAtVertex3^2) (-(1+normalAtVertex1) normalAtVertex2 normalAtVertex3 (x-x0)+normalAtVertex2^2 (y+normalAtVertex3 (z-vertex))+normalAtVertex3^2 (y0+normalAtVertex1 (-y+y0)+normalAtVertex3 z-normalAtVertex3 *vertex)),y]},With[{reflectiveLayer=ImplicitRegion[With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot>=vertex&&zRot<=vertex+reflectiveLayerThickness],{{z,vertex-coordinateExtremum,vertex+coordinateExtremum},{x,x0-coordinateExtremum,x0+coordinateExtremum},{y,y0-coordinateExtremum,y0+coordinateExtremum}}],nonReflectiveLayer=ImplicitRegion[With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot>=vertex+reflectiveLayerThickness&&zRot<=vertex+reflectiveLayerThickness+nonReflectiveLayerThickness],{{z,vertex-coordinateExtremum,vertex+coordinateExtremum},{x,x0-coordinateExtremum,x0+coordinateExtremum},{y,y0-coordinateExtremum,y0+coordinateExtremum}}]},Show[RegionPlot3D[reflectiveLayer,AspectRatio->Automatic,PlotPoints->70,BoxRatios->Automatic,BoundaryStyle-> None,PlotStyle->OptionValue[ReflectiveMirrorSurfaceStyle],Mesh->None,PlotTheme->"Monochrome",plotOptions],RegionPlot3D[nonReflectiveLayer,AspectRatio->Automatic,PlotPoints->70,BoxRatios->Automatic,BoundaryStyle->None,PlotStyle->OptionValue[NonReflectiveMirrorSurfaceStyle],Mesh->None,PlotTheme->"Monochrome",plotOptions]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedPlanarCircularFlat3D]=Join[{Reverse->False},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
(*If we were to use TransformedRegion,as in 2D case, the drawing would take ages*)drawArbitrarilyOrientedPlanarCircularFlat3D[centralPoint_,normalAtVertex_,thickness_,diameter_,opts:OptionsPattern[drawArbitrarilyOrientedPlanarCircularFlat3D]]:=With[{effectiveNormal=If[OptionValue[Reverse],-normalAtVertex,normalAtVertex],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-thickness*normalAtVertex,centralPoint]},With[{vertex=effectiveCentralPoint[[1]],x0=effectiveCentralPoint[[2]],y0=effectiveCentralPoint[[3]],normalAtVertex1=normalAtVertex[[1]],normalAtVertex2=effectiveNormal[[2]],normalAtVertex3=effectiveNormal[[3]]},With[{coordinateExtremum=Sqrt[(diameter/2)^2+thickness^2],plotOptions=FilterRules[{opts},Options[RegionPlot3D]]},With[{zRot=normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0)-normalAtVertex1 z+vertex+normalAtVertex1 *vertex,xRot=If[normalAtVertex2^2+normalAtVertex3^2>10^-12,1/(normalAtVertex2^2+normalAtVertex3^2) (normalAtVertex2 normalAtVertex3 (-y+y0)+normalAtVertex1 normalAtVertex2 (normalAtVertex2 (-x+x0)+normalAtVertex3 (-y+y0))+normalAtVertex3^2 (x+normalAtVertex2 z-normalAtVertex2 *vertex)+normalAtVertex2^2 (x0+normalAtVertex2 z-normalAtVertex2 *vertex)),x0+normalAtVertex1 (-x+x0)],yRot=If[normalAtVertex2^2+normalAtVertex3^2>10^-12,1/(normalAtVertex2^2+normalAtVertex3^2) (-(1+normalAtVertex1) normalAtVertex2 normalAtVertex3 (x-x0)+normalAtVertex2^2 (y+normalAtVertex3 (z-vertex))+normalAtVertex3^2 (y0+normalAtVertex1 (-y+y0)+normalAtVertex3 z-normalAtVertex3 *vertex)),y]},With[{region=ImplicitRegion[If[OptionValue[Reverse],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot<= vertex+thickness&&zRot>= vertex],With[{r=Sqrt[(xRot-x0)^2+(yRot-y0)^2]},r>=-diameter/2&&r<=diameter/2&&zRot>=vertex&&zRot<=vertex+thickness]],{{z,vertex-coordinateExtremum,vertex+coordinateExtremum},{x,x0-coordinateExtremum,x0+coordinateExtremum},{y,y0-coordinateExtremum,y0+coordinateExtremum}}]},RegionPlot3D[region,AspectRatio->Automatic,PlotPoints->70,BoxRatios->Automatic,BoundaryStyle-> None,Mesh->None,PlotTheme->"Monochrome",plotOptions]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedPlanarRectangularFlat3D]=Join[{Reverse->False},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
(*we neglect the Reverse option, as it does not affect drawing of a blank flat*)drawArbitrarilyOrientedPlanarRectangularFlat3D[centralPoint_,normalAtVertex_,thickness_,xLength_,yLength_,opts:OptionsPattern[drawArbitrarilyOrientedPlanarRectangularFlat3D]]:=With[{vertex=centralPoint[[1]],x0=centralPoint[[2]],y0=centralPoint[[3]],nz=normalAtVertex[[1]],nx=normalAtVertex[[2]],ny=normalAtVertex[[3]]},With[{plotOptions=FilterRules[{opts},Options[RegionPlot3D]]},With[{vVector=If[Abs[ny]<1,{nx/Sqrt[1-ny^2],-(nz/Sqrt[1-ny^2]),0},{0,1,0}],wVector=If[Abs[ny]<1,{-((ny nz)/Sqrt[1-ny^2]),-((nx ny)/Sqrt[1-ny^2]),Sqrt[1-ny^2]},{1,0,0}]},With[{region=Parallelepiped[centralPoint-0.5*xLength*vVector-0.5*yLength*wVector-thickness*normalAtVertex,{xLength*vVector,yLength*wVector,thickness*normalAtVertex}]},RegionPlot3D[region,AspectRatio->Automatic,PlotPoints->70,BoxRatios->Automatic,BoundaryStyle->None,Mesh->10,PlotTheme->"Monochrome",MeshStyle->None,plotOptions]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawArbitrarilyOrientedPlanarRectangularMirror3D]=Join[{Reverse->False,ReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.4]],NonReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.05]]},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
drawArbitrarilyOrientedPlanarRectangularMirror3D[centralPoint_,normalAtVertex_,thickness_,xLength_,yLength_,opts:OptionsPattern[drawArbitrarilyOrientedPlanarRectangularMirror3D]]:=With[{reflectiveLayerThicknesssFraction=0.2,effectiveNormal=If[OptionValue[Reverse],-normalAtVertex,normalAtVertex],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-thickness*normalAtVertex,centralPoint]},With[{optsReflective=Join[{PlotStyle->OptionValue[ReflectiveMirrorSurfaceStyle]},FilterRules[{opts},Options[drawArbitrarilyOrientedPlanarRectangularFlat3D]]],optsNonReflective=Join[{PlotStyle->OptionValue[NonReflectiveMirrorSurfaceStyle]},FilterRules[{opts},Options[drawArbitrarilyOrientedPlanarRectangularFlat3D]]]},With[{nonReflectiveLeyerCentralPoint=effectiveCentralPoint-reflectiveLayerThicknesssFraction*thickness*effectiveNormal,reflectiveLayerThickness=reflectiveLayerThicknesssFraction*thickness,nonreflectiveLayerThickness=(1-reflectiveLayerThicknesssFraction)*thickness},Show[drawArbitrarilyOrientedPlanarRectangularFlat3D[centralPoint,effectiveNormal,reflectiveLayerThickness,xLength,yLength,Sequence@@optsReflective],drawArbitrarilyOrientedPlanarRectangularFlat3D[nonReflectiveLeyerCentralPoint,effectiveNormal,nonreflectiveLayerThickness,xLength,yLength,Sequence@@optsNonReflective]]]]]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToInteractionWithArbitraryPlanarRectangularMirror3D]={Reverse->False};


(* ::Input::Initialization::Bold:: *)
(*we assume that the ray does nor start inside the screen*)subjectRayToInteractionWithArbitraryPlanarRectangularMirror3D[ray_List,centralPoint_,normal_,thickness_,xLength_,yLength_,reflectance_,opts:OptionsPattern[subjectRayToInteractionWithArbitraryPlanarRectangularMirror3D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-normal*thickness,centralPoint]},With[{rayOrigin=ray[[-1,1]],rayDirectionalVector=ray[[-1,2]],sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],nz=effectiveNormal[[1]],nx=effectiveNormal[[2]],ny=effectiveNormal[[3]],surfaceBCenter=effectiveCentralPoint-thickness*effectiveNormal},With[{mainSurfacesFunction=Function[{xCan,yCan},Abs[xCan]<xLength/2&&Abs[yCan]<yLength/2],(*parallel to y axis in the canonical orientation*)verticalEdgesFunction=Function[{xCan,yCan},Abs[xCan]<thickness/2&&Abs[yCan]<yLength/2],(*parallel to x axis in the canonical orientation*)horizontalEdgesFunction=Function[{xCan,yCan},Abs[xCan]<xLength/2&&Abs[yCan]<thickness/2],(*v vector is the normal of the vertical (in canonical orientation) edges*)v=If[Abs[ny]<1,{nx/(\[Sqrt](1-ny^2)),-(nz/(\[Sqrt](1-ny^2))),0},{0,1,0}],(*w vector is the normal of the horizontal edges*)w=If[Abs[ny]<1,{-((ny nz)/(\[Sqrt](1-ny^2))),-((nx ny)/(\[Sqrt](1-ny^2))),\[Sqrt](1-ny^2)},{1,0,0}]},With[{edgeOnCanonicallyPositiveXSideCenter=effectiveCentralPoint+(xLength/2)*v+0.5*thickness*(-effectiveNormal),edgeOnCanonicallyNegativeXSideCenter=effectiveCentralPoint-(xLength/2)*v+0.5*thickness*(-effectiveNormal),edgeOnCanonicallyPositiveYSideCenter=effectiveCentralPoint+(yLength/2)*w+0.5*thickness*(-effectiveNormal),edgeOnCanonicallyNegativeYSideCenter=effectiveCentralPoint-(yLength/2)*w+0.5*thickness*(-effectiveNormal)},With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,effectiveCentralPoint,effectiveNormal,mainSurfacesFunction,0],
rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,surfaceBCenter,effectiveNormal,mainSurfacesFunction,0],
rayIncidencePointScalarFactorListRightEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,edgeOnCanonicallyPositiveXSideCenter,v,verticalEdgesFunction,0],
rayIncidencePointScalarFactorListLeftEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,edgeOnCanonicallyNegativeXSideCenter,v,verticalEdgesFunction,0],
rayIncidencePointScalarFactorListTopEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,edgeOnCanonicallyPositiveYSideCenter,w,horizontalEdgesFunction,0],
rayIncidencePointScalarFactorListBottomEdge=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,edgeOnCanonicallyNegativeYSideCenter,w,horizontalEdgesFunction,0]},

With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveRightEdge = If[Length[rayIncidencePointScalarFactorListRightEdge]<1,\[Infinity],rayIncidencePointScalarFactorListRightEdge[[1,1]]],dEffectiveLeftEdge = If[Length[rayIncidencePointScalarFactorListLeftEdge]<1,\[Infinity],rayIncidencePointScalarFactorListLeftEdge[[1,1]]],dEffectiveTopEdge = If[Length[rayIncidencePointScalarFactorListTopEdge]<1,\[Infinity],rayIncidencePointScalarFactorListTopEdge[[1,1]]],dEffectiveBottomEdge = If[Length[rayIncidencePointScalarFactorListBottomEdge]<1,\[Infinity],rayIncidencePointScalarFactorListBottomEdge[[1,1]]]},If[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveRightEdge&&dEffectiveSurfaceA<=dEffectiveLeftEdge&&dEffectiveSurfaceA<=dEffectiveTopEdge&&dEffectiveSurfaceA<=dEffectiveBottomEdge,(*ray hits the first surface of the screen*)With[{incidentPoint=rayOrigin+dEffectiveSurfaceA*rayDirectionalVector},Append[ray,{incidentPoint,findReflectedRayUnitVector[rayDirectionalVector,effectiveNormal],reflectance*ray[[-1,-1]]}]],With[{dMin=Min[dEffectiveRightEdge,dEffectiveLeftEdge,dEffectiveTopEdge,dEffectiveBottomEdge]},If[dMin != \[Infinity],(*ray hits a non reflecting surface*)Append[ray,{rayOrigin+dMin*rayDirectionalVector,Null,ray[[-1,-1]]}],(*ray misses the mirror*)ray]]]]]]]]]]


Options[subjectRayToInteractionWithArbitraryPlanarPrismMirror2D]={Reverse->False};


(* ::Code::Initialization::Bold:: *)
subjectRayToInteractionWithArbitraryPlanarPrismMirror2D[ray_List,centralPoint_,normal_,zLegLength_,rLegLength_,reflectance_,opts:OptionsPattern[subjectRayToInteractionWithArbitraryPlanarPrismMirror2D]]:= 
With[{rayOrigin=ray[[-1,1]],rayDirectionalVector=ray[[-1,2]],\[Alpha]=ArcTan[zLegLength,rLegLength],wLength=Sqrt[zLegLength^2+rLegLength^2]},With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-normal*zLegLength*Sin[\[Alpha]],centralPoint]},
With[{sz=rayOrigin[[1]],sr=rayOrigin[[2]],\[CapitalDelta]z=rayDirectionalVector[[1]],\[CapitalDelta]r=rayDirectionalVector[[2]], nz=effectiveNormal[[1]],nr=effectiveNormal[[2]]},
With[{wz=nr,wr=-nz,l1z=If[Abs[nz]>0, nr*Cos[\[Alpha]]-nz Abs[Sin[\[Alpha]]],Cos[\[Alpha]]/nr],l1r=If[Abs[nz]>0,-nz Cos[\[Alpha]]-nr Abs[Sin[\[Alpha]]],-(Abs[Sin[\[Alpha]]]/nr)]},With[{wVector=wLength*{wz,wr},lZVector=zLegLength*{l1z,l1r}},
With[{(*unit vector perpendicular to the z leg, paralel to the y leg*)rLegUnitVector=(wVector-lZVector)/Norm[wVector-lZVector]},With[{referenceVertex=effectiveCentralPoint-0.5*wVector},With[{rayIncidencePointScalarFactorListReflectiveSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,wLength,effectiveCentralPoint,effectiveNormal,0],
rayIncidencePointScalarFactorListZLegSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,zLegLength,referenceVertex+0.5*lZVector,rLegUnitVector,0],
rayIncidencePointScalarFactorListRLegSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,rLegLength,referenceVertex+wVector-0.5*rLegLength*rLegUnitVector,{l1z,l1r},0]},
With[{dEffectiveReflectiveSurface = If[Length[rayIncidencePointScalarFactorListReflectiveSurface]<1,\[Infinity],rayIncidencePointScalarFactorListReflectiveSurface[[1,1]]],
dEffectiveReflectiveZLegSurface = If[Length[rayIncidencePointScalarFactorListZLegSurface]<1,\[Infinity],rayIncidencePointScalarFactorListZLegSurface[[1,1]]],
dEffectiveReflectiveRLegSurface = If[Length[rayIncidencePointScalarFactorListRLegSurface]<1,\[Infinity],rayIncidencePointScalarFactorListRLegSurface[[1,1]]]},
If[(dEffectiveReflectiveSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveReflectiveSurface<= dEffectiveReflectiveZLegSurface&&dEffectiveReflectiveSurface<=dEffectiveReflectiveRLegSurface,
With[{incidentPoint=rayOrigin+dEffectiveReflectiveSurface*rayDirectionalVector},Append[ray,{incidentPoint,findReflectedRayUnitVector[rayDirectionalVector,effectiveNormal],reflectance*ray[[-1,-1]]}]],
With[{dMin=Min[dEffectiveReflectiveZLegSurface,dEffectiveReflectiveRLegSurface]},If[dMin != \[Infinity],(*ray hits a non reflecting surface*)Append[ray,{rayOrigin+dMin*rayDirectionalVector,Null,ray[[-1,-1]]}],(*ray misses the mirror*)ray]]]]]]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToInteractionWithArbitraryPlanarPrismMirror3D]={Reverse->False};


(* ::Input::Initialization::Bold:: *)
(*centralPoint is in the center of the hypotenuse (at the surface),
when normalAtVertex is {-1,0,0}, then v is a vector parallel to the x axis, w is parrallel to y axis 
xSideLength is the length of the side which is parallel to the x axis when the hypotenuse normal is {-1,0,0}
zLegLength and ylegLength is the length of the prism leg (triangular part) are parallel to the z and y axes, respectively, when the hypotenuse normal is {Cos[90 Degree + \[Alpha]],0,Sin[90 Degree + \[Alpha]]}, where \[Alpha]=ArcTan[zLegLength,yLegLength]*)subjectRayToInteractionWithArbitraryPlanarPrismMirror3D[ray_List,centralPoint_,normal_,xSideLength_,zLegLength_,yLegLength_,reflectance_,opts:OptionsPattern[subjectRayToInteractionWithArbitraryPlanarPrismMirror3D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{\[Alpha]=ArcTan[zLegLength,yLegLength],wLength=Sqrt[zLegLength^2+yLegLength^2]},With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-normal*zLegLength*Sin[\[Alpha]],centralPoint]},With[{rayOrigin=ray[[-1,1]],rayDirectionalVector=ray[[-1,2]],sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],nz=effectiveNormal[[1]],nx=effectiveNormal[[2]],ny=effectiveNormal[[3]]},With[{(*v vector is parallel to the x edge, it is the normal of the vertical (in canonical orientation) edges, it is parallel to the z - x plane, it is orthogonal to the  vector normal to the  reflective edge*)v=If[Abs[ny]<1,{nx/Sqrt[1-ny^2],-(nz/Sqrt[1-ny^2]),0},{0,1,0}],(*w vector is parallel to one of the edges of the reflective surface (this edge is parallel to y axis when the normal to the reflective surface is {-1,0,0})*)w=If[Abs[ny]<1,{-((ny nz)/Sqrt[1-ny^2]),-((nx ny)/Sqrt[1-ny^2]),Sqrt[1-ny^2]},{1,0,0}],legZUnitVector={If[Abs[ny]<1,If[Abs[nz]>0,-nz Abs[Sin[\[Alpha]]]-(ny nz Cos[\[Alpha]])/Sqrt[1-ny^2],0],Cos[\[Alpha]]],If[Abs[ny]<1,If[Abs[nz]>0,-nx  Abs[Sin[\[Alpha]]]-(nx ny Cos[\[Alpha]])/Sqrt[1-ny^2],((-1+ny^2)  Abs[Sin[\[Alpha]]])/nx -(ny Sqrt[1-ny^2] Cos[\[Alpha]])/nx],0],If[Abs[ny]<1,If[Abs[nz]>0,-ny  Abs[Sin[\[Alpha]]]+Sqrt[1-ny^2] Cos[\[Alpha]],-ny Abs[ Sin[\[Alpha]]]+Sqrt[1-ny^2] Cos[\[Alpha]]],-Sign[ny]Abs[Sin[\[Alpha]]]]}},With[{legYUnitVector=(-wLength*w+zLegLength*legZUnitVector)/Norm[-wLength*w+zLegLength*legZUnitVector](*don't change, we cannot just add unit vectors*),referenceVertex=centralPoint-0.5*xSideLength*v-0.5*wLength*w},With[{tranglePointsForSurfaceWithVNormal={referenceVertex+xSideLength*v,referenceVertex+xSideLength*v+zLegLength*legZUnitVector,referenceVertex+xSideLength*v+wLength*w},tranglePointsForSurfaceWithMinusVNormal={referenceVertex,referenceVertex+zLegLength*legZUnitVector,referenceVertex+wLength*w},baseCentralPoint=effectiveCentralPoint-0.5*wLength*w+0.5*zLegLength*legZUnitVector,
(*back side is the side with the legZUnitVector as a normal*)centralPointBackSide=effectiveCentralPoint+0.5*wLength*w+0.5*yLegLength*(legYUnitVector),wTransformedForCanonicalOrientationOfTriangularFaceWithVNormal=wLength*If[v[[2]] != 0,{w[[1]]/v[[2]],w[[3]]},{-w[[2]],w[[3]]}],wTransformedForCanonicalOrientationOfTriangularFaceWithMinusVNormal=wLength*If[v[[2]] != 0,{-(w[[1]]/v[[2]]),w[[3]]},{w[[2]],w[[3]]}],legZVectorTransformedForCanonicalOrientationOfTriangularFaceWithVNormal=zLegLength*If[v[[2]] != 0,{legZUnitVector[[1]]/v[[2]],legZUnitVector[[3]]},{-legZUnitVector[[2]],legZUnitVector[[3]]}],legZVectorTransformedForCanonicalOrientationOfTriangularFaceWithMinusVNormal=zLegLength*If[v[[2]] != 0,{-(legZUnitVector[[1]]/v[[2]]),legZUnitVector[[3]]},{legZUnitVector[[2]],legZUnitVector[[3]]}]},With[{reflectiveSurfaceFunction=Function[{xCan,yCan},Abs[xCan]<xSideLength/2&&Abs[yCan]<wLength/2],
baseSurfaceFunction=Function[{xCan,yCan},Abs[xCan]<xSideLength/2&&Abs[yCan]<zLegLength/2],
backSurfaceFunction=Function[{xCan,yCan},Abs[xCan]<xSideLength/2&&Abs[yCan]<yLegLength/2],triangularSurfaceWithVNormalFunction=With[{region=Triangle[{{0,0},legZVectorTransformedForCanonicalOrientationOfTriangularFaceWithVNormal,wTransformedForCanonicalOrientationOfTriangularFaceWithVNormal}]},Function[{xCan,yCan},RegionMember[region,{xCan,yCan}]]],
triangularSurfaceWithMinusVNormalFunction=With[{region=Triangle[{{0,0},legZVectorTransformedForCanonicalOrientationOfTriangularFaceWithMinusVNormal,wTransformedForCanonicalOrientationOfTriangularFaceWithMinusVNormal}]},Function[{xCan,yCan},RegionMember[region,{xCan,yCan}]]]},With[{rayIncidencePointScalarFactorListReflectiveSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,effectiveCentralPoint,effectiveNormal,reflectiveSurfaceFunction,0],
rayIncidencePointScalarFactorListBaseSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,baseCentralPoint,-legYUnitVector,baseSurfaceFunction,0],
rayIncidencePointScalarFactorListBackSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,centralPointBackSide,legZUnitVector,backSurfaceFunction,0],
rayIncidencePointScalarFactorListTriangularFaceWithVNormal=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,referenceVertex+xSideLength*v,v,triangularSurfaceWithVNormalFunction,0],
rayIncidencePointScalarFactorListTriangularFaceWithMinusVNormal=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceIntersectionOfArbitraryElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,referenceVertex,-v,triangularSurfaceWithMinusVNormalFunction,0]},

With[{dEffectiveReflectiveSurface = If[Length[rayIncidencePointScalarFactorListReflectiveSurface]<1,\[Infinity],rayIncidencePointScalarFactorListReflectiveSurface[[1,1]]],dEffectiveBaseSurface = If[Length[rayIncidencePointScalarFactorListBaseSurface]<1,\[Infinity],rayIncidencePointScalarFactorListBaseSurface[[1,1]]],dEffectiveBackSurface= If[Length[rayIncidencePointScalarFactorListBackSurface]<1,\[Infinity],rayIncidencePointScalarFactorListBackSurface[[1,1]]],dEffectiveTriangularFaceWithVNormal= If[Length[rayIncidencePointScalarFactorListTriangularFaceWithVNormal]<1,\[Infinity],rayIncidencePointScalarFactorListTriangularFaceWithVNormal[[1,1]]],dEffectiveTriangularFaceWithMinusVNormal = If[Length[rayIncidencePointScalarFactorListTriangularFaceWithMinusVNormal]<1,\[Infinity],rayIncidencePointScalarFactorListTriangularFaceWithMinusVNormal[[1,1]]]},If[(dEffectiveReflectiveSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveReflectiveSurface<= dEffectiveBaseSurface&&dEffectiveReflectiveSurface<=dEffectiveBackSurface&&dEffectiveReflectiveSurface<=dEffectiveTriangularFaceWithVNormal&&dEffectiveReflectiveSurface<=dEffectiveTriangularFaceWithMinusVNormal,(*ray hits the first surface of the screen*)With[{incidentPoint=rayOrigin+dEffectiveReflectiveSurface*rayDirectionalVector},Append[ray,{incidentPoint,findReflectedRayUnitVector[rayDirectionalVector,effectiveNormal],reflectance*ray[[-1,-1]]}]],With[{dMin=Min[dEffectiveBaseSurface,dEffectiveBackSurface,dEffectiveTriangularFaceWithVNormal,dEffectiveTriangularFaceWithMinusVNormal]},If[dMin != \[Infinity],(*ray hits a non reflecting surface*)Append[ray,{rayOrigin+dMin*rayDirectionalVector,Null,ray[[-1,-1]]}],(*ray misses the mirror*)ray]]]]]]]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawTriangularPrism2D]=Join[{Reverse->False,PlotStyle->FaceForm[GrayLevel[0.05]]},Options[Graphics]];


(* ::Input::Initialization::Bold:: *)
(*centralPoint is in the center of the hypotenuse (at the surface),
when normalAtVertex is {-1,0,0}, then v is a vector parallel to the x axis, w is parrallel to y axis 
xSideLength is the length of the side which is parallel to the x axis when the hypotenuse normal is {-1,0,0}
zLegLength and ylegLength is the length of the prism leg (triangular part) are parallel to the z and y axes, respectively, when the hypotenuse normal is {Cos[90 Degree + \[Alpha]],0,Sin[90 Degree + \[Alpha]]}, where \[Alpha]=ArcTan[zLegLength,yLegLength]*)drawTriangularPrism2D[centralPoint_,normalAtVertex_,zLegLength_,rLegLength_,opts:OptionsPattern[drawTriangularPrism2D]]:=With[{nz=normalAtVertex[[1]],nr=normalAtVertex[[2]],\[Alpha]=ArcTan[zLegLength,rLegLength],wLength=Sqrt[zLegLength^2+rLegLength^2],optsRegionPlot=FilterRules[{opts},Options[Graphics]]},With[{wz=nr,wr=-nz,l1z=If[Abs[nz]>0,nr Cos[\[Alpha]]-nz Abs[Sin[\[Alpha]]],Cos[\[Alpha]]/nr],l1r=If[Abs[nz]>0,-nz Cos[\[Alpha]]-nr Abs[Sin[\[Alpha]]],-(Abs[Sin[\[Alpha]]]/nr)]},With[{wVector=wLength*{wz,wr},lVector=zLegLength*{l1z,l1r}},With[{vertex=centralPoint-0.5*wVector},With[{firstTranglePoints={vertex,vertex+lVector,vertex+wVector}},Graphics[{EdgeForm[Black],OptionValue[PlotStyle],Polygon[firstTranglePoints]},FilterRules[{opts},Options[Graphics]]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawTriangularPrism3D]=Join[{Reverse->False,PlotStyle->Gray},Options[Graphics3D]];


(* ::Input::Initialization::Bold:: *)
(*centralPoint is in the center of the hypotenuse (at the surface),
when normalAtVertex is {-1,0,0}, then v is a vector parallel to the x axis, w is parrallel to y axis 
xSideLength is the length of the side which is parallel to the x axis when the hypotenuse normal is {-1,0,0}
zLegLength and ylegLength is the length of the prism leg (triangular part) are parallel to the z and y axes, respectively, when the hypotenuse normal is {Cos[90 Degree + \[Alpha]],0,Sin[90 Degree + \[Alpha]]}, where \[Alpha]=ArcTan[zLegLength,yLegLength]*)drawTriangularPrism3D[centralPoint_,normalAtVertex_,xSideLength_,zLegLength_,yLegLength_,opts:OptionsPattern[drawTriangularPrism3D]]:=With[{nz=normalAtVertex[[1]],nx=normalAtVertex[[2]],ny=normalAtVertex[[3]],\[Alpha]=ArcTan[zLegLength,yLegLength],wLength=Sqrt[zLegLength^2+yLegLength^2],optsGraphics=FilterRules[{opts},Options[Graphics3D]]},With[{vz=If[Abs[ny]<1,nx/Sqrt[1-ny^2],0],vx=If[Abs[ny]<1,-(nz/Sqrt[1-ny^2]),1],wz=If[Abs[ny]<1,-((ny nz)/Sqrt[1-ny^2]),1],wx=If[Abs[ny]<1,-((nx ny)/Sqrt[1-ny^2]),0],wy=If[Abs[ny]<1,Sqrt[1-ny^2],0],l1z=If[Abs[ny]<1,If[Abs[nz]>0,-nz Abs[Sin[\[Alpha]]]-(ny nz Cos[\[Alpha]])/Sqrt[1-ny^2],0],Cos[\[Alpha]]],l1x=If[Abs[ny]<1,If[Abs[nz]>0,-nx  Abs[Sin[\[Alpha]]]-(nx ny Cos[\[Alpha]])/Sqrt[1-ny^2],((-1+ny^2)  Abs[Sin[\[Alpha]]])/nx -(ny Sqrt[1-ny^2] Cos[\[Alpha]])/nx],0],l1y=If[Abs[ny]<1,If[Abs[nz]>0,-ny  Abs[Sin[\[Alpha]]]+Sqrt[1-ny^2] Cos[\[Alpha]],-ny Abs[ Sin[\[Alpha]]]+Sqrt[1-ny^2] Cos[\[Alpha]]],-Sign[ny]Abs[Sin[\[Alpha]]]]},(*Graphics3D[{Red,Arrow[{centralPoint,{nz,nx,ny}}],Blue,Arrow[{centralPoint,xSideLength*{vz,vx,0}}],Green,Arrow[{centralPoint,wLength*{wz,wx,wy}}],Black,Arrow[{centralPoint,zLegLength*{l1z,l1x,l1y}}]},Axes\[Rule]True,AxesLabel\[Rule]{"z","x","y"}]*)With[{vVector=xSideLength*{vz,vx,0},wVector=wLength*{wz,wx,wy},lVector=zLegLength*{l1z,l1x,l1y}},With[{vertex=centralPoint-0.5*vVector-0.5*wVector},With[{firstTranglePoints={vertex,vertex+lVector,vertex+wVector},secondTranglePoints={vertex+vVector,vertex+lVector+vVector,vertex+wVector+vVector}},With[{region=Prism[Join[firstTranglePoints,secondTranglePoints]]},Graphics3D[{OptionValue[PlotStyle],region},Lighting->"Neutral",AspectRatio->Automatic,BoxRatios->Automatic,optsGraphics]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawTruncatedTriangularPrism2D]=Join[{Reverse->False,PlotStyle->FaceForm[GrayLevel[0.05]]},Options[Graphics]];


(* ::Input::Initialization::Bold:: *)
(*the truncation surface is parallel to the hypotenuse*)drawTruncatedTriangularPrism2D[centralPoint_,normalAtVertex_,(*should be smaller than zLegLength*Sin[\[Alpha]], i.e. the height in the normal direction of the full, non-truncated prism*)heightInNormalDirection_,(*whole prism x side length*)zLegLength_,(*whole prism r side length*)rLegLength_,opts:OptionsPattern[drawTruncatedTriangularPrism2D]]:=With[{nz=normalAtVertex[[1]],nr=normalAtVertex[[2]],\[Alpha]=ArcTan[zLegLength,rLegLength],wLength=Sqrt[zLegLength^2+rLegLength^2],optsRegionPlot=FilterRules[{opts},Options[Graphics]]},With[{wz=nr,wr=-nz,l1z=If[Abs[nz]>0,nr Cos[\[Alpha]]-nz Abs[Sin[\[Alpha]]],Cos[\[Alpha]]/nr],l1r=If[Abs[nz]>0,-nz Cos[\[Alpha]]-nr Abs[Sin[\[Alpha]]],-(Abs[Sin[\[Alpha]]]/nr)]},With[{legYUnitVector=(-wLength*{wz,wr}+zLegLength*{l1z,l1r})/Norm[-wLength*{wz,wr}+zLegLength*{l1z,l1r}],legZUnitVector={l1z,l1r},wVector=wLength*{wz,wr}},With[{legZFractionalVector=heightInNormalDirection/Cos[\[Pi]/2-\[Alpha]]*legZUnitVector,legYFractionalVector=heightInNormalDirection/Cos[\[Alpha]]*legYUnitVector},With[{referenceVertex=centralPoint-0.5*wVector},With[{firstTrapezoidPoints={referenceVertex,referenceVertex+legZFractionalVector,referenceVertex+wVector+legYFractionalVector,referenceVertex+wVector}},Graphics[{EdgeForm[Black],OptionValue[PlotStyle],Polygon[firstTrapezoidPoints]},FilterRules[{opts},Options[Graphics]]]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawTruncatedTriangularPrism3D]=Join[{Reverse->False},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
(*the truncation surface is parallel to the hypotenuse*)drawTruncatedTriangularPrism3D[centralPoint_,normalAtVertex_,(*should be smaller than zLegLength*Sin[\[Alpha]], i.e. the height in the normal direction of the full, non-truncated prism*)heightInNormalDirection_,(*whole prism x side length*)xSideLength_,(*whole prism x side length*)zlegLength_,(*whole prism x side length*)yLegLength_,opts:OptionsPattern[drawTruncatedTriangularPrism3D]]:=With[{nz=normalAtVertex[[1]],nx=normalAtVertex[[2]],ny=normalAtVertex[[3]],\[Alpha]=ArcTan[zlegLength,yLegLength],wLength=Sqrt[zlegLength^2+yLegLength^2],optsRegionPlot=FilterRules[{opts},Options[RegionPlot3D]]},With[{vz=If[Abs[ny]<1,nx/Sqrt[1-ny^2],0],vx=If[Abs[ny]<1,-(nz/Sqrt[1-ny^2]),1],wz=If[Abs[ny]<1,-((ny nz)/Sqrt[1-ny^2]),1],wx=If[Abs[ny]<1,-((nx ny)/Sqrt[1-ny^2]),0],wy=If[Abs[ny]<1,Sqrt[1-ny^2],0],l1z=If[Abs[ny]<1,If[Abs[nz]>0,-nz Abs[Sin[\[Alpha]]]-(ny nz Cos[\[Alpha]])/Sqrt[1-ny^2],0],Cos[\[Alpha]]],l1x=If[Abs[ny]<1,If[Abs[nz]>0,-nx  Abs[Sin[\[Alpha]]]-(nx ny Cos[\[Alpha]])/Sqrt[1-ny^2],((-1+ny^2)  Abs[Sin[\[Alpha]]])/nx -(ny Sqrt[1-ny^2] Cos[\[Alpha]])/nx],0],l1y=If[Abs[ny]<1,If[Abs[nz]>0,-ny  Abs[Sin[\[Alpha]]]+Sqrt[1-ny^2] Cos[\[Alpha]],-ny Abs[ Sin[\[Alpha]]]+Sqrt[1-ny^2] Cos[\[Alpha]]],-Sign[ny]Abs[Sin[\[Alpha]]]]},With[{legYUnitVector=(-wLength*{wz,wx,wy}+zlegLength*{l1z,l1x,l1y})/Norm[-wLength*{wz,wx,wy}+zlegLength*{l1z,l1x,l1y}],legZUnitVector={l1z,l1x,l1y},vVector=xSideLength*{vz,vx,0},wVector=wLength*{wz,wx,wy}},With[{legZFractionalVector=heightInNormalDirection/Cos[\[Pi]/2-\[Alpha]]*legZUnitVector,legYFractionalVector=heightInNormalDirection/Cos[\[Alpha]]*legYUnitVector},With[{referenceVertex=centralPoint-0.5*vVector-0.5*wVector},With[{firstTrapezoidPoints={referenceVertex,referenceVertex+legZFractionalVector,referenceVertex+wVector+legYFractionalVector,referenceVertex+wVector},secondTrapezoidPoints={referenceVertex+vVector,legZFractionalVector+referenceVertex+vVector,legYFractionalVector+referenceVertex+vVector+wVector,referenceVertex+vVector+wVector}},With[{region=Hexahedron[Join[firstTrapezoidPoints,secondTrapezoidPoints]]},RegionPlot3D[region,AspectRatio->Automatic,PlotPoints->70,BoxRatios->Automatic,BoundaryStyle->None,Mesh->10,PlotTheme->"Monochrome",MeshStyle->None,optsRegionPlot]]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawPrismMirror2D]=Join[{Reverse->False,ReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.8]],NonReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.05]]},Options[Graphics]];


(* ::Input::Initialization::Bold:: *)
drawPrismMirror2D[centralPoint_,normalAtVertex_,reflectiveLayerThickness_,zlegLength_,rLegLength_,opts:OptionsPattern[drawPrismMirror2D]]:=With[{effectiveNormal=normalAtVertex,effectiveCentralPoint=centralPoint},With[{nonReflectiveCentralPoint=centralPoint-reflectiveLayerThickness*effectiveNormal,\[Alpha]=ArcTan[zlegLength,rLegLength],nonReflectiveLayerStyle=OptionValue[NonReflectiveMirrorSurfaceStyle],reflectiveLayerStyle=OptionValue[ReflectiveMirrorSurfaceStyle]},With[{legZFractionToSubstractForReflectiveLayer=reflectiveLayerThickness/Cos[\[Pi]/2-\[Alpha]],legYFractionToSubstractForReflectiveLayer=reflectiveLayerThickness/Cos[\[Alpha]],reflectiveLayerOptions=Join[{PlotStyle->reflectiveLayerStyle},FilterRules[{opts},Options[drawTruncatedTriangularPrism2D]]],mainPrismBodyOptions=Join[{PlotStyle->nonReflectiveLayerStyle},FilterRules[{opts},Options[drawTriangularPrism2D]]]},Show[drawTruncatedTriangularPrism2D[effectiveCentralPoint,normalAtVertex,reflectiveLayerThickness,zlegLength,rLegLength,reflectiveLayerOptions],drawTriangularPrism2D[nonReflectiveCentralPoint,normalAtVertex,zlegLength-legZFractionToSubstractForReflectiveLayer,rLegLength-legYFractionToSubstractForReflectiveLayer,mainPrismBodyOptions]]]]]


(* ::Code::Initialization::Bold:: *)
With[{centralPoint={0,0},normalAtVertex={Cos[135Degree],Sin[135Degree]},reflectiveLayerThickness=0.02,zlegLength=1,rLegLength=1},drawPrismMirror2D[centralPoint,normalAtVertex,reflectiveLayerThickness,zlegLength,rLegLength]]


(* ::Input::Initialization::Bold:: *)
Options[drawPrismMirror3D]=Join[{Reverse->False,ReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.3]],NonReflectiveMirrorSurfaceStyle->FaceForm[GrayLevel[0.05]]},Options[RegionPlot3D]];


(* ::Input::Initialization::Bold:: *)
drawPrismMirror3D[centralPoint_,normalAtVertex_,reflectiveLayerThickness_,xSideLength_,zlegLength_,yLegLength_,opts:OptionsPattern[drawPrismMirror3D]]:=With[{effectiveNormal=normalAtVertex,effectiveCentralPoint=centralPoint},With[{nonReflectiveCentralPoint=centralPoint-reflectiveLayerThickness*effectiveNormal,\[Alpha]=ArcTan[zlegLength,yLegLength],nonReflectiveLayerStyle=OptionValue[NonReflectiveMirrorSurfaceStyle],reflectiveLayerStyle=OptionValue[ReflectiveMirrorSurfaceStyle]},With[{legZFractionToSubstractForReflectiveLayer=reflectiveLayerThickness/Cos[\[Pi]/2-\[Alpha]],legYFractionToSubstractForReflectiveLayer=reflectiveLayerThickness/Cos[\[Alpha]],reflectiveLayerOptions=Join[{PlotStyle->reflectiveLayerStyle},FilterRules[{opts},Options[drawTruncatedTriangularPrism3D]]],mainPrismBodyOptions=Join[{PlotStyle->nonReflectiveLayerStyle},FilterRules[{opts},Options[drawTriangularPrism3D]]]},Show[drawTruncatedTriangularPrism3D[effectiveCentralPoint,normalAtVertex,reflectiveLayerThickness,xSideLength,zlegLength,yLegLength,reflectiveLayerOptions],drawTriangularPrism3D[nonReflectiveCentralPoint,normalAtVertex,xSideLength,zlegLength-legZFractionToSubstractForReflectiveLayer,yLegLength-legYFractionToSubstractForReflectiveLayer,mainPrismBodyOptions]]]]]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToReflectionOnArbitraryPlanarMirror2D]={Reverse->False};


(* ::Input::Initialization::Bold:: *)
(*we assume that the ray does nor start inside the mirror*)subjectRayToReflectionOnArbitraryPlanarMirror2D[ray_List,centralPoint_,diameter_,thickness_,normal_,reflectance_,opts:OptionsPattern[subjectRayToReflectionOnArbitraryPlanarMirror2D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-thickness*normal,centralPoint]},With[{cz=centralPoint[[1]],cr=centralPoint[[2]]},With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]],surfaceBCenter=effectiveCentralPoint-thickness*effectiveNormal{cz-thickness*effectiveNormal[[1]],cr-thickness*effectiveNormal[[2]]},edgeACenter={effectiveCentralPoint[[1]]-0.5*thickness*effectiveNormal[[1]]+0.5*diameter*(-effectiveNormal[[2]]),cr-0.5*thickness*effectiveNormal[[2]]+0.5*diameter*(effectiveNormal[[1]])},edgeBCenter={effectiveCentralPoint[[1]]-0.5*thickness*effectiveNormal[[1]]-0.5*diameter*(-effectiveNormal[[2]]),cr-0.5*thickness*effectiveNormal[[2]]-0.5*diameter*(effectiveNormal[[1]])}},With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,diameter,effectiveCentralPoint,effectiveNormal,0],rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,diameter,surfaceBCenter,effectiveNormal,0],rayIncidencePointScalarFactorListEdgeA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,thickness,edgeACenter,{-effectiveNormal[[2]],effectiveNormal[[1]]},0],rayIncidencePointScalarFactorListEdgeB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,thickness,edgeBCenter,{effectiveNormal[[2]],-effectiveNormal[[1]]},0]},With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveEdgeA = If[Length[rayIncidencePointScalarFactorListEdgeA]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeA[[1,1]]],dEffectiveEdgeB = If[Length[rayIncidencePointScalarFactorListEdgeB]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeB[[1,1]]]},Which[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveEdgeA&& dEffectiveSurfaceA<= dEffectiveEdgeB,(*ray hits the reflective surface of the mirror*)With[{incidentZ=sz+dEffectiveSurfaceA*\[CapitalDelta]z,incidentR=sr+dEffectiveSurfaceA*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},findReflectedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},effectiveNormal],reflectance*ray[[-1,-1]]}]],(*ray hits the bottom surface of the mirror*)(dEffectiveSurfaceB!=\[Infinity])&&dEffectiveSurfaceB<= dEffectiveSurfaceA&&dEffectiveSurfaceB<=dEffectiveEdgeA&& dEffectiveSurfaceB<= dEffectiveEdgeB,With[{incidentZ=sz+dEffectiveSurfaceB*\[CapitalDelta]z,incidentR=sr+dEffectiveSurfaceB*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray hits the first edge*)(dEffectiveEdgeA!=\[Infinity])&&dEffectiveEdgeA<= dEffectiveSurfaceA&&dEffectiveEdgeA<=dEffectiveSurfaceB&& dEffectiveEdgeA<= dEffectiveEdgeB,With[{incidentZ=sz+dEffectiveEdgeA*\[CapitalDelta]z,incidentR=sr+dEffectiveEdgeA*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray hits the second edge*)(dEffectiveEdgeB!=\[Infinity])&&dEffectiveEdgeB<= dEffectiveSurfaceA&&dEffectiveEdgeB<=dEffectiveSurfaceB&& dEffectiveEdgeB<= dEffectiveEdgeA,With[{incidentZ=sz+dEffectiveEdgeB*\[CapitalDelta]z,incidentR=sr+dEffectiveEdgeB*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray misses the mirror*)True,ray]]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToInteractionWithArbitraryPlanarCircularMirror3D]={Reverse->False};


(* ::Input::Initialization::Bold:: *)
(*we assume that the ray does nor start inside the screen*)subjectRayToInteractionWithArbitraryPlanarCircularMirror3D[ray_List,centralPoint_,diameter_,thickness_,normal_,reflectance_,opts:OptionsPattern[subjectRayToInteractionWithArbitraryPlanarCircularMirror3D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-normal*thickness,centralPoint]},With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]],surfaceBCenter=effectiveCentralPoint-thickness*effectiveNormal},With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter,effectiveCentralPoint,effectiveNormal,0],rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter,surfaceBCenter,effectiveNormal,0],rayIncidencePointScalarFactorListEdge=findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter/2,thickness,effectiveCentralPoint,normal,0]},With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveEdge = If[Length[rayIncidencePointScalarFactorListEdge]<1,\[Infinity],rayIncidencePointScalarFactorListEdge[[1,1]]]},Which[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveEdge,(*ray hits the first surface of the screen*)With[{incidentZ=sz+dEffectiveSurfaceA*\[CapitalDelta]z,incidentX=sx+dEffectiveSurfaceA*\[CapitalDelta]x,incidentY=sy+dEffectiveSurfaceA*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},findReflectedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y},effectiveNormal],reflectance*ray[[-1,-1]]}]],(*ray hits the bottom,non reflective surface of the mirror*)(dEffectiveSurfaceB!=\[Infinity])&&dEffectiveSurfaceB<= dEffectiveSurfaceA&&dEffectiveSurfaceB<=dEffectiveEdge,With[{incidentZ=sz+dEffectiveSurfaceB*\[CapitalDelta]z,incidentX=sx+dEffectiveSurfaceB*\[CapitalDelta]x,incidentY=sy+dEffectiveSurfaceB*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},Null,ray[[-1,-1]]}]],(*ray hits the first edge*)(dEffectiveEdge!=\[Infinity])&&dEffectiveEdge<= dEffectiveSurfaceA&&dEffectiveEdge<=dEffectiveSurfaceB,With[{incidentZ=sz+dEffectiveEdge*\[CapitalDelta]z,incidentX=sx+dEffectiveEdge*\[CapitalDelta]x,incidentY=sy+dEffectiveEdge*\[CapitalDelta]y},Append[ray,{{incidentZ,incidentX,incidentY},Null,ray[[-1,-1]]}]],(*ray misses the mirror*)True,ray]]]]]]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToReflectionOnArbitraryPlanarDichroicMirror2D]={Reverse->False};


(* ::Input::Initialization::Bold:: *)
(*we assume that the ray does nor start inside the mirror*)subjectRayToReflectionOnArbitraryPlanarDichroicMirror2D[ray_List,centralPoint_,diameter_,thickness_,normal_,reflectance_,transmittance_,n1_,n2_,opts:OptionsPattern[subjectRayToReflectionOnArbitraryPlanarDichroicMirror2D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-normal*thickness,centralPoint]},With[{vectorPerpendicularToEffectiveNormal={-effectiveNormal[[2]],effectiveNormal[[1]]}},With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]],surfaceBCenter=effectiveCentralPoint-thickness*effectiveNormal,edgeACenter=effectiveCentralPoint-0.5*thickness*effectiveNormal+0.5*diameter*effectiveNormal,edgeBCenter=effectiveCentralPoint-0.5*thickness*effectiveNormal-0.5*diameter*effectiveNormal},With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,diameter,effectiveCentralPoint,effectiveNormal,0],rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,diameter,surfaceBCenter,effectiveNormal,0],rayIncidencePointScalarFactorListEdgeA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,thickness, edgeACenter,vectorPerpendicularToEffectiveNormal,0],rayIncidencePointScalarFactorListEdgeB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,thickness,edgeBCenter,-vectorPerpendicularToEffectiveNormal,0]},With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveEdgeA = If[Length[rayIncidencePointScalarFactorListEdgeA]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeA[[1,1]]],dEffectiveEdgeB = If[Length[rayIncidencePointScalarFactorListEdgeB]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeB[[1,1]]]},Which[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveEdgeA&& dEffectiveSurfaceA<= dEffectiveEdgeB,(*ray hits the reflective surface of the mirror*)handleInteractionOfRayWithReflectingTransmittingSurfaceOfDichroicMirror2D[dEffectiveSurfaceA,ray,effectiveCentralPoint,diameter,thickness,effectiveNormal,reflectance,transmittance,n1,n2],

(*ray hits the bottom surface of the mirror*)(dEffectiveSurfaceB!=\[Infinity])&&dEffectiveSurfaceB<= dEffectiveSurfaceA&&dEffectiveSurfaceB<=dEffectiveEdgeA&& dEffectiveSurfaceB<= dEffectiveEdgeB,With[{incidentZ=sz+dEffectiveSurfaceB*\[CapitalDelta]z,incidentR=sr+dEffectiveSurfaceB*\[CapitalDelta]r},handleInteractionOfRayWithReflectingTransmittingSurfaceOfDichroicMirror2D[dEffectiveSurfaceB,ray,effectiveCentralPoint+thickness*(-effectiveNormal),diameter,thickness,-effectiveNormal,reflectance,transmittance,n1,n2]],(*ray hits the first edge*)(dEffectiveEdgeA!=\[Infinity])&&dEffectiveEdgeA<= dEffectiveSurfaceA&&dEffectiveEdgeA<=dEffectiveSurfaceB&& dEffectiveEdgeA<= dEffectiveEdgeB,With[{incidentZ=sz+dEffectiveEdgeA*\[CapitalDelta]z,incidentR=sr+dEffectiveEdgeA*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray hits the second edge*)(dEffectiveEdgeB!=\[Infinity])&&dEffectiveEdgeB<= dEffectiveSurfaceA&&dEffectiveEdgeB<=dEffectiveSurfaceB&& dEffectiveEdgeB<= dEffectiveEdgeA,With[{incidentZ=sz+dEffectiveEdgeB*\[CapitalDelta]z,incidentR=sr+dEffectiveEdgeB*\[CapitalDelta]r},Append[ray,{{incidentZ,incidentR},Null,ray[[-1,-1]]}]],(*ray misses the mirror*)True,ray]]]]]]]


(* ::Input::Initialization::Bold:: *)
(*we assume that the ray does nor start inside the mirror*)subjectRayToReflectionOnArbitraryPlanarDichroicMirror3D[ray_List,centralPoint_,diameter_,thickness_,normal_,reflectance_,transmittance_,n1_,n2_,opts:OptionsPattern[subjectRayToReflectionOnArbitraryPlanarDichroicMirror2D]]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{effectiveNormal=If[OptionValue[Reverse],-normal,normal],effectiveCentralPoint=If[OptionValue[Reverse],centralPoint-normal*thickness,centralPoint]},With[{rayOriginalPoint=ray[[-1,1]],rayDirectionVector=ray[[-1,2]],sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,3]],\[CapitalDelta]y=ray[[-1,2,3]],surfaceBCenter=effectiveCentralPoint-thickness*effectiveNormal,edgeACenter=effectiveCentralPoint-0.5*thickness*effectiveNormal+0.5*diameter*effectiveNormal,edgeBCenter=effectiveCentralPoint-0.5*thickness*effectiveNormal-0.5*diameter*effectiveNormal},With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter,effectiveCentralPoint,effectiveNormal,0],rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter,surfaceBCenter,effectiveNormal,0],rayIncidencePointScalarFactorListEdge=findPositiveScalarFactorsAndNormalsAtIncidenceCylindricalSurfaceIntersection3D[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,diameter/2,thickness,effectiveCentralPoint,normal,0]},With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveEdge= If[Length[rayIncidencePointScalarFactorListEdge]<1,\[Infinity],rayIncidencePointScalarFactorListEdge[[1,1]]]},

Which[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveEdge,(*ray hits the reflective surface of the mirror*)handleInteractionOfRayWithReflectingTransmittingSurfaceOfDichroicMirror3D[dEffectiveSurfaceA,ray,effectiveCentralPoint,diameter,thickness,effectiveNormal,reflectance,transmittance,n1,n2],

(*ray hits the bottom surface of the mirror*)(dEffectiveSurfaceB!=\[Infinity])&&dEffectiveSurfaceB<= dEffectiveSurfaceA&&dEffectiveSurfaceB<=dEffectiveEdge,With[{pointOfIncidence=rayOriginalPoint+dEffectiveSurfaceB*rayDirectionVector},handleInteractionOfRayWithReflectingTransmittingSurfaceOfDichroicMirror3D[dEffectiveSurfaceB,ray,effectiveCentralPoint+thickness*(-effectiveNormal),diameter,thickness,-effectiveNormal,reflectance,transmittance,n1,n2]],(*ray hits the first edge*)(dEffectiveEdge!=\[Infinity])&&dEffectiveEdge<= dEffectiveSurfaceA&&dEffectiveEdge<=dEffectiveSurfaceB,With[{pointOfIncidence=rayOriginalPoint+dEffectiveEdge*rayDirectionVector},Append[ray,{pointOfIncidence,Null,ray[[-1,-1]]}]],(*ray misses the mirror*)True,ray]]]]]]


(* ::Input::Initialization::Bold:: *)
handleInteractionOfRayWithReflectingTransmittingSurfaceOfDichroicMirror2D[interectionScalarFactor_,ray_List,centralPointHitSurface_,diameter_,thickness_,normalToHitSurface_,reflectance_,transmittance_,n1_,n2_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},Module[{firstSurfaceIncidentZ=sz+interectionScalarFactor*\[CapitalDelta]z,firstSurfaceIncidentR=sr+interectionScalarFactor*\[CapitalDelta]r, reflectedRay, transmittedRay,scalarFactorsOppositeSide},reflectedRay = If[reflectance>0,Append[ray,{{firstSurfaceIncidentZ,firstSurfaceIncidentR},findReflectedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},normalToHitSurface],reflectance*ray[[-1,-1]]}],Null];

transmittedRay=If[transmittance>0,With[{surfaceARefractedRayUnitVector = findRefractedRayUnitVector[ray[[-1,2]],normalToHitSurface,n1,n2]},(*we assume that the ray refracted at the first surface must hit the second surface, i.e. we don't account for the possibility that the ray hits the edge, if it does, then we simply set  the ray to null, as if it was absorbed*)With[{refractedRay=Append[ray,{{firstSurfaceIncidentZ,firstSurfaceIncidentR},surfaceARefractedRayUnitVector,transmittance*ray[[-1,-1]]}]},scalarFactorsOppositeSide=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[firstSurfaceIncidentZ,firstSurfaceIncidentR,surfaceARefractedRayUnitVector[[1]],surfaceARefractedRayUnitVector[[2]],diameter,centralPointHitSurface+thickness*(-normalToHitSurface),-normalToHitSurface];If[Length[scalarFactorsOppositeSide]>= 1,With[{dSecondSurface=scalarFactorsOppositeSide[[1,1]],refracted\[CapitalDelta]z=surfaceARefractedRayUnitVector[[1]],refracted\[CapitalDelta]r=surfaceARefractedRayUnitVector[[2]]},Append[refractedRay,{{firstSurfaceIncidentZ+dSecondSurface*refracted\[CapitalDelta]z,firstSurfaceIncidentR+dSecondSurface*refracted\[CapitalDelta]r},findRefractedRayUnitVector[surfaceARefractedRayUnitVector,scalarFactorsOppositeSide[[1,2]],n2,n1],refractedRay[[-1,-1]]}]],Null]]],Null];Module[{finalrays={}},If[reflectedRay=!=Null,finalrays=Append[finalrays,reflectedRay]];If[transmittedRay=!=Null,finalrays=Append[finalrays,transmittedRay]];Apply[HoldComplete,finalrays]]]]


(* ::Input::Initialization::Bold:: *)
handleInteractionOfRayWithReflectingTransmittingSurfaceOfDichroicMirror3D[interectionScalarFactor_,ray_List,centralPointHitSurface_,diameter_,thickness_,normalToHitSurface_,reflectance_,transmittance_,n1_,n2_]:=With[{rayInitialPoint=ray[[-1,1]],rayDirectionVector=ray[[-1,2]]},Module[{firstSurfaceIncidencePoint=rayInitialPoint+interectionScalarFactor*rayDirectionVector,reflectedRay, transmittedRay,scalarFactorsOppositeSide},reflectedRay = If[reflectance>0,Append[ray,{firstSurfaceIncidencePoint,findReflectedRayUnitVector[rayDirectionVector,normalToHitSurface],reflectance*ray[[-1,-1]]}],Null];

transmittedRay=If[transmittance>0,With[{surfaceARefractedRayUnitVector = findRefractedRayUnitVector[rayDirectionVector,normalToHitSurface,n1,n2]},(*we assume that the ray refracted at the first surface must hit the second surface, i.e. we don't account for the possibility that the ray hits the edge, if it does, then we simply set  the ray to null, as if it was absorbed*)With[{refractedRay=Append[ray,{firstSurfaceIncidencePoint,surfaceARefractedRayUnitVector,transmittance*ray[[-1,-1]]}]},scalarFactorsOppositeSide=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement3D[firstSurfaceIncidencePoint[[1]],firstSurfaceIncidencePoint[[2]],firstSurfaceIncidencePoint[[3]],surfaceARefractedRayUnitVector[[1]],surfaceARefractedRayUnitVector[[2]],surfaceARefractedRayUnitVector[[3]],diameter,centralPointHitSurface+thickness*(-normalToHitSurface),normalToHitSurface,0];If[Length[scalarFactorsOppositeSide]>= 1,With[{dSecondSurface=scalarFactorsOppositeSide[[1,1]]},Append[refractedRay,{firstSurfaceIncidencePoint+dSecondSurface*surfaceARefractedRayUnitVector,findRefractedRayUnitVector[surfaceARefractedRayUnitVector,scalarFactorsOppositeSide[[1,2]],n2,n1],refractedRay[[-1,-1]]}]],Null]]],Null];Module[{finalrays={}},If[reflectedRay=!=Null,finalrays=Append[finalrays,reflectedRay]];If[transmittedRay=!=Null,finalrays=Append[finalrays,transmittedRay]];Apply[HoldComplete,finalrays]]]]


(* ::Subsubsection::Bold:: *)
(*SPLITTERS*)


(* ::Input::Initialization::Bold:: *)
Options[createBeamSplitterCube]=Join[{Reverse->False},Options[GeneralOptomechanicalPart],Options[drawCubeBeamSplitter2D]];


(* ::Code::Initialization::Bold:: *)
createBeamSplitterCube[firstFaceCentralPoint_List, normalToFirstFace_List,sideLength_?NumericQ,transmittance_?NumericQ,glass_String,opts:OptionsPattern[createBeamSplitterCube]]:=createBeamSplitterCube[firstFaceCentralPoint,normalToFirstFace,sideLength,(transmittance &),glass,opts]


(* ::Input::Initialization::Bold:: *)
createBeamSplitterCube[firstFaceCentralPoint_List,normalToFirstFace_List,sideLength_?NumericQ,transmittanceFunction_Function,glass_String,opts:OptionsPattern[createBeamSplitterCube]]:=Module[{self},self=Association["objectType"->"beamSplitterCube","objectId"->OptionValue[PartId],"surfaceCount"->1,"minimalCenterZ"->firstFaceCentralPoint[[1]],"vertex"->firstFaceCentralPoint[[1]],"sideLength"->sideLength,"transmittanceFunction"->transmittanceFunction,"glass"->glass,"draw2D"->(drawCubeBeamSplitter2D[firstFaceCentralPoint,normalToFirstFace,sideLength,FilterRules[{opts},Options[drawCubeBeamSplitter2D]]]&),"draw3D"->(drawCubeBeamSplitter3D[firstFaceCentralPoint,normalToFirstFace,sideLength,FilterRules[{opts},Options[drawCubeBeamSplitter3D]]]&),"interactWithRays2D"->Function[{rays,surroundingMedium},self["refractRays2D"][rays,surroundingMedium]],"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],wavelength=raysObject["wavelength"],nOuter=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],nGlass=getGlassRefractiveIndex[raysObject["wavelength"],glass],transmittance=transmittanceFunction[raysObject["wavelength"]]},createRaysObject[ParallelMap[releaseHold[subjectRayToInteractionWithCubeBeamSplitter2D[#,firstFaceCentralPoint,normalToFirstFace,sideLength,transmittance,nOuter,nGlass,FilterRules[{opts},Options[subjectRayToInteractionWithCubeBeamSplitter2D]]]]&,rays],raysObject["wavelength"]]]]),"refractRays2DAndDraw"->Function[{raysObject,surroundingMedium},With[{refractedRays=(self["refractRays2D"][raysObject,surroundingMedium])["traces"]},Show[Graphics[Table[Table[Line[{refractedRays[[i,j,1]],refractedRays[[i,j+1,1]]}],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw2D"][]]]],"refractRaysUpToScreen2D"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{raysAfterSecondSurface=self["refractRays2D"][raysObject,surroundingMedium]},ParallelMap[subjectRayToInteractionWithVerticalScreen[#,screenZPosition,screenDiameter]&,raysAfterSecondSurface]]],"refractRaysUpToScreen2DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{refractedRays=self["refractRaysUpToScreen2D"][raysObject,surroundingMedium,screenZPosition,screenDiameter]},Show[Graphics[Table[Table[Line[{refractedRays[[i,j,1]],refractedRays[[i,j+1,1]]}],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw2D"][]]]],"interactWithRays3D"->Function[{raysObject,surroundingMedium},self["refractRays3D"][raysObject,surroundingMedium]],"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"],n1=getGlassRefractiveIndex[raysObject["wavelength"],surroundingMedium],n2=getGlassRefractiveIndex[raysObject["wavelength"],glass]},createRaysObject[If[OptionValue[Reverse],ParallelMap[subjectRayToRefractionOnSphericalThinLens3D[#,-R2,-R1,vertex,centerThickness,lensDiameter,n1,n2]&,rays],ParallelMap[subjectRayToRefractionOnSphericalThinLens3D[#,R1,R2,vertex,centerThickness,lensDiameter,n1,n2]&,rays]],raysObject["wavelength"]]]]),"refractRaysUpToScreen3D"->(Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{refractedRays=self["refractRays3D"][raysObject,surroundingMedium]},Table[subjectRayToInteractionWithVerticalScreen3D[refractedRays[[l]],screenZPosition,screenDiameter],{l,1,Length[refractedRays]}]]]),"refractRays3DAndDraw"->Function[{raysObject,surroundingMedium},With[{refractedRays=self["refractRays3D"][raysObject,surroundingMedium]},Show[Graphics3D[Table[Table[Line[{refractedRays[[i,j,1]],refractedRays[[i,j+1,1]]}],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw3D"][]]]],"refractRaysUpToScreen3DAndDraw"->Function[{raysObject,surroundingMedium,screenZPosition,screenDiameter},With[{refractedRays=self["refractRaysUpToScreen3D"][raysObject,surroundingMedium,screenZPosition,screenDiameter]},Show[Graphics3D[Table[Table[Line[{refractedRays[[i,j,1]],refractedRays[[i,j+1,1]]}],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw3D"][]]]],"createShiftedCopy"->Function[{vertexShift},createBeamSplitterCube[firstFaceCentralPoint + {vertexShift,0,0},normalToFirstFace,sideLength,transmittanceFunction,glass,opts]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawCubeBeamSplitter2D]={Reverse->False,PlotStyleFirstPart->Directive[EdgeForm[Black],FaceForm[{Opacity[0.5],GrayLevel[0.9]}]],PlotStyleSecondPart->Directive[EdgeForm[Black],FaceForm[{Opacity[0.5],GrayLevel[0.3]}]]};


(* ::Input::Initialization::Bold:: *)
drawCubeBeamSplitter2D[firstFaceCentralPoint_,normalToFirstFace_,sideLength_,opts:OptionsPattern[drawCubeBeamSplitter2D]]:=With[{firstFaceCentralPoint1=firstFaceCentralPoint[[1]],firstFaceCentralPoint2=firstFaceCentralPoint[[2]],normalToFirstFace1=normalToFirstFace[[1]],normalToFirstFace2=normalToFirstFace[[2]]},If[OptionValue[Reverse],Graphics[{OptionValue[PlotStyleSecondPart],Polygon[{{firstFaceCentralPoint1-(normalToFirstFace2 sideLength)/2,firstFaceCentralPoint2+(normalToFirstFace1 sideLength)/2 },{firstFaceCentralPoint1-((2 normalToFirstFace1+normalToFirstFace2) sideLength)/2 ,firstFaceCentralPoint2+((normalToFirstFace1-2 normalToFirstFace2) sideLength)/2 },{firstFaceCentralPoint1+((-2 normalToFirstFace1+normalToFirstFace2) sideLength)/2 ,firstFaceCentralPoint2-((normalToFirstFace1+2 normalToFirstFace2) sideLength)/2 }}],OptionValue[PlotStyleFirstPart],Polygon[{{firstFaceCentralPoint1-(normalToFirstFace2 sideLength)/2 ,firstFaceCentralPoint2+(normalToFirstFace1 sideLength)/2 },{firstFaceCentralPoint1+(normalToFirstFace2 sideLength)/2 ,firstFaceCentralPoint2-(normalToFirstFace1 sideLength)/2 },{firstFaceCentralPoint1+((-2 normalToFirstFace1+normalToFirstFace2) sideLength)/2 ,firstFaceCentralPoint2-((normalToFirstFace1+2 normalToFirstFace2) sideLength)/2 }}]}],Graphics[{OptionValue[PlotStyleFirstPart],Polygon[{{firstFaceCentralPoint1-(normalToFirstFace2 sideLength)/2 ,firstFaceCentralPoint2+(normalToFirstFace1 sideLength)/2 },{firstFaceCentralPoint1-((2 normalToFirstFace1+normalToFirstFace2) sideLength)/2 ,firstFaceCentralPoint2+((normalToFirstFace1-2 normalToFirstFace2) sideLength)/2 },{firstFaceCentralPoint1+(normalToFirstFace2 sideLength)/2 ,firstFaceCentralPoint2-(normalToFirstFace1 sideLength)/2 }}],OptionValue[PlotStyleSecondPart],Polygon[{{firstFaceCentralPoint1-((2 normalToFirstFace1+normalToFirstFace2) sideLength)/(2 Sqrt[normalToFirstFace1^2+normalToFirstFace2^2]),firstFaceCentralPoint2+((normalToFirstFace1-2 normalToFirstFace2) sideLength)/(2 Sqrt[normalToFirstFace1^2+normalToFirstFace2^2])},{firstFaceCentralPoint1+((-2 normalToFirstFace1+normalToFirstFace2) sideLength)/(2 Sqrt[normalToFirstFace1^2+normalToFirstFace2^2]),firstFaceCentralPoint2-((normalToFirstFace1+2 normalToFirstFace2) sideLength)/(2 Sqrt[normalToFirstFace1^2+normalToFirstFace2^2])},{firstFaceCentralPoint1+(normalToFirstFace2 sideLength)/(2 Sqrt[normalToFirstFace1^2+normalToFirstFace2^2]),firstFaceCentralPoint2-(normalToFirstFace1 sideLength)/(2 Sqrt[normalToFirstFace1^2+normalToFirstFace2^2])}}]}]]]


Options[drawCubeBeamSplitter3D]=Join[{Reverse->False,PlotStyleFirstPart->Directive[FaceForm[{Opacity[0.5],GrayLevel[0.1]}]],PlotStyleSecondPart->Directive[FaceForm[{Opacity[0.5],GrayLevel[0.7]}]]},Options[drawTriangularPrism3D]];


drawCubeBeamSplitter3D[firstFaceCentralPoint_,normalToFirstFace_,sideLength_,opts:OptionsPattern[drawCubeBeamSplitter3D]]:=With[{fz=normalToFirstFace[[1]],fx=normalToFirstFace[[2]],fy=normalToFirstFace[[3]],\[Alpha]=45*Degree},
With[{vz=If[Abs[fy]<1,-If[fz!=0,Sign[fz],-1] fx/Sqrt[1-fy^2],0],vx=If[Abs[fy]<1,Abs[fz]/Sqrt[1-fy^2],1]},
With[{nz=If[Abs[fy]<1,If[fz!=0,fy Abs[fz Cos[\[Alpha]]]/Sqrt[1-fy^2]+fz Sin[\[Alpha]],0],Sign[fy]Sin[\[Pi]/2-\[Alpha]]],nx=If[Abs[fy]<1,If[fz!= 0,fx (-fy Sign[fz] Abs[Cos[\[Alpha]]]/Sqrt[1-fy^2]+Sin[\[Alpha]]),-fy Abs[Cos[\[Alpha]]]+fx Sin[\[Alpha]]],0],
ny=If[fz!= 0,-Sign[ fz ] Sqrt[1-fy^2] Abs[Cos[\[Alpha]]]+fy Sin[\[Alpha]],fx  Abs[Cos[\[Alpha]]]+fy Sin[\[Alpha]]]},
With[{hypotenuseCentralPoint=firstFaceCentralPoint-sideLength/(2*Tan[\[Alpha]])*normalToFirstFace,opsDrawPrism=FilterRules[{opts},Options[drawTriangularPrism3D]]},Show[drawTriangularPrism3D[hypotenuseCentralPoint,{nz,nx,ny},sideLength,sideLength,sideLength,PlotStyle->OptionValue[PlotStyleFirstPart],opsDrawPrism],
drawTriangularPrism3D[hypotenuseCentralPoint,-{nz,nx,ny},sideLength,sideLength,sideLength,PlotStyle->OptionValue[PlotStyleSecondPart],opsDrawPrism]]]]]]


With[{vector={Cos[90 Degree],0.1,Sin[91 Degree]}},OpenRayTracer`Private`drawCubeBeamSplitter3D[{0,0,0},vector/Norm[vector],1,Axes->True,AxesLabel->{"z","x","y"}]]


With[{vector={Cos[90 Degree],0,Sin[90 Degree]}},OpenRayTracer`Private`drawCubeBeamSplitter3D[{0,0,0},vector/Norm[vector],1,Axes->True,AxesLabel->{"z","x","y"}]]


OpenRayTracer`Private`drawCubeBeamSplitter3D[{0,0,0},{Cos[89 Degree],0,Sin[89 Degree]},1,Axes->True,AxesLabel->{"z","x","y"}]


(* ::Input::Initialization::Bold:: *)
Options[subjectRayToInteractionWithCubeBeamSplitter2D]=Join[{Reverse->False},Options[GeneralOptomechanicalPart]];


(* ::Input::Initialization::Bold:: *)
(*first and second horizontal walls are either to or bottom walls, depending on whether the splitter is reversed*)subjectRayToInteractionWithCubeBeamSplitter2D[ray_,vertex_,sideLength_,transmissionRatio_,nOuter_,nGlass_,opts:OptionsPattern[subjectRayToInteractionWithCubeBeamSplitter2D]]:=Module[{rayRefractedOnFirstWall,rayRefractedOnBottomWall,rayRefractedOnSecondHorizontalWall,rayTransmittedByDiagonalWall,rayReflectedByDiagonalWall,intersectionScalarFactorWithFirstHorizontalWall,intersectionScalarFactorWithDiagonalWall,intersectionScalarFactorWithDiagonalWallD,rayDiagonalWallIncidencePoint},With[{reversed=OptionValue[Reverse]},(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],vertex]},If[rayIncidencePoint===Null||Length[rayIncidencePoint]<= 1||Abs[rayIncidencePoint[[2]]]>sideLength/2,(*ray missed the front wall*)Append[ray,{rayIncidencePoint,ray[[-1,2]],ray[[-1,-1]]}],(*we can treat from wall of the cube as a planar lens*)rayRefractedOnFirstWall=subjectRayToRefractionOnVerticalPlanarLensSurface[ray,vertex,sideLength,nOuter,nGlass];intersectionScalarFactorWithFirstHorizontalWall=findRayLineIntersectionsScalarFactors[rayRefractedOnFirstWall[[-1,1,1]],rayRefractedOnFirstWall[[-1,1,2]],rayRefractedOnFirstWall[[-1,2,1]],rayRefractedOnFirstWall[[-1,2,2]],vertex,If[reversed,sideLength/2,-(sideLength/2)],1,0];intersectionScalarFactorWithDiagonalWall=findRayLineIntersectionsScalarFactors[rayRefractedOnFirstWall[[-1,1,1]],rayRefractedOnFirstWall[[-1,1,2]],rayRefractedOnFirstWall[[-1,2,1]],rayRefractedOnFirstWall[[-1,2,2]],vertex,If[reversed,-(sideLength/2),sideLength/2],1/Sqrt[2],If[reversed,1/Sqrt[2],-(1/Sqrt[2])]];If[Length[intersectionScalarFactorWithDiagonalWall]>= 1&&(Length[intersectionScalarFactorWithFirstHorizontalWall]<1||intersectionScalarFactorWithDiagonalWall[[1]]<= intersectionScalarFactorWithFirstHorizontalWall[[1]]),intersectionScalarFactorWithDiagonalWallD=intersectionScalarFactorWithDiagonalWall[[1]];rayDiagonalWallIncidencePoint={rayRefractedOnFirstWall[[-1,1,1]]+intersectionScalarFactorWithDiagonalWallD*rayRefractedOnFirstWall[[-1,2,1]],rayRefractedOnFirstWall[[-1,1,2]]+intersectionScalarFactorWithDiagonalWallD*rayRefractedOnFirstWall[[-1,2,2]]};rayReflectedByDiagonalWall=With[{rayReflectedUnitVector=findReflectedRayUnitVector[rayRefractedOnFirstWall[[-1,2]],(*normalToDiagonal*)If[reversed,{-(1/Sqrt[2]),1/Sqrt[2]},{-(1/Sqrt[2]),-(1/Sqrt[2])}]]},Append[rayRefractedOnFirstWall,{rayDiagonalWallIncidencePoint,rayReflectedUnitVector,(1-transmissionRatio)*rayRefractedOnFirstWall[[-1,-1]]}]];(*reflectedRay*)Module[{intersectionScalarFactorWithFirstHorizontalWallForReflectedRay=findRayLineIntersectionsScalarFactors[rayReflectedByDiagonalWall[[-1,1,1]],rayReflectedByDiagonalWall[[-1,1,2]],rayReflectedByDiagonalWall[[-1,2,1]],rayReflectedByDiagonalWall[[-1,2,2]],vertex,If[reversed,sideLength/2,-(sideLength/2)],1,0]},If[Length[intersectionScalarFactorWithFirstHorizontalWallForReflectedRay]>= 1,rayReflectedByDiagonalWall=subjectRayToRefractionOnArbitraryPlanarLensSurface[rayReflectedByDiagonalWall,{vertex+sideLength/2,If[reversed,sideLength/2,-(sideLength/2)]},sideLength,If[reversed,{0,-1},{0,1}],nGlass,nOuter]]];(*transmittedRay*)rayTransmittedByDiagonalWall=Append[rayRefractedOnFirstWall,{rayDiagonalWallIncidencePoint,rayRefractedOnFirstWall[[-1,2]],transmissionRatio*rayRefractedOnFirstWall[[-1,-1]]}];Module[{intersectionScalarFactorWithSecondHorizontalWall=findRayLineIntersectionsScalarFactors[rayTransmittedByDiagonalWall[[-1,1,1]],rayTransmittedByDiagonalWall[[-1,1,2]],rayTransmittedByDiagonalWall[[-1,2,1]],rayTransmittedByDiagonalWall[[-1,2,2]],vertex,If[reversed,-(sideLength/2),sideLength/2],1,0],intersectionScalarFactorWithRightWall=findRayLineIntersectionsScalarFactors[rayTransmittedByDiagonalWall[[-1,1,1]],rayTransmittedByDiagonalWall[[-1,1,2]],rayTransmittedByDiagonalWall[[-1,2,1]],rayTransmittedByDiagonalWall[[-1,2,2]],vertex+sideLength,-(sideLength/2),0,1]},If[Length[intersectionScalarFactorWithRightWall]>= 1&&(Length[intersectionScalarFactorWithSecondHorizontalWall]<1||intersectionScalarFactorWithRightWall[[1]]<intersectionScalarFactorWithSecondHorizontalWall[[1]]),(*ray hits right wall*)With[{transmittedFinal=subjectRayToRefractionOnVerticalPlanarLensSurface[rayTransmittedByDiagonalWall,vertex+sideLength,sideLength,nGlass,nOuter]},HoldComplete[transmittedFinal,rayReflectedByDiagonalWall]],(*ray hit inner non-diagonal wall, we finish it*)If[Length[intersectionScalarFactorWithSecondHorizontalWall]>= 1,rayRefractedOnSecondHorizontalWall=subjectRayToRefractionOnArbitraryPlanarLensSurface[rayTransmittedByDiagonalWall,{vertex+sideLength/2,If[reversed,-(sideLength/2),sideLength/2]},sideLength,If[reversed,{0,1},{0,-1}],nGlass,nOuter];rayRefractedOnSecondHorizontalWall,Append[rayTransmittedByDiagonalWall,{rayIncidencePoint,ray[[-1,2]],ray[[-1,-1]]}]]]],(*ray hit inner non-diagonal wall, we finish it*)If[Length[intersectionScalarFactorWithFirstHorizontalWall]>= 1,rayRefractedOnBottomWall=subjectRayToRefractionOnArbitraryPlanarLensSurface[rayRefractedOnFirstWall,{vertex+sideLength/2,If[reversed,sideLength/2,-(sideLength/2)]},sideLength,If[reversed,{0,-1},{0,1}],nGlass,nOuter],Append[ray,{rayIncidencePoint,ray[[-1,2]],ray[[-1,-1]]}]]]]]])]]


(* ::Input::Initialization::Bold:: *)
(*first and second horizontal walls are either to or bottom walls, depending on whether the splitter is reversed*)subjectRayToInteractionWithCubeBeamSplitter2D[ray_,firstFaceCentralPoint_,normalToFirstFace_,sideLength_,transmissionRatio_,nOuter_,nGlass_,opts:OptionsPattern[subjectRayToInteractionWithCubeBeamSplitter2D]]:=Module[{rayRefractedOnFirstWall,rayRefractedOnBottomWall,rayRefractedOnSecondHorizontalWall,rayTransmittedByDiagonalWall,rayReflectedByDiagonalWall,intersectionScalarFactorWithFirstHorizontalWall,intersectionScalarFactorWithDiagonalWall,intersectionScalarFactorWithDiagonalWallD,rayDiagonalWallIncidencePoint},With[{cz=firstFaceCentralPoint[[1]],cr=firstFaceCentralPoint[[2]],reversed=OptionValue[Reverse],effectiveNormal=If[OptionValue[Reverse],{-normalToFirstFace[[1]],normalToFirstFace[[2]]},normalToFirstFace]},With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]],surfaceBCenter={cz-sideLength*effectiveNormal[[1]],cr-sideLength*effectiveNormal[[2]]},edgeACenter={cz-0.5*sideLength*effectiveNormal[[1]]+0.5*sideLength*(-effectiveNormal[[2]]),cr-0.5*sideLength*effectiveNormal[[2]]+0.5*sideLength*(effectiveNormal[[1]])},edgeAEffectiveNormal={-effectiveNormal[[2]],effectiveNormal[[1]]},edgeBCenter={cz-0.5*sideLength*effectiveNormal[[1]]-0.5*sideLength*(-effectiveNormal[[2]]),cr-0.5*sideLength*effectiveNormal[[2]]-0.5*sideLength*(effectiveNormal[[1]])},edgeBEffectiveNormal={effectiveNormal[[2]],-effectiveNormal[[1]]},diagonalCenter={cz-0.5*sideLength*(effectiveNormal[[1]]),cr-0.5*sideLength*(effectiveNormal[[2]])},diagonalNormal=1/Sqrt[2] {effectiveNormal[[1]]-effectiveNormal[[2]],effectiveNormal[[1]]+effectiveNormal[[2]]}},(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePointScalarFactorListSurfaceA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,sideLength,firstFaceCentralPoint,effectiveNormal],rayIncidencePointScalarFactorListSurfaceB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,sideLength,surfaceBCenter,-effectiveNormal],rayIncidencePointScalarFactorListEdgeA=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,sideLength,edgeACenter,edgeAEffectiveNormal],rayIncidencePointScalarFactorListEdgeB=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,sideLength,edgeBCenter,edgeBEffectiveNormal]},With[{dEffectiveSurfaceA = If[Length[rayIncidencePointScalarFactorListSurfaceA]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceA[[1,1]]],dEffectiveSurfaceB = If[Length[rayIncidencePointScalarFactorListSurfaceB]<1,\[Infinity],rayIncidencePointScalarFactorListSurfaceB[[1,1]]],dEffectiveEdgeA = If[Length[rayIncidencePointScalarFactorListEdgeA]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeA[[1,1]]],dEffectiveEdgeB = If[Length[rayIncidencePointScalarFactorListEdgeB]<1,\[Infinity],rayIncidencePointScalarFactorListEdgeB[[1,1]]]},Which[(dEffectiveSurfaceA!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSurfaceA<= dEffectiveSurfaceB&&dEffectiveSurfaceA<=dEffectiveEdgeA&& dEffectiveSurfaceA<= dEffectiveEdgeB,(*ray hits the the first outer surface*)handleInteractionOfRayWithOuterSurfaceOfBeamSplitter2D[dEffectiveSurfaceA,ray,sideLength,firstFaceCentralPoint,effectiveNormal,edgeACenter,edgeAEffectiveNormal,diagonalCenter,diagonalNormal,transmissionRatio,nOuter,nGlass],

(*ray hits the opposite surface of the mirror*)(dEffectiveSurfaceB!=\[Infinity])&&dEffectiveSurfaceB<= dEffectiveSurfaceA&&dEffectiveSurfaceB<=dEffectiveEdgeA&& dEffectiveSurfaceB<= dEffectiveEdgeB,With[{incidentZ=sz+dEffectiveSurfaceB*\[CapitalDelta]z,incidentR=sr+dEffectiveSurfaceB*\[CapitalDelta]r},handleInteractionOfRayWithOuterSurfaceOfBeamSplitter2D[dEffectiveSurfaceB,ray,sideLength,surfaceBCenter,-effectiveNormal,edgeBCenter,edgeBEffectiveNormal,diagonalCenter,diagonalNormal,transmissionRatio,nOuter,nGlass]],(*ray hits the first edge*)(dEffectiveEdgeA!=\[Infinity])&&dEffectiveEdgeA<= dEffectiveSurfaceA&&dEffectiveEdgeA<=dEffectiveSurfaceB&& dEffectiveEdgeA<= dEffectiveEdgeB,handleInteractionOfRayWithOuterSurfaceOfBeamSplitter2D[dEffectiveEdgeA,ray,sideLength,edgeACenter,edgeAEffectiveNormal,firstFaceCentralPoint,effectiveNormal,diagonalCenter,diagonalNormal,transmissionRatio,nOuter,nGlass],(*ray hits the second edge*)(dEffectiveEdgeB!=\[Infinity])&&dEffectiveEdgeB<= dEffectiveSurfaceA&&dEffectiveEdgeB<=dEffectiveSurfaceB&& dEffectiveEdgeB<= dEffectiveEdgeA,handleInteractionOfRayWithOuterSurfaceOfBeamSplitter2D[dEffectiveEdgeB,ray,sideLength,edgeBCenter,edgeBEffectiveNormal,surfaceBCenter,-effectiveNormal,diagonalCenter,diagonalNormal,transmissionRatio,nOuter,nGlass],(*ray misses the mirror*)True,ray]]]])]]]


(* ::Input::Initialization:: *)
handleInteractionOfRayWithOuterSurfaceOfBeamSplitter2D[d_,ray_List,sideLength_,centralPointHitOuterSurface_,normalToHitOuterSurface_,centralPointPerpendicularSurface_,normalToPerpendicularSurface_,centralPointDiagonalSurface_,normalToDiagonalSurface_,transmissionRatio_,n1_,n2_]:=With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},Module[{firstSurfaceIncidentZ=sz+d*\[CapitalDelta]z,firstSurfaceIncidentR=sr+d*\[CapitalDelta]r,refractedRay, reflectedRay, transmittedRay,scalarFactorsOppositeSide,refractedOnHitSurfaceVector=findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},normalToHitOuterSurface,n1,n2]},refractedRay = Append[ray,{{firstSurfaceIncidentZ,firstSurfaceIncidentR},refractedOnHitSurfaceVector,ray[[-1,-1]]}];
With[{rayIncidencePointScalarFactorListPerpendicular=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[firstSurfaceIncidentZ,firstSurfaceIncidentR,refractedOnHitSurfaceVector[[1]],refractedOnHitSurfaceVector[[2]],sideLength,centralPointPerpendicularSurface,normalToPerpendicularSurface],rayIncidencePointScalarFactorListDiagonal=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[firstSurfaceIncidentZ,firstSurfaceIncidentR,refractedOnHitSurfaceVector[[1]],refractedOnHitSurfaceVector[[2]],sideLength,centralPointDiagonalSurface,normalToDiagonalSurface]},

With[{dEffectivePerpendicular = If[Length[rayIncidencePointScalarFactorListPerpendicular]<1,\[Infinity],rayIncidencePointScalarFactorListPerpendicular[[1,1]]],dEffectiveDiagonal= If[Length[rayIncidencePointScalarFactorListDiagonal]<1,\[Infinity],rayIncidencePointScalarFactorListDiagonal[[1,1]]]},If[(dEffectivePerpendicular!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectivePerpendicular<= dEffectiveDiagonal,transmittedRay=Append[refractedRay,{{firstSurfaceIncidentZ+dEffectivePerpendicular*refractedOnHitSurfaceVector[[1]],firstSurfaceIncidentR+dEffectivePerpendicular*refractedOnHitSurfaceVector[[2]]},findRefractedRayUnitVector[refractedOnHitSurfaceVector,rayIncidencePointScalarFactorListPerpendicular[[1,2]],n2,n1],ray[[-1,-1]]}],If[(dEffectiveDiagonal!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveDiagonal<= dEffectivePerpendicular,transmittedRay=Append[refractedRay,{{firstSurfaceIncidentZ+dEffectiveDiagonal*refractedOnHitSurfaceVector[[1]],firstSurfaceIncidentR+dEffectiveDiagonal*refractedOnHitSurfaceVector[[2]]},(*both halves of the cube are made of the same glass, so the directional unit vector of the ray does not change*)refractedOnHitSurfaceVector,transmissionRatio*ray[[-1,-1]]}];transmittedRay=handleRayAfterInteractionWithDiagonalSurfaceOfBeamSplitter2D[transmittedRay,sideLength,centralPointHitOuterSurface-sideLength*normalToHitOuterSurface,-normalToHitOuterSurface,centralPointPerpendicularSurface-sideLength*normalToPerpendicularSurface,-normalToPerpendicularSurface,n1,n2];reflectedRay=Append[refractedRay,{{firstSurfaceIncidentZ+dEffectiveDiagonal*refractedOnHitSurfaceVector[[1]],firstSurfaceIncidentR+dEffectiveDiagonal*refractedOnHitSurfaceVector[[2]]},findReflectedRayUnitVector[refractedOnHitSurfaceVector,rayIncidencePointScalarFactorListDiagonal[[1,2]]],(1-transmissionRatio)*ray[[-1,-1]]}]]]]];reflectedRay=handleRayAfterInteractionWithDiagonalSurfaceOfBeamSplitter2D[reflectedRay,sideLength,centralPointHitOuterSurface,normalToHitOuterSurface,centralPointPerpendicularSurface,normalToPerpendicularSurface,n1,n2];


Module[{finalrays={}},If[reflectedRay=!=Null,finalrays=Append[finalrays,reflectedRay]];If[transmittedRay=!=Null,finalrays=Append[finalrays,transmittedRay]];Apply[HoldComplete,finalrays]]]]


(* ::Input::Initialization::Bold:: *)
handleRayAfterInteractionWithDiagonalSurfaceOfBeamSplitter2D[rayAfterDiagonal_List,sideLength_,centralPointFirstOuterSurface_,normalToFirstOuterSurface_,centralPointSecondOuterSurface_,normalToSecondOuterSurface_,n1_,n2_]:=With[{sz=rayAfterDiagonal[[-1,1,1]],sr=rayAfterDiagonal[[-1,1,2]],\[CapitalDelta]z=rayAfterDiagonal[[-1,2,1]],\[CapitalDelta]r=rayAfterDiagonal[[-1,2,2]]},With[{rayIncidencePointScalarFactorListFirstOuterSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,sideLength,centralPointFirstOuterSurface,normalToFirstOuterSurface],rayIncidencePointScalarFactorListSecondOuterSurface=findPositiveScalarFactorsAndNormalsAtIncidenceOfRayOnPlanarSurfaceOfCircularElement[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,sideLength,centralPointSecondOuterSurface,normalToSecondOuterSurface]},

With[{dEffectiveFirstSurface= If[Length[rayIncidencePointScalarFactorListFirstOuterSurface]<1,\[Infinity],rayIncidencePointScalarFactorListFirstOuterSurface[[1,1]]],dEffectiveSecondSurface= If[Length[rayIncidencePointScalarFactorListSecondOuterSurface]<1,\[Infinity],rayIncidencePointScalarFactorListSecondOuterSurface[[1,1]]]},If[(dEffectiveFirstSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveFirstSurface<= dEffectiveSecondSurface,Append[rayAfterDiagonal,{{sz+dEffectiveFirstSurface*\[CapitalDelta]z,sr+dEffectiveFirstSurface*\[CapitalDelta]r},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},rayIncidencePointScalarFactorListFirstOuterSurface[[1,2]],n2,n1],rayAfterDiagonal[[-1,-1]]}],If[(dEffectiveSecondSurface!=\[Infinity])(*we cannot use unsameQ here*)&&dEffectiveSecondSurface<= dEffectiveFirstSurface,Append[rayAfterDiagonal,{{sz+dEffectiveSecondSurface*\[CapitalDelta]z,sr+dEffectiveSecondSurface*\[CapitalDelta]r},findRefractedRayUnitVector[{\[CapitalDelta]z,\[CapitalDelta]r},rayIncidencePointScalarFactorListSecondOuterSurface[[1,2]],n2,n1],rayAfterDiagonal[[-1,-1]]}]]]]]]


(* ::Subsubsection::Bold:: *)
(*INTEGRATING SPHERE*)


(* ::Input::Initialization::Bold:: *)
drawIntegratingSphere3D[inputPortVertex_,inPlanePortDiametersAndAngularPositionsRaw_,chamberRadius_,(*list in order: minZSideThickness, maxZSideThickness, minXSideThickness, maxXSideThickness, minYSideThickness, maxYSideThickness to the viewer, behind the viewer*)sideThicknessList_,opts:OptionsPattern[drawIntegratingSphere]]:=Module[{cube,sphereInside,integratingSphere},With[{minZSideThickness=sideThicknessList[[1]],maxZSideThickness=sideThicknessList[[2]],minXSideThickness=sideThicknessList[[3]],maxXSideThickness=sideThicknessList[[4]],minYSideThickness=sideThicknessList[[5]],maxYSideThickness=sideThicknessList[[6]],portsAlongZAxis=Select[inPlanePortDiametersAndAngularPositionsRaw,((#[[4]]==="Z"))&],portsAlongXAxis=Select[inPlanePortDiametersAndAngularPositionsRaw,((#[[4]]==="X"))&],portsAlongYAxis=Select[inPlanePortDiametersAndAngularPositionsRaw,((#[[4]]==="Y"))&]},Module[{portConditions=True},With[{chamberCenter={inputPortVertex+sideThicknessList[[1]]+chamberRadius,0,0},minZ=inputPortVertex,maxZ=inputPortVertex+minZSideThickness+maxZSideThickness+2*chamberRadius,minX=-minXSideThickness - chamberRadius,maxX=maxXSideThickness+chamberRadius,minY=-minYSideThickness - chamberRadius,maxY=maxYSideThickness+chamberRadius},portConditions=portConditions&&Apply[And,Table[With[{portCenter={chamberRadius*Sin[portsAlongZAxis[[i,2]]]*Cos[portsAlongZAxis[[i,3]]]+chamberCenter[[1]],chamberRadius*Sin[portsAlongZAxis[[i,2]]]*Sin[portsAlongZAxis[[i,3]]]+chamberCenter[[2]],chamberRadius*Cos[portsAlongZAxis[[i,2]]]+chamberCenter[[3]]},portRadius =portsAlongZAxis[[i,1]]/2},(Sqrt[((x-portCenter[[2]])^2)+((y-portCenter[[3]])^2) ]>= portRadius||If[portCenter[[1]]>= chamberCenter[[1]],z<=  chamberCenter[[1]],z>=   chamberCenter[[1]]])],{i,1,Length[portsAlongZAxis]}]]&&Apply[And,Table[With[{portCenter={chamberRadius*Sin[portsAlongXAxis[[i,2]]]*Cos[portsAlongXAxis[[i,3]]]+chamberCenter[[1]],chamberRadius*Sin[portsAlongXAxis[[i,2]]]*Sin[portsAlongXAxis[[i,3]]]+chamberCenter[[2]],chamberRadius*Cos[portsAlongXAxis[[i,2]]]+chamberCenter[[3]]},portRadius =portsAlongXAxis[[i,1]]/2},(Sqrt[((z-portCenter[[1]])^2)+((y-portCenter[[3]])^2) ]>= portRadius||If[portCenter[[2]]>= chamberCenter[[2]],x<=  chamberCenter[[2]],x>=   chamberCenter[[2]]])],{i,1,Length[portsAlongXAxis]}]]&&Apply[And,Table[With[{portCenter={chamberRadius*Sin[portsAlongYAxis[[i,2]]]*Cos[portsAlongYAxis[[i,3]]]+chamberCenter[[1]],chamberRadius*Sin[portsAlongYAxis[[i,2]]]*Sin[portsAlongYAxis[[i,3]]]+chamberCenter[[2]],chamberRadius*Cos[portsAlongYAxis[[i,2]]]+chamberCenter[[3]]},portRadius =portsAlongYAxis[[i,1]]/2},(Sqrt[((z-portCenter[[1]])^2)+((x-portCenter[[2]])^2) ]>= portRadius||If[portCenter[[3]]>= chamberCenter[[3]],y<=  chamberCenter[[3]],y>=   chamberCenter[[3]]])],{i,1,Length[portsAlongYAxis]}]];RegionPlot3D[(*main body*)minZ<=z<= maxZ&&minX<=x<= maxX&&(*sphere inside*)minY<=y<= maxY&&(z-chamberCenter[[1]])^2+(x-chamberCenter[[2]])^2+(y-chamberCenter[[3]])^2>= chamberRadius^2&&portConditions,{z,minZ-0.1*chamberRadius,maxZ+0.1*chamberRadius},{x,minX-0.1*chamberRadius,maxX+0.1*chamberRadius},{y,minY-0.1*chamberRadius,maxY+0.1*chamberRadius},PlotPoints->100,PlotStyle->Directive[Opacity[0.5],GrayLevel[0.3]],Mesh->False,AxesLabel->Automatic,Lighting->"Neutral"]]]]]


(* ::Input::Initialization::Bold:: *)
Options[drawIntegratingSphere]={DrawSphericalOuterSurface->False,DrawOuterCuboidalSurface->True};


(* ::Input::Initialization::Bold:: *)
drawIntegratingSphere[inputPortVertex_,inPlanePortDiametersAndAngularPositionsRaw_,chamberRadius_,(*list in order: left, top, right, bottom*)sideThicknessList_,opts:OptionsPattern[drawIntegratingSphere]]:=With[{chamberCenter={inputPortVertex+sideThicknessList[[1]]+chamberRadius,0},sideThicknessLeft=sideThicknessList[[1]],sideThicknessTop=sideThicknessList[[2]],sideThicknessRight=sideThicknessList[[3]],sideThicknessBottom=sideThicknessList[[4]],inPlanePortDiametersAndAngularPositions=Sort[inPlanePortDiametersAndAngularPositionsRaw,(#1[[2]]>#2[[2]]&)]},Show[Table[With[{inpuPortDiameterInAngles=2*ArcSin[(0.5 inPlanePortDiametersAndAngularPositions[[i,1]])/chamberRadius],nextInputPortDiameterInAngles=2*ArcSin[(0.5 inPlanePortDiametersAndAngularPositions[[If[i+1<= Length[inPlanePortDiametersAndAngularPositions],i+1,1],1]])/chamberRadius]},With[{initAngle=inPlanePortDiametersAndAngularPositions[[i,2]]-inpuPortDiameterInAngles/2,endAngle=If[i+1<=  Length[inPlanePortDiametersAndAngularPositions],inPlanePortDiametersAndAngularPositions[[i+1,2]]+nextInputPortDiameterInAngles/2,inPlanePortDiametersAndAngularPositions[[1,2]]-2\[Pi]+nextInputPortDiameterInAngles/2]},Graphics[{Circle[chamberCenter,chamberRadius,{initAngle,endAngle}]}]]],{i,1,Length[inPlanePortDiametersAndAngularPositions]}],(*top Line*)With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=180Degree&&#[[2]]>0Degree&&#[[3]]==="V")||(#[[2]]<=135Degree&&#[[2]]>45Degree&&#[[3]]==="D"))&]},{Graphics[Table[With[{angleLeftEnd=holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],angleRightEnd=holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius]},{Line[{{chamberRadius*Cos[angleLeftEnd],chamberRadius*Sin[angleLeftEnd]}+chamberCenter,{chamberRadius*Cos[angleLeftEnd],chamberRadius+sideThicknessTop}+chamberCenter}],Line[{{chamberRadius*Cos[angleRightEnd],chamberRadius*Sin[angleRightEnd]}+chamberCenter,{chamberRadius*Cos[angleRightEnd],chamberRadius+sideThicknessTop}+chamberCenter}]}],{i,1,Length[holes]}]],If[OptionValue[DrawOuterCuboidalSurface],With[{topWallSegments=getIntegratingSphereTopWallSegments[inPlanePortDiametersAndAngularPositions,chamberRadius,chamberCenter,sideThicknessLeft,sideThicknessTop,sideThicknessRight,opts]},Graphics[Table[Line[topWallSegments[[j]]],{j,1,Length[topWallSegments]}]]],{}]}],(*right side*)With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=90Degree&&#[[2]]>-90Degree&&#[[3]]==="H")||((#[[2]]<=45Degree&&#[[2]]>-45Degree&&#[[3]]==="D")))&]},{Graphics[Table[With[{angleLeftEnd=holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],angleRightEnd=holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius]},{Line[{{chamberRadius*Cos[angleLeftEnd],chamberRadius*Sin[angleLeftEnd]}+chamberCenter,{chamberRadius+sideThicknessRight,chamberRadius*Sin[angleLeftEnd]}+chamberCenter}],Line[{{chamberRadius*Cos[angleRightEnd],chamberRadius*Sin[angleRightEnd]}+chamberCenter,{chamberRadius+sideThicknessRight,chamberRadius*Sin[angleRightEnd]}+chamberCenter}]}],{i,1,Length[holes]}]],If[OptionValue[DrawOuterCuboidalSurface],With[{rightWallSegments=getIntegratingSphereRightWallSegments[inPlanePortDiametersAndAngularPositions,chamberRadius,chamberCenter,sideThicknessTop,sideThicknessRight,sideThicknessBottom,opts]},Graphics[Table[Line[rightWallSegments[[j]]],{j,1,Length[rightWallSegments],1}]]],{}]}],(*bottom line*)With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=-45Degree&&#[[2]]>-135Degree&&#[[3]]==="D")||(#[[2]]<=0Degree&&#[[2]]>-180Degree&&#[[3]]==="V"))&]},{Graphics[Table[With[{angleLeftEnd=holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],angleRightEnd=holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius]},{Line[{{chamberRadius*Cos[angleLeftEnd],chamberRadius*Sin[angleLeftEnd]}+chamberCenter,{chamberRadius*Cos[angleLeftEnd],-chamberRadius-sideThicknessBottom}+chamberCenter}],Line[{{chamberRadius*Cos[angleRightEnd],chamberRadius*Sin[angleRightEnd]}+chamberCenter,{chamberRadius*Cos[angleRightEnd],-chamberRadius-sideThicknessBottom}+chamberCenter}]}],{i,1,Length[holes]}]],If[OptionValue[DrawOuterCuboidalSurface],With[{bottomWallSegments=getIntegratingSphereBottomWallSegments[inPlanePortDiametersAndAngularPositions,chamberRadius,chamberCenter,sideThicknessRight,sideThicknessBottom,sideThicknessLeft,opts]},Graphics[Table[Line[bottomWallSegments[[j]]],{j,1,Length[bottomWallSegments]}]]],{}]}],(*left line*)With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=-135Degree||#[[2]]>135Degree)&&(#[[3]]==="D") || (#[[2]]<=-90Degree||#[[2]]>90Degree)&&(#[[3]]==="H"))&]},{Graphics[Table[With[{angleLeftEnd=holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],angleRightEnd=holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius]},{Line[{{chamberRadius*Cos[angleLeftEnd],chamberRadius*Sin[angleLeftEnd]}+chamberCenter,{-chamberRadius-sideThicknessLeft,chamberRadius*Sin[angleLeftEnd]}+chamberCenter}],Line[{{chamberRadius*Cos[angleRightEnd],chamberRadius*Sin[angleRightEnd]}+chamberCenter,{-chamberRadius-sideThicknessLeft,chamberRadius*Sin[angleRightEnd]}+chamberCenter}]}],{i,1,Length[holes]}]],If[OptionValue[DrawOuterCuboidalSurface],With[{leftWallSegments=getIntegratingSphereLeftWallSegments[inPlanePortDiametersAndAngularPositions,chamberRadius,chamberCenter,sideThicknessLeft,sideThicknessTop,sideThicknessBottom,opts]},Graphics[Table[Line[leftWallSegments[[j]]],{j,1,Length[leftWallSegments]}]]],{}]}],(*outer spherical surface*)If[OptionValue[DrawSphericalOuterSurface],Graphics[Circle[chamberCenter,chamberRadius+Min[sideThicknessList]]],{}]]]


(* ::Input::Initialization::Bold:: *)
getIntegratingSphereLeftWallSegments[inPlanePortDiametersAndAngularPositions_,chamberRadius_,chamberCenter_,sideThicknessLeft_,sideThicknessTop_,sideThicknessBottom_,opts:OptionsPattern[drawIntegratingSphere]]:=With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=-135Degree||#[[2]]>135Degree)&&(#[[3]]==="D") || (#[[2]]<=-90Degree||#[[2]]>90Degree)&&(#[[3]]==="H"))&]},Module[{endpointAngles={{ArcTan[-chamberRadius-sideThicknessLeft,-chamberRadius-sideThicknessBottom],"D"}}},Do[endpointAngles=Join[endpointAngles,{{holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]},{holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]}}],{i,1,Length[holes]}];endpointAngles=Append[endpointAngles,{ArcTan[-chamberRadius-sideThicknessLeft,chamberRadius+sideThicknessTop],"D"}];endpointAngles=Sort[endpointAngles,(If[#1[[2]]==="H",chamberRadius*Sin[#1[[1]]],(chamberRadius+sideThicknessLeft)*If[#1[[1]]<0,-Tan[\[Pi]+#1[[1]]],Tan[\[Pi]-#1[[1]]]]]<If[#2[[2]]==="H",chamberRadius*Sin[#2[[1]]],(chamberRadius+sideThicknessLeft)*If[#2[[1]]<0,-Tan[\[Pi]+#2[[1]]],Tan[\[Pi]-#2[[1]]]]]&)];Table[{{-chamberRadius+chamberCenter[[1]]-sideThicknessLeft,If[endpointAngles[[j,2]]==="H",chamberRadius*Sin[endpointAngles[[j,1]]],(chamberRadius+sideThicknessLeft)*If[endpointAngles[[j,1]]<0,-Tan[\[Pi]+endpointAngles[[j,1]]],Tan[\[Pi]-endpointAngles[[j,1]]]]]+chamberCenter[[2]]},{-chamberRadius+chamberCenter[[1]]-sideThicknessLeft,If[endpointAngles[[j+1,2]]==="H",chamberRadius*Sin[endpointAngles[[j+1,1]]],(chamberRadius+sideThicknessLeft)*If[endpointAngles[[j+1,1]]<0,-Tan[\[Pi]+endpointAngles[[j+1,1]]],Tan[\[Pi]-endpointAngles[[j+1,1]]]]]+chamberCenter[[2]]}},{j,1,Length[endpointAngles],2}]]]


(* ::Input::Initialization::Bold:: *)
getIntegratingSphereTopWallSegments[inPlanePortDiametersAndAngularPositions_,chamberRadius_,chamberCenter_,sideThicknessLeft_,sideThicknessTop_,sideThicknessRight_,opts:OptionsPattern[drawIntegratingSphere]]:=With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=180Degree&&#[[2]]>0Degree&&#[[3]]==="V")||(#[[2]]<=135Degree&&#[[2]]>45Degree&&#[[3]]==="D"))&]},{Module[{endpointAngles={{ArcTan[-chamberRadius-sideThicknessLeft,chamberRadius+sideThicknessTop],"D"}}},Do[endpointAngles=Join[endpointAngles,{{holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]},{holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]}}],{i,1,Length[holes]}];endpointAngles=Append[endpointAngles,{ArcTan[chamberRadius+sideThicknessRight,chamberRadius+sideThicknessTop],"D"}];endpointAngles=Sort[endpointAngles,(If[#1[[2]]==="V",chamberRadius*Cos[#1[[1]]],(chamberRadius+sideThicknessTop)*If[#1[[1]]>\[Pi]/2,-Tan[#1[[1]]-\[Pi]/2],Tan[\[Pi]/2-#1[[1]]]]]<If[#2[[2]]==="V",chamberRadius*Cos[#2[[1]]],(chamberRadius+sideThicknessTop)*If[#2[[1]]>\[Pi]/2,-Tan[#2[[1]]-\[Pi]/2],Tan[\[Pi]/2-#2[[1]]]]]&)];Table[{{If[endpointAngles[[j,2]]==="V",chamberRadius*Cos[endpointAngles[[j,1]]],(chamberRadius+sideThicknessTop)*If[endpointAngles[[j,1]]>\[Pi]/2,-Tan[endpointAngles[[j,1]]-\[Pi]/2],Tan[\[Pi]/2-endpointAngles[[j,1]]]]]+chamberCenter[[1]],chamberRadius+chamberCenter[[2]]+sideThicknessTop},{If[endpointAngles[[j+1,2]]==="V",chamberRadius*Cos[endpointAngles[[j+1,1]]],(chamberRadius+sideThicknessTop)*If[endpointAngles[[j+1,1]]>\[Pi]/2,-Tan[endpointAngles[[j+1,1]]-\[Pi]/2],Tan[\[Pi]/2-endpointAngles[[j+1,1]]]]]+chamberCenter[[1]],chamberRadius+chamberCenter[[2]]+sideThicknessTop}},{j,1,Length[endpointAngles],2}]]}]


(* ::Input::Initialization::Bold:: *)
getIntegratingSphereRightWallSegments[inPlanePortDiametersAndAngularPositions_,chamberRadius_,chamberCenter_,sideThicknessTop_,sideThicknessRight_,sideThicknessBottom_,opts:OptionsPattern[drawIntegratingSphere]]:=With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=90Degree&&#[[2]]>-90Degree&&#[[3]]==="H")||((#[[2]]<=45Degree&&#[[2]]>-45Degree&&#[[3]]==="D")))&]},{Module[{endpointAngles={{ArcTan[chamberRadius+sideThicknessRight,chamberRadius+sideThicknessTop],"D"}}},Do[endpointAngles=Join[endpointAngles,{{holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]},{holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]}}],{i,1,Length[holes]}];endpointAngles=Append[endpointAngles,{ArcTan[chamberRadius+sideThicknessRight,-chamberRadius-sideThicknessBottom],"D"}];endpointAngles=Sort[endpointAngles,(If[#1[[2]]==="H",chamberRadius*Sin[#1[[1]]],(chamberRadius+sideThicknessRight)*Tan[#1[[1]]]]>If[#2[[2]]==="H",chamberRadius*Sin[#2[[1]]],(chamberRadius+sideThicknessRight)*Tan[#2[[1]]]]&)];Table[{{chamberRadius+chamberCenter[[1]]+sideThicknessRight,If[endpointAngles[[j,2]]==="H",chamberRadius*Sin[endpointAngles[[j,1]]],(chamberRadius+sideThicknessRight)*Tan[endpointAngles[[j,1]]]]+chamberCenter[[2]]},{chamberRadius+chamberCenter[[1]]+sideThicknessRight,If[endpointAngles[[j+1,2]]==="H",chamberRadius*Sin[endpointAngles[[j+1,1]]],(chamberRadius+sideThicknessRight)*Tan[endpointAngles[[j+1,1]]]]+chamberCenter[[2]]}},{j,1,Length[endpointAngles],2}]]}]


(* ::Input::Initialization::Bold:: *)
getIntegratingSphereBottomWallSegments[inPlanePortDiametersAndAngularPositions_,chamberRadius_,chamberCenter_,sideThicknessRight_,sideThicknessBottom_,sideThicknessLeft_,opts:OptionsPattern[drawIntegratingSphere]]:=With[{holes=Select[inPlanePortDiametersAndAngularPositions,((#[[2]]<=-45Degree&&#[[2]]>-135Degree&&#[[3]]==="D")||(#[[2]]<=0Degree&&#[[2]]>-180Degree&&#[[3]]==="V"))&]},{Module[{endpointAngles={{ArcTan[chamberRadius+sideThicknessRight,-chamberRadius-sideThicknessBottom],"D"}}},Do[endpointAngles=Join[endpointAngles,{{holes[[i,2]]+ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]},{holes[[i,2]]-ArcSin[(0.5 holes[[i,1]])/chamberRadius],holes[[i,3]]}}],{i,1,Length[holes]}];endpointAngles=Append[endpointAngles,{ArcTan[-chamberRadius-sideThicknessLeft,-chamberRadius-sideThicknessBottom],"D"}];endpointAngles=Sort[endpointAngles,(If[#1[[2]]==="V",chamberRadius*Cos[#1[[1]]],(chamberRadius+sideThicknessBottom)*If[#1[[1]]<-(\[Pi]/2),-Tan[-#1[[1]]-\[Pi]/2],Tan[\[Pi]/2+#1[[1]]]]]>If[#2[[2]]==="V",chamberRadius*Cos[#2[[1]]],(chamberRadius+sideThicknessBottom)*If[#2[[1]]<-(\[Pi]/2),-Tan[-#2[[1]]-\[Pi]/2],Tan[\[Pi]/2+#2[[1]]]]]&)];Table[{{If[endpointAngles[[j,2]]==="V",chamberRadius*Cos[endpointAngles[[j,1]]],(chamberRadius+sideThicknessBottom)*If[endpointAngles[[j,1]]<-(\[Pi]/2),-Tan[-endpointAngles[[j,1]]-\[Pi]/2],Tan[\[Pi]/2+endpointAngles[[j,1]]]]]+chamberCenter[[1]],-chamberRadius+chamberCenter[[2]]-sideThicknessBottom},{If[endpointAngles[[j+1,2]]==="V",chamberRadius*Cos[endpointAngles[[j+1,1]]],(chamberRadius+sideThicknessBottom)*If[endpointAngles[[j+1,1]]<-(\[Pi]/2),-Tan[-endpointAngles[[j+1,1]]-\[Pi]/2],Tan[\[Pi]/2+endpointAngles[[j+1,1]]]]]+chamberCenter[[1]],-chamberRadius+chamberCenter[[2]]-sideThicknessBottom}},{j,1,Length[endpointAngles],2}]]}]


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithintegratingSphereFrontWall[ray_,frontWallZPosition_,inputPortRRange_]:=(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null ,ray,With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,2,1]],ray[[-1,2,2]],frontWallZPosition]},If[rayIncidencePoint =!= Null&&((checkIfValueIsWithinInterval[inputPortRRange,rayIncidencePoint[[2]]])) ,Append[ray,{rayIncidencePoint,ray[[-1,2]],ray[[-1,-1]]}],Append[ray,{rayIncidencePoint,Null,ray[[-1,-1]]}]]]])


(* ::Input::Initialization::Bold:: *)
subjectRayToInteractionWithIntegratingSphereFrontWall3D[ray_,frontWallZPosition_,inputPorCenterX_,inputPorCenterY_,inputPortDiameter_]:=(If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{rayIncidencePoint=findRayVerticalPlanarSurfaceIntersection3D[ray[[-1,1,1]],ray[[-1,1,2]],ray[[-1,1,3]],ray[[-1,2,1]],ray[[-1,2,2]],ray[[-1,2,3]],frontWallZPosition]},If[rayIncidencePoint =!= Null&&Sqrt[(rayIncidencePoint[[2]]-inputPorCenterX)^2+(rayIncidencePoint[[3]]-inputPorCenterY)^2]< inputPortDiameter/2 ,Append[ray,{rayIncidencePoint,ray[[-1,2]],ray[[-1,-1]]}],Append[ray,{rayIncidencePoint,Null,ray[[-1,-1]]}]]]])


(* ::Input::Initialization:: *)
(*it is assumed that the ray already interacted with the front wall of the sphere, it is assumed that that the input port walls are parallel the the Z axis*)subjectRayToInteractionWithIntegratingSphereNonReflectiveHorizontalInputPortTube[ray_,inputPortVertex_,inputPortRRange_,inputPortAngularRange_,chamberRadius_,chamberCenter_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},With[{intersection1=findRayHorizontalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,inputPortRRange[[1]]],intersection2=findRayHorizontalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,inputPortRRange[[2]]]},

Which[intersection1=!=Null&&intersection1[[1]]<= (chamberRadius*Cos[inputPortAngularRange[[1]]]+chamberCenter[[1]])&&intersection1[[1]]>= inputPortVertex(*ray hits the first inner wall of the port*),Append[ray,{intersection1,Null,ray[[-1,-1]]}],intersection2=!=Null&&intersection2[[1]]<= (chamberRadius*Cos[inputPortAngularRange[[2]]]+chamberCenter[[1]])&&intersection2[[1]]>= inputPortVertex(*ray hits the second inner wall of the port*),Append[ray,{intersection2,Null,ray[[-1,-1]]}],True,(*ray reaches the inside of the chamber*)


With[{d=Max[findRayCircleIntersectionsScalarFactors[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,chamberCenter[[1]],chamberCenter[[2]],chamberRadius]]},With[{rayChamberEntrancePoint={sz+d*\[CapitalDelta]z,sr+d*\[CapitalDelta]r}},Append[ray,{rayChamberEntrancePoint,ray[[-1,2]],ray[[-1,-1]]}]]]]]]]


(* ::Input::Initialization:: *)
(*it is assumed that the ray already interacted with the front wall of the sphere, it is assumed that that the input port walls are parallel the the Z axis*)subjectRayToInteractionWithIntegratingSphereNonReflectiveHorizontalInputPortTube3D[ray_,inputPortVertex_,inputPortDimaterAndAngularPosition3D_,inputPorCenterX_,inputPorCenterY_,chamberRadius_,chamberCenter_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]]},With[{tubeCenterX=chamberRadius*Sin[inputPortDimaterAndAngularPosition3D[[2]]]*Sin[inputPortDimaterAndAngularPosition3D[[3]]]+chamberCenter[[2]],tubeCenterY=chamberRadius*Cos[inputPortDimaterAndAngularPosition3D[[2]]]+chamberCenter[[3]]},With[{intersection=findRayZAxisTubeIntersection[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,tubeCenterX,tubeCenterY,inputPortDimaterAndAngularPosition3D[[1]]]},

Which[intersection=!=Null&&Length[intersection]>= 3&&chamberRadius^2<= (intersection[[1]]-chamberCenter[[1]])^2+ (intersection[[2]]-chamberCenter[[2]])^2+ (intersection[[3]]-chamberCenter[[3]])^2&&intersection[[1]]<= chamberCenter[[1]]&&intersection[[1]]>= inputPortVertex(*ray hits the inner wall of the port*),Append[ray,{intersection,Null,ray[[-1,-1]]}],True,(*ray reaches the inside of the chamber*)


With[{d=Max[findRaySphereIntersectionsScalarFactors[sz,sx,sy,\[CapitalDelta]z,\[CapitalDelta]x,\[CapitalDelta]y,chamberCenter[[1]],chamberCenter[[2]],chamberCenter[[3]],chamberRadius]]},With[{rayChamberEntrancePoint={sz+d*\[CapitalDelta]z,sx+d*\[CapitalDelta]x,sy+d*\[CapitalDelta]y}},Append[ray,{rayChamberEntrancePoint,ray[[-1,2]],ray[[-1,-1]]}]]]]]]]]


(* ::Input::Initialization:: *)
(*it is assumed that the ray already interacted with the front wall of the sphere, it is assumed that that the input port walls are parallel the the Z axis*)subjectRayToInteractionWithIntegratingSphereNonReflectiveHorizontalOutputPortTube[ray_,outputPortEndVertex_,outputPortAngularRange_,outputPortAngularRayCatchinRanges_,chamberRadius_,chamberCenter_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},With[{rayIncidanceAngle=ArcTan[sz-chamberCenter[[1]],sr-chamberCenter[[2]]]},If[checkIfValueIsWithinAnyInterval[outputPortAngularRayCatchinRanges,rayIncidanceAngle],With[{intersection1=findRayHorizontalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,chamberRadius*Sin[outputPortAngularRange[[1]]]],intersection2=findRayHorizontalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,chamberRadius*Sin[outputPortAngularRange[[2]]]]},

Which[intersection1=!=Null&&intersection1[[1]]>=  (chamberRadius*Cos[outputPortAngularRange[[1]]]+chamberCenter[[1]])&&intersection1[[1]]<=  outputPortEndVertex(*ray hits the first inner wall of the port*),Append[ray,{intersection1,Null,ray[[-1,-1]]}],intersection2=!=Null&&intersection2[[1]]>= (chamberRadius*Cos[outputPortAngularRange[[2]]]+chamberCenter[[1]])&&intersection2[[1]]<=  outputPortEndVertex(*ray hits the second inner wall of the port*),Append[ray,{intersection2,Null,ray[[-1,-1]]}],True,(*ray reaches the inside of the chamber*)


With[{sphereExitPoint=findRayVerticalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,outputPortEndVertex]},Append[ray,{sphereExitPoint,ray[[-1,2]],ray[[-1,-1]]}]]]],ray]]]]


(* ::Input::Initialization:: *)
(*it is assumed that the ray already interacted with the front wall of the sphere, it is assumed that that the input port walls are parallel the the Z axis*)subjectRayToInteractionWithIntegratingSphereNonReflectiveHorizontalOutputPortTube[rayOriginal_,outputPortEndVertex_,outputPortAngularRange_,outputPortAngularRayCatchinRanges_,chamberRadius_,chamberCenter_, rayReflectionProbability_]:=Module[{ray=rayOriginal,outputOnTheLeftWall=Cos[outputPortAngularRange[[1]]]<0},If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},With[{rayIncidanceAngle=ArcTan[sz-chamberCenter[[1]],sr-chamberCenter[[2]]]},If[checkIfValueIsWithinAnyInterval[outputPortAngularRayCatchinRanges,rayIncidanceAngle],With[{intersection1=findRayHorizontalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,chamberRadius*Sin[outputPortAngularRange[[1]]]],intersection2=findRayHorizontalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,chamberRadius*Sin[outputPortAngularRange[[2]]]]},

Which[intersection1=!=Null&&(*ray hits the first inner wall of the port*)If[outputOnTheLeftWall,intersection1[[1]]<=   (chamberRadius*Cos[outputPortAngularRange[[1]]]+chamberCenter[[1]])&&intersection1[[1]]>=   outputPortEndVertex,intersection1[[1]]>=  (chamberRadius*Cos[outputPortAngularRange[[1]]]+chamberCenter[[1]])&&intersection1[[1]]<=  outputPortEndVertex],Append[ray,{intersection1,Null,ray[[-1,-1]]}],intersection2=!=Null&&(*ray hits the second inner wall of the port*)If[outputOnTheLeftWall,intersection2[[1]]<=  (chamberRadius*Cos[outputPortAngularRange[[2]]]+chamberCenter[[1]])&&intersection2[[1]]>=   outputPortEndVertex,intersection2[[1]]>= (chamberRadius*Cos[outputPortAngularRange[[2]]]+chamberCenter[[1]])&&intersection2[[1]]<=  outputPortEndVertex],Append[ray,{intersection2,Null,ray[[-1,-1]]}],True,(*ray reaches the inside of the chamber*)


With[{sphereExitPoint=If[outputOnTheLeftWall(*output port located to the left, rays propagate in the opposite direction*),findRayBackwardPropagationVerticalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,outputPortEndVertex],findRayVerticalPlanarSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,outputPortEndVertex]]},If[RandomReal[]<= rayReflectionProbability,With[{reflectedUnitVector=findReflectedRayUnitVector[ray[[-1,2]],{-Sign[Cos[outputPortAngularRange[[1]]]],0}]},ray=Append[ray,{sphereExitPoint,reflectedUnitVector,ray[[-1,-1]]}];With[{intersectionReflected1=findRayHorizontalPlanarSurfaceIntersection[sphereExitPoint[[1]],sphereExitPoint[[2]],reflectedUnitVector[[1]],reflectedUnitVector[[2]],chamberRadius*Sin[outputPortAngularRange[[1]]]],intersectionReflected2=findRayHorizontalPlanarSurfaceIntersection[sphereExitPoint[[1]],sphereExitPoint[[2]],reflectedUnitVector[[1]],reflectedUnitVector[[2]],chamberRadius*Sin[outputPortAngularRange[[2]]]]},

Which[intersectionReflected1=!=Null&&(*sample - reflected ray hits the first inner wall of the port*)If[outputOnTheLeftWall,intersectionReflected1[[1]]<=  (chamberRadius*Cos[outputPortAngularRange[[1]]]+chamberCenter[[1]])&&intersectionReflected1[[1]]>=  outputPortEndVertex,intersectionReflected1[[1]]>=  (chamberRadius*Cos[outputPortAngularRange[[1]]]+chamberCenter[[1]])&&intersectionReflected1[[1]]<=  outputPortEndVertex],Append[ray,{intersectionReflected1,Null,ray[[-1,-1]]}],intersectionReflected2=!=Null&&(*sample - reflected ray hits the second inner wall of the port*)If[outputOnTheLeftWall,intersectionReflected2[[1]]<=  (chamberRadius*Cos[outputPortAngularRange[[2]]]+chamberCenter[[1]])&&intersectionReflected2[[1]]>=   outputPortEndVertex,intersectionReflected2[[1]]>= (chamberRadius*Cos[outputPortAngularRange[[2]]]+chamberCenter[[1]])&&intersectionReflected2[[1]]<=  outputPortEndVertex],Append[ray,{intersectionReflected2,Null,ray[[-1,-1]]}],True,(*ray reaches the inside of the chamber*)


With[{d=Min[findRayCircleIntersectionsScalarFactors[sphereExitPoint[[1]],sphereExitPoint[[2]],reflectedUnitVector[[1]],reflectedUnitVector[[2]],chamberCenter[[1]],chamberCenter[[2]],chamberRadius]]},With[{rayChamberEntrancePoint={sphereExitPoint[[1]]+d*reflectedUnitVector[[1]],sphereExitPoint[[2]]+d*reflectedUnitVector[[2]]}},Append[ray,{rayChamberEntrancePoint,ray[[-1,2]],ray[[-1,-1]]}]]]]]],Append[ray,{sphereExitPoint,ray[[-1,2]],ray[[-1,-1]]}]]]]],ray]]]]]


(* ::Input::Initialization::Bold:: *)
(*it is assumed that the ray already interacted with the front wall of the sphere, it is assumed that that the input port walls are parallel the the Z axis*)finishRaysInNonReflectivePorts[ray_,nonReflectivePortAngularRanges_,chamberRadius_,chamberCenter_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},With[{rayIncidanceAngle=ArcTan[sz-chamberCenter[[1]],sr-chamberCenter[[2]]]},If[checkIfValueIsWithinAnyInterval[nonReflectivePortAngularRanges,rayIncidanceAngle],Append[ray,{ray[[-1,1]],Null,ray[[-1,-1]]}],ray]]]]


(* ::Input::Initialization::Bold:: *)
(*assumes that ray's incidence point is on the surface of the chamber/or end of a port*)subjectRayToReflectionWithinIntegratingSphereChamber[ray_,portAngularRanges_,chamberRadius_,chamberCenter_,reflectionCountMax_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},Module[{(*https://community.wolfram.com/groups/-/m/t/364417*)rayFinal=ray,reflectionCount=0,normalToChamberSurface,reflectedUnitVector,rayIncidencePoint=ray[[-1,1]],incidentRayUnitVector=ray[[-1,2]],rayIncidanceAngle=ArcTan[sz-chamberCenter[[1]],sr-chamberCenter[[2]]]},While[reflectionCount<reflectionCountMax&&(!checkIfValueIsWithinAnyInterval[portAngularRanges,rayIncidanceAngle]),

reflectionCount = reflectionCount+1;normalToChamberSurface={-Cos[rayIncidanceAngle],-Sin[rayIncidanceAngle]};reflectedUnitVector=findReflectedRayUnitVector[incidentRayUnitVector,normalToChamberSurface];(*new ray incidencePoint*)rayIncidencePoint=With[{d=Max[findRayCircleIntersectionsScalarFactors[rayIncidencePoint[[1]],rayIncidencePoint[[2]],reflectedUnitVector[[1]],reflectedUnitVector[[2]],chamberCenter[[1]],chamberCenter[[2]],chamberRadius]]},rayIncidencePoint+d*reflectedUnitVector];

rayFinal=Append[rayFinal,{rayIncidencePoint,reflectedUnitVector,ray[[-1,-1]]}];
rayIncidanceAngle=ArcTan[rayIncidencePoint[[1]]-chamberCenter[[1]],rayIncidencePoint[[2]]-chamberCenter[[2]]];incidentRayUnitVector=reflectedUnitVector;];rayFinal]]]


(* ::Input::Initialization::Bold:: *)
(*assumes that ray's incidence point is on the surface of the chamber/or end of a port*)subjectRayToReflectionWithinIntegratingSphereChamber2[ray_,portAngularRanges_,chamberRadius_,chamberCenter_,reflectionCountMax_,outputPortEndVertex_,outputPortAngularRange_,outputPortAngularRayCatchingRanges_,samplereflectance_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sr=ray[[-1,1,2]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]r=ray[[-1,2,2]]},Module[{(*https://community.wolfram.com/groups/-/m/t/364417*)rayFinal=ray,reflectionCount=0,normalToChamberSurface,reflectedUnitVector,rayIncidencePoint=ray[[-1,1]],incidentRayUnitVector=ray[[-1,2]],rayIncidanceAngle=ArcTan[sz-chamberCenter[[1]],sr-chamberCenter[[2]]]},While[reflectionCount<reflectionCountMax&&((!checkIfValueIsWithinAnyInterval[portAngularRanges,rayIncidanceAngle])||(*ray that hits the inner face of ourput port may be still reflected by the sample*)(checkIfValueIsWithinAnyInterval[outputPortAngularRayCatchingRanges,rayIncidanceAngle])),

(*ray hit the inner face of output port*)If[checkIfValueIsWithinAnyInterval[outputPortAngularRayCatchingRanges,rayIncidanceAngle],rayFinal=subjectRayToInteractionWithIntegratingSphereNonReflectiveHorizontalOutputPortTube[rayFinal,outputPortEndVertex,outputPortAngularRange,outputPortAngularRayCatchingRanges,chamberRadius,chamberCenter,samplereflectance];(*new ray incidencePoint, after reflected ray came back to output port inner face *)rayIncidencePoint=rayFinal[[-1,1]];reflectedUnitVector=rayFinal[[-1,2]];If[(*ray reflected from sample*)Norm[reflectedUnitVector-incidentRayUnitVector]>0.0001,

(*new ray incidencePoint after it reached again true inner surface of sphere*)rayIncidencePoint=With[{d=Max[findRayCircleIntersectionsScalarFactors[rayIncidencePoint[[1]],rayIncidencePoint[[2]],reflectedUnitVector[[1]],reflectedUnitVector[[2]],chamberCenter[[1]],chamberCenter[[2]],chamberRadius]]},rayIncidencePoint+d*reflectedUnitVector];

rayFinal=Append[rayFinal,{rayIncidencePoint,reflectedUnitVector,ray[[-1,-1]]}];
rayIncidanceAngle=ArcTan[rayIncidencePoint[[1]]-chamberCenter[[1]],rayIncidencePoint[[2]]-chamberCenter[[2]]];incidentRayUnitVector=reflectedUnitVector;Continue[],Break[]],

(*ray hits ordinary inner surface of the sphere*)
normalToChamberSurface={-Cos[rayIncidanceAngle],-Sin[rayIncidanceAngle]};reflectedUnitVector=findReflectedRayUnitVector[incidentRayUnitVector,normalToChamberSurface];(*new ray incidencePoint*)rayIncidencePoint=With[{d=Max[findRayCircleIntersectionsScalarFactors[rayIncidencePoint[[1]],rayIncidencePoint[[2]],reflectedUnitVector[[1]],reflectedUnitVector[[2]],chamberCenter[[1]],chamberCenter[[2]],chamberRadius]]},rayIncidencePoint+d*reflectedUnitVector];

rayFinal=Append[rayFinal,{rayIncidencePoint,reflectedUnitVector,ray[[-1,-1]]}];
rayIncidanceAngle=ArcTan[rayIncidencePoint[[1]]-chamberCenter[[1]],rayIncidencePoint[[2]]-chamberCenter[[2]]];incidentRayUnitVector=reflectedUnitVector;];

reflectionCount = reflectionCount+1;];rayFinal]]]


(* ::Input::Initialization::Bold:: *)
(*assumes that ray's incidence point is on the surface of the chamber/or end of a port*)subjectRayToReflectionWithinIntegratingSphereChamber3D[ray_,zAxisPortDiametersAndTubeCenters_,xAxisPortDiametersAndTubeCenters_,yAxisPortDiametersAndTubeCenters_,chamberRadius_,chamberCenter_,reflectionCountMax_]:=If[ray[[-1,1]]===Null||ray[[-1,2]]===Null,ray,With[{sz=ray[[-1,1,1]],sx=ray[[-1,1,2]],sy=ray[[-1,1,3]],\[CapitalDelta]z=ray[[-1,2,1]],\[CapitalDelta]x=ray[[-1,2,2]],\[CapitalDelta]y=ray[[-1,2,3]]},Module[{(*https://community.wolfram.com/groups/-/m/t/364417*)rayFinal=ray,reflectionCount=0,normalToChamberSurface,reflectedUnitVector,rayIncidencePoint=ray[[-1,1]],incidentRayUnitVector=ray[[-1,2]]},While[reflectionCount<reflectionCountMax&&(!checkIfPointIsWithinAnyZAxisTubeOpening[rayIncidencePoint,zAxisPortDiametersAndTubeCenters])&&(!checkIfPointIsWithinAnyXAxisTubeOpening[rayIncidencePoint,xAxisPortDiametersAndTubeCenters])&&(!checkIfPointIsWithinAnyYAxisTubeOpening[rayIncidencePoint,yAxisPortDiametersAndTubeCenters]),

reflectionCount = reflectionCount+1;normalToChamberSurface=(chamberCenter-rayIncidencePoint)/Sqrt[(chamberCenter[[1]]-rayIncidencePoint[[1]])^2+(chamberCenter[[2]]-rayIncidencePoint[[2]])^2+(chamberCenter[[3]]-rayIncidencePoint[[3]])^2];reflectedUnitVector=findReflectedRayUnitVector[incidentRayUnitVector,normalToChamberSurface];(*new ray incidencePoint*)rayIncidencePoint=With[{d=Max[findRaySphereIntersectionsScalarFactors[rayIncidencePoint[[1]],rayIncidencePoint[[2]],rayIncidencePoint[[3]],reflectedUnitVector[[1]],reflectedUnitVector[[2]],reflectedUnitVector[[3]],chamberCenter[[1]],chamberCenter[[2]],chamberCenter[[3]],chamberRadius]]},rayIncidencePoint+d*reflectedUnitVector];

rayFinal=Append[rayFinal,{rayIncidencePoint,reflectedUnitVector,ray[[-1,-1]]}];incidentRayUnitVector=reflectedUnitVector;];rayFinal]]]


(* ::Input::Initialization::Bold:: *)
checkIfValueIsWithinInterval[interval_,val_]:=(val>= interval[[1]]&&val<=interval[[2]])||(val<= interval[[1]]&&val>=interval[[2]])


(* ::Input::Initialization::Bold:: *)
checkIfValueIsWithinAnyInterval[intervals_,val_]:=Module[{within=False},Do[within = within || (val>= intervals[[i,1]]&&val<=intervals[[i,2]])||(val<= intervals[[i,1]]&&val>=intervals[[i,2]]);,{i,1,Length[intervals]}];within]


(* ::Input::Initialization::Bold:: *)
convertAngleToPiMinuPiRange[angle_]:=With[{angleReduced=Sign[angle]Mod[Abs[angle],2\[Pi]]},Which[angleReduced>\[Pi],angleReduced-2\[Pi],angleReduced<-\[Pi],angleReduced+2\[Pi],True,angleReduced]]


(* ::Input::Initialization::Bold:: *)
convert3DPortPositionsTo2D[PortDiametersAndAngularPositions3D_]:=With[{portsIn2D=Select[PortDiametersAndAngularPositions3D,(Which[#[[4]]==="Z"||#[[4]]==="Y",(Mod[Abs[#[[3]]],\[Pi]]<= 0.001),#[[4]]==="X",False])&]},Table[convert3DPortPositionTo2D[portsIn2D[[i]]],{i,1,Length[portsIn2D]}]]


(* ::Input::Initialization::Bold:: *)
convert3DPortPositionTo2D[portIn2D_List]:={portIn2D[[1]],convertAngleToPiMinuPiRange[If[portIn2D[[4]]==="Z",portIn2D[[3]],If[Abs[portIn2D[[3]]]>=  \[Pi]/2,\[Pi]/2+portIn2D[[2]],\[Pi]/2-portIn2D[[2]]]]],If[portIn2D[[4]]==="Z","H","V"]}


(* ::Input::Initialization::Bold:: *)
Options[createIntegratingSphere]=Join[{IncludeOutputPortSample->False,DrawOutputPortSampleIfIncluded->True,DrawSphericalOuterSurface->False,DrawOuterCuboidalSurface->True},Options[GeneralOptomechanicalPart]];


(* ::Input::Initialization:: *)
createIntegratingSphere[inputPortVertex_,(*can be set to nonpoisitive value if there is no output port*)outputPortIndex_,(*can be set to nonpoisitive value if there is no detector port*)detectorPortIndex_,(*raw means that the order of ports is arbitrary; this list should contain also input and detector ports*)portDiametersAndAngularPositionsRaw3D_,chamberRadius_,(*list in order: minZSideThickness, maxZSideThickness, minXSideThickness, maxXSideThickness, minYSideThickness, maxYSideThickness to the viewer, maxYSideThickness,behind the viewer*)sideThicknessList_,inputPortDimaterAndAngularPosition3D_(*should be in the front wall*),opts:OptionsPattern[createIntegratingSphere]]:=With[{inputPortIndex=1,inputPortDimaterAndAngularPosition2D=convert3DPortPositionTo2D[inputPortDimaterAndAngularPosition3D],inPlanePortDiametersAndAngularPositionsRaw2D=convert3DPortPositionsTo2D[portDiametersAndAngularPositionsRaw3D]},Module[{self,(*sorted according to the angle*)inPlanePortDiametersAndAngularPositions2D=Sort[inPlanePortDiametersAndAngularPositionsRaw2D,(#1[[2]]>#2[[2]]&)],chamberCenter={inputPortVertex+sideThicknessList[[1]]+chamberRadius,0,0},inputPortAngularRange={convertAngleToPiMinuPiRange[inputPortDimaterAndAngularPosition2D[[2]]+ArcSin[(0.5 (*inputPortDiameter*)inputPortDimaterAndAngularPosition2D[[1]])/chamberRadius]],convertAngleToPiMinuPiRange[inputPortDimaterAndAngularPosition2D[[2]]-ArcSin[(0.5 (*inputPortDiameter*)inputPortDimaterAndAngularPosition2D[[1]])/chamberRadius]]},outputPortAngularRange=If[outputPortIndex >=  1,{convertAngleToPiMinuPiRange[inPlanePortDiametersAndAngularPositionsRaw2D[[outputPortIndex,2]]+ArcSin[(0.5 (*outputPortDiameter*)inPlanePortDiametersAndAngularPositionsRaw2D[[outputPortIndex,1]])/chamberRadius]],convertAngleToPiMinuPiRange[inPlanePortDiametersAndAngularPositionsRaw2D[[outputPortIndex,2]]-ArcSin[(0.5 (*outputPortDiameter*)inPlanePortDiametersAndAngularPositionsRaw2D[[outputPortIndex,1]])/chamberRadius]]},(*no output port*){}],outputPortAngularRayCatchingRanges=getAngularRangesTakingIntoAccountPiMinusPiBoundary[{inPlanePortDiametersAndAngularPositionsRaw2D[[outputPortIndex]]},chamberRadius],detectorPortAngularRange=If[outputPortIndex >=  1,{convertAngleToPiMinuPiRange[inPlanePortDiametersAndAngularPositionsRaw2D[[detectorPortIndex,2]]+ArcSin[(0.5 (*outputPortDiameter, wazne zeby listy raw uzywac, bo nie jest sorted*)inPlanePortDiametersAndAngularPositionsRaw2D[[detectorPortIndex,1]])/chamberRadius]],convertAngleToPiMinuPiRange[inPlanePortDiametersAndAngularPositionsRaw2D[[detectorPortIndex,2]]-ArcSin[(0.5 (*outputPortDiameter*)inPlanePortDiametersAndAngularPositionsRaw2D[[detectorPortIndex,1]])/chamberRadius]]},(*no detector port*){}]},


With[{outputPortEndVertex=If[outputPortIndex >=  1(*makes sure there is an output port*)&&Cos[outputPortAngularRange[[1]]]<0(*output port to the left*),inputPortVertex,inputPortVertex+sideThicknessList[[1]]+2*chamberRadius+sideThicknessList[[2]]],allPortsAngularRange=getAngularRangesTakingIntoAccountPiMinusPiBoundary[inPlanePortDiametersAndAngularPositions2D,chamberRadius],nonReflectivePortAngularRanges=If[detectorPortIndex>= 1,getAngularRangesTakingIntoAccountPiMinusPiBoundary[Join[{inPlanePortDiametersAndAngularPositionsRaw2D[[detectorPortIndex]],inPlanePortDiametersAndAngularPositionsRaw2D[[inputPortIndex]]}],chamberRadius],{}],inputPortRRange={chamberRadius*Sin[inputPortAngularRange[[1]]],chamberRadius*Sin[inputPortAngularRange[[2]]]},zAxisPortDiametersAndTubeCenters=Map[{#[[1]],{chamberRadius*Sin[#[[2]]]*Cos[#[[3]]]+chamberCenter[[1]],chamberRadius*Sin[#[[2]]]*Sin[#[[3]]]+chamberCenter[[2]],chamberRadius*Cos[#[[2]]]+chamberCenter[[3]]}}&,Select[portDiametersAndAngularPositionsRaw3D,((#[[4]]==="Z")&)]],xAxisPortDiametersAndTubeCenters=Map[{#[[1]],{chamberRadius*Sin[#[[2]]]*Cos[#[[3]]]+chamberCenter[[1]],chamberRadius*Sin[#[[2]]]*Sin[#[[3]]]+chamberCenter[[2]],chamberRadius*Cos[#[[2]]]+chamberCenter[[3]]}}&,Select[portDiametersAndAngularPositionsRaw3D,((#[[4]]==="X")&)]],yAxisPortDiametersAndTubeCenters=Map[{#[[1]],{chamberRadius*Sin[#[[2]]]*Cos[#[[3]]]+chamberCenter[[1]],chamberRadius*Sin[#[[2]]]*Sin[#[[3]]]+chamberCenter[[2]],chamberRadius*Cos[#[[2]]]+chamberCenter[[3]]}}&,Select[portDiametersAndAngularPositionsRaw3D,((#[[4]]==="Y")&)]]},With[{outputPorSample=If[OptionValue[IncludeOutputPortSample]&&outputPortIndex>= 1,createSimpleSample[outputPortEndVertex, If[outputPortIndex >=  1(*makes sure there is an output port*)&&Cos[outputPortAngularRange[[1]]]<0(*output port to the left*),(*thickness is negative if light propagates in the backward direction*)-1,1],(*height*)1.1inPlanePortDiametersAndAngularPositionsRaw2D[[outputPortIndex,1]],(*relectivity*)0.5],createSimpleSample[outputPortEndVertex, (*thickness*)0,(*height*)0,(*relectivity*)0]]},self=Association["objectType"->"integratingSphere","objectId"->OptionValue[PartId],"minimalCenterZ"->inputPortVertex,"vertex"->inputPortVertex,"inPlanePortDiametersAndAngularPositionsRaw2D"->portDiametersAndAngularPositionsRaw3D,"chamberRadius"->chamberRadius,"sideThicknessList"->sideThicknessList,"draw2D"->(Show[If[OptionValue[IncludeOutputPortSample]&&OptionValue[DrawOutputPortSampleIfIncluded],outputPorSample["draw2D"][],{}],drawIntegratingSphere[inputPortVertex,inPlanePortDiametersAndAngularPositionsRaw2D,chamberRadius,Take[sideThicknessList,{1,4}],FilterRules[{opts},Options[drawIntegratingSphere]]]]&),"draw3D"->(drawIntegratingSphere3D[inputPortVertex,portDiametersAndAngularPositionsRaw3D,chamberRadius,sideThicknessList]&),"interactWithRays2D"->Function[{raysObject,surroundingMedium},self["refractRays2D"][raysObject,surroundingMedium]],"refractRays2D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"]},createRaysObject[With[{raysAfterFirstSurface=ParallelMap[subjectRayToInteractionWithintegratingSphereFrontWall[#,inputPortVertex,inputPortRRange]&,rays]},With[{raysAfterSecondSurface=ParallelMap[subjectRayToInteractionWithIntegratingSphereNonReflectiveHorizontalInputPortTube[#,inputPortVertex,inputPortRRange,inputPortAngularRange,chamberRadius,chamberCenter]&,raysAfterFirstSurface]},With[{raysAfterRelectionWithinIntegratingSphere=If[outputPortIndex>= 1,ParallelMap[subjectRayToReflectionWithinIntegratingSphereChamber2[#,allPortsAngularRange,chamberRadius,chamberCenter,100,outputPortEndVertex,outputPortAngularRange,outputPortAngularRayCatchingRanges,outputPorSample["reflectance"]]&,raysAfterSecondSurface],ParallelMap[subjectRayToReflectionWithinIntegratingSphereChamber[#,allPortsAngularRange,chamberRadius,chamberCenter,200]&,raysAfterSecondSurface]]},With[{raysAfterInteractionWithNonReflectivePorts=ParallelMap[finishRaysInNonReflectivePorts[#,nonReflectivePortAngularRanges,chamberRadius,chamberCenter]&,raysAfterRelectionWithinIntegratingSphere]},raysAfterInteractionWithNonReflectivePorts]]]],raysObject["wavelength"]]]]),"refractRays2DAndDraw"->Function[{raysObject,surroundingMedium},With[{refractedRays=(self["refractRays2D"][raysObject,surroundingMedium])["traces"]},Show[Graphics[{AbsoluteThickness[0.3],Table[Table[Line[{refractedRays[[i,j,1]],refractedRays[[i,j+1,1]]}],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]}],self["draw2D"][]]]],"interactWithRays3D"->Function[{raysObject,surroundingMedium},self["refractRays3D"][raysObject,surroundingMedium]],
"refractRays3D"->(Function[{raysObject,surroundingMedium},With[{rays=raysObject["traces"]},With[{inputPorCenterX=chamberRadius*Sin[inputPortDimaterAndAngularPosition3D[[2]]]*Sin[inputPortDimaterAndAngularPosition3D[[3]]]+chamberCenter[[2]],inputPorCenterY=chamberRadius*Cos[inputPortDimaterAndAngularPosition3D[[2]]]+chamberCenter[[3]]},createRaysObject[With[{raysAfterSphereFrontWall=ParallelMap[subjectRayToInteractionWithIntegratingSphereFrontWall3D[#,inputPortVertex,inputPorCenterX,inputPorCenterY,Abs[inputPortRRange[[1]]-inputPortRRange[[2]]]]&,rays]},With[{raysAfterInputPort=ParallelMap[subjectRayToInteractionWithIntegratingSphereNonReflectiveHorizontalInputPortTube3D[#,inputPortVertex,inputPortDimaterAndAngularPosition3D,inputPorCenterX,inputPorCenterY,chamberRadius,chamberCenter]&,raysAfterSphereFrontWall]},ParallelMap[subjectRayToReflectionWithinIntegratingSphereChamber3D[#,zAxisPortDiametersAndTubeCenters,xAxisPortDiametersAndTubeCenters,yAxisPortDiametersAndTubeCenters,chamberRadius,chamberCenter,20]&,raysAfterInputPort]]],raysObject["wavelength"]]]]]),"refractRays3DAndDraw"->Function[{raysObject,surroundingMedium},With[{refractedRays=(self["refractRays3D"][raysObject,surroundingMedium])["traces"]},Show[Graphics3D[Table[Table[With[{p1=refractedRays[[i,j,1]],p2=refractedRays[[i,j+1,1]]},If[p1=!=Null&&p2=!=Null,Line[{p1,p2}],{}]],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],self["draw3D"][]]]],"createShiftedCopy"->Function[{vertexShift},createIntegratingSphere[inputPortVertex+vertexShift,portDiametersAndAngularPositionsRaw3D,chamberRadius,sideThicknessList,inputPortDimaterAndAngularPosition3D,opts]]]]]]]


(* ::Input::Initialization::Bold:: *)
getAngularRangesTakingIntoAccountPiMinusPiBoundary[inPlanePortDiametersAndAngularPositions2D_,chamberRadius_]:=ReleaseHold[Table[With[{portHalfLength=ArcSin[(0.5 inPlanePortDiametersAndAngularPositions2D[[i,1]])/chamberRadius]},With[{minAngle=convertAngleToPiMinuPiRange[inPlanePortDiametersAndAngularPositions2D[[i,2]]+portHalfLength],maxAngle=convertAngleToPiMinuPiRange[inPlanePortDiametersAndAngularPositions2D[[i,2]]-portHalfLength]},If[Abs[minAngle-maxAngle]<= 2.01*portHalfLength,{minAngle,maxAngle},HoldComplete[Sequence[{minAngle,Sign[minAngle]*\[Pi]},{Sign[maxAngle]*\[Pi],maxAngle}]]]]],{i,1,Length[inPlanePortDiametersAndAngularPositions2D]}]]


(* ::Subsubsection::Bold:: *)
(*BENCH*)


(* ::Input::Initialization::Bold:: *)
Options[createBench]:={SortAccordingToZPosition->False,SingleFanStyle->singleRayColor,MultipleFanStyle->rayStyleSequence};


(* ::Input::Initialization::Bold:: *)
createBench[surroundingMedium_String,opts:OptionsPattern[createBench]]:=Module[{self},self=Association["surfaceCount":>With[{elements=self["opticalComponents"]},Module[{count=1},Do[(count= count+(elements[[i]]["surfaceCount"])),{i,1,Length[elements]}];count]],"lastScreenSurfaceIndex":>With[{elements=self["opticalComponents"]},Module[{index=-1,surfaceCount=1},Do[(surfaceCount=surfaceCount+(elements[[i]]["surfaceCount"]);index= If[(elements[[i]]["objectType"])==="screen",surfaceCount,index]),{i,1,Length[elements]}];index]],"opticalComponentsPrivateContainer"->{},"surroundingMedium"->surroundingMedium,"opticalComponents"->self["opticalComponentsPrivateContainer"],"opticalComponentsCount"->Function[Length[self["opticalComponentsPrivateContainer"]]],"addOpticalComponents"->((self["opticalComponentsPrivateContainer"]=If[OptionValue[SortAccordingToZPosition],Sort[Join[self["opticalComponentsPrivateContainer"],{##}],(#1["minimalCenterZ"]<#2["minimalCenterZ"]&)],Join[self["opticalComponentsPrivateContainer"],{##}]])&),"shiftComponentVertex"->Function[{componentIndex,vertexShift},self["opticalComponentsPrivateContainer"]=Sort[Join[Take[self["opticalComponentsPrivateContainer"],{1,componentIndex-1}],{(self["opticalComponentsPrivateContainer"][[componentIndex]])["createShiftedCopy"][vertexShift]},Take[self["opticalComponentsPrivateContainer"],{componentIndex+1,-1}]],(#1["minimalCenterZ"]<#2["minimalCenterZ"]&)]],"draw2D"->With[{elements=self["opticalComponents"]},Function[With[{graphs=Table[(elements[[i]]["draw2D"])[],{i,1,Length[elements]}]},If[Length[Flatten[graphs]]>0,Show[graphs,PlotRange->All],{}]]]],"draw3D"->With[{elements=self["opticalComponents"]},Function[With[{graphs=Table[(elements[[i]]["draw3D"])[],{i,1,Length[elements]}]},If[Length[Flatten[graphs]]>0,Show[graphs,PlotRange->All],{}]]]],"interactWithRays2D"->With[{elements=self["opticalComponents"]},Function[{raysObject},Module[{refractedRaysObject=raysObject},Do[(refractedRaysObject=(elements[[i]]["interactWithRays2D"])[refractedRaysObject,surroundingMedium]),{i,1,Length[elements]}];refractedRaysObject]]],"interactWithMulipleRayBundles2D"->Function[{rayBundles},With[{rayBundlesList=If[AssociationQ[rayBundles],{rayBundles},rayBundles]},Table[self["interactWithRays2D"][rayBundlesList[[i]]],{i,1,Length[rayBundlesList]}]]],"interactWithRays3D"->With[{elements=self["opticalComponents"]},Function[{raysObject},Module[{refractedRaysObject=raysObject},Do[(refractedRaysObject=(elements[[i]]["interactWithRays3D"])[refractedRaysObject,surroundingMedium]),{i,1,Length[elements]}];refractedRaysObject]]],"interactWithMulipleRayBundles3D"->Function[{rayBundles},With[{rayBundlesList=If[AssociationQ[rayBundles],{rayBundles},rayBundles]},Table[self["interactWithRays3D"][rayBundlesList[[i]]],{i,1,Length[rayBundlesList]}]]],"sortOpticalElements"->Function[{},With[{elements = self["opticalComponents"]},(self["opticalComponentsPrivateContainer"]=Sort[elements,(#1["minimalCenterZ"]<#2["minimalCenterZ"]&)])]],"interactWithRays2DAndDraw"->Function[{raysObject,optionsList},With[{refractedRays=(self["interactWithRays2D"][raysObject])["traces"]},Show[self["draw2D"][],Graphics[Table[Table[With[{p1=refractedRays[[i,j,1]],p2=refractedRays[[i,j+1,1]]},If[p1=!=Null&&p2=!=Null,Line[{p1,p2}],{}]],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]],AspectRatio->Automatic,PlotRange->All,FilterRules[optionsList,Options[Graphics]]]]],"interactWithMulipleRayBundles2DAndDraw"->Function[{rayBundles,optionsList},With[{refractedRayBundlesObjects=(self["interactWithMulipleRayBundles2D"][rayBundles])},Show[self["draw2D"][],Graphics[Table[With[{refractedRayBundles=(refractedRayBundlesObjects[[m]])["traces"]},{If[(Length[rayBundles]>1 &&Head[rayBundles]===List(*can be single association, whose length is number of key - value pairs*)),getValueFromAtomOrList[m,OptionValue[MultipleFanStyle]],OptionValue[SingleFanStyle]],Table[Table[Line[{refractedRayBundles[[i,j,1]],refractedRayBundles[[i,j+1,1]]}],{j,1,Length[refractedRayBundles[[i]]]-1}],{i,1,Length[refractedRayBundles]}]}],{m,1,Length[refractedRayBundlesObjects]}]],AspectRatio->Automatic,PlotRange->All,FilterRules[optionsList,Options[Graphics]]]]],"interactWithRays3DAndDraw"->Function[{rays,optionsList},With[{refractedRays=(self["interactWithRays3D"][rays])["traces"]},Show[self["draw3D"][],Graphics3D[{Antialiasing->True,Table[Table[With[{p1=refractedRays[[i,j,1]],p2=refractedRays[[i,j+1,1]]},If[p1=!=Null&&p2=!=Null,Line[{p1,p2}],{}]],{j,1,Length[refractedRays[[i]]]-1}],{i,1,Length[refractedRays]}]}],BoxRatios->Automatic,PlotRange->All,FilterRules[optionsList,Options[Graphics3D]]]]],"interactWithMulipleRayBundles3DAndDraw"->Function[{rayBundles,optionsList},With[{refractedRayBundlesObjects=(self["interactWithMulipleRayBundles3D"][rayBundles])},Show[self["draw3D"][],Graphics3D[Table[With[{refractedRayBundles=(refractedRayBundlesObjects[[m]])["traces"]},{If[Length[rayBundles]>1,getValueFromAtomOrList[m,OptionValue[MultipleFanStyle]],OptionValue[SingleFanStyle]],Table[Table[With[{p1=refractedRayBundles[[i,j,1]],p2=refractedRayBundles[[i,j+1,1]]},If[p1=!=Null&&p2=!=Null,Line[{p1,p2}],{}]],{j,1,Length[refractedRayBundles[[i]]]-1}],{i,1,Length[refractedRayBundles]}]}],{m,1,Length[refractedRayBundlesObjects]}]],BoxRatios->Automatic,PlotRange->All,FilterRules[optionsList,Options[Graphics]]]]],"partitionRaysIncidentOnScreenIntoCircularBandsTally"->Function[{rayBundles,spacingR},With[{center={0,0},finalScreenIndex=self["lastScreenSurfaceIndex"],refractedRays=(self["interactWithMulipleRayBundles3D"][rayBundles])},If[finalScreenIndex<1,{},SortBy[partitionRaysIncidentOnScreenIntoCircularBandsTally[refractedRays,finalScreenIndex,center,spacingR],(#[[1]]&)]]]]]];


(* ::Subsubsection::Bold:: *)
(*OBJECTS*)


(* ::Input::Initialization::Bold:: *)
Options[createSimpleSample]={PlotStyle->Directive[EdgeForm[Black],FaceForm[{Green,Opacity[0.5]}]]};


(* ::Input::Initialization::Bold:: *)
createSimpleSample[vertex_?NumericQ, thickness_?NumericQ,height_?NumericQ,reflectance_,opts:OptionsPattern[createSimpleSample]]:=Module[{self},self=Association["objectType"->"sample","thickness"->thickness,"vertex"->vertex,"height"->height,"reflectance"->reflectance,"draw2D"->(Graphics[{OptionValue[PlotStyle],Rectangle[{vertex,-height/2},{vertex+thickness,height/2}]}]&),"createShiftedCopy"->Function[{vertexShift},createSimpleSample[vertex + vertexShift,thickness,height,reflectance,opts]]]]


(* ::Subsubsection::Bold:: *)
(*RAYS, FANS AND BEAMS*)


(* ::Input::Initialization::Bold:: *)
createRaysObject[traces_List,wavelength_?NumericQ]:=Module[{self},self=Association["traces"->traces,"wavelength"->wavelength,"truncateUpTo"->Function[{limit},createRaysObject[Take[self["traces"],{1,Min[limit,Length[self["traces"]]]}],self["wavelength"]]]]];


(* ::Input::Initialization::Bold:: *)
readInRaySet[file_String,vertex_?NumericQ,wavelength_?NumericQ,step_:1]:=readInRaySet[file,{vertex,0,0},wavelength,step]


(* ::Input::Initialization::Bold:: *)
readInRaySet[file_String,centerPoint_List,wavelength_?NumericQ,step_:1]:=createRaysObject[With[{rawData=Rest[Import[file,"Table"]]},Table[{{centerPoint+{rawData[[i,3]],rawData[[i,1]],rawData[[i,2]]},{rawData[[i,6]],rawData[[i,4]],rawData[[i,5]]},rawData[[i,7]]}},{i,1,Length[rawData],step}]],wavelength]


(* ::Code::Initialization::Bold:: *)
readInRaySetLightToolsAsciiExport[file_String,vertex_?NumericQ,wavelength_?NumericQ,step_:1]:=readInRaySetLightToolsAsciiExport[file,{vertex,0,0},wavelength,step]


(* ::Input::Initialization::Bold:: *)
readInRaySetLightToolsAsciiExport[file_String,centerPoint_List,wavelength_?NumericQ,step_Integer:1]:=createRaysObject[Module[{initIndex},With[{rawData=Import[file,"Table"]},initIndex=FirstPosition[rawData,{"lt_startofdata"}][[1]];Table[{{centerPoint+{rawData[[i,3]],rawData[[i,1]],rawData[[i,2]]},{rawData[[i,6]],rawData[[i,4]],rawData[[i,5]]},rawData[[i,7]]}},{i,initIndex+1,Length[rawData],step}]]],wavelength]


(* ::Input::Initialization::Bold:: *)
drawRayFanUpToNextSurface[sz_,sr_,R_,vertex_,lensDiameter_?NumericQ,beamHalfAngle_?NumericQ,beamAngularResolution_]:=With[{rayEnds=Table[With[{\[CapitalDelta]z=1,\[CapitalDelta]r=Tan[\[Theta]]},findRaySphericalSurfaceIntersection[sz,sr,\[CapitalDelta]z,\[CapitalDelta]r,R,vertex]],{\[Theta],-beamHalfAngle,beamHalfAngle,beamAngularResolution}]},Show[Graphics[Table[If[Length[rayEnds[[i]]]>0,Line[{{sz,sr},rayEnds[[i]]}],{}],{i,1,Length[rayEnds]}]],drawSphericalSurface[vertex,R,lensDiameter]]]


(* ::Input::Initialization::Bold:: *)
(*if the ray coordinates are not floating points number, but exact (i.e. N[]) is removed*, then equations for aspherical lens that does not use FindRoot become slow*)createRayFan[wavelength_?NumericQ,sz_?NumericQ,sr_?NumericQ,beamHalfAngle_?NumericQ,rayAngularSpacing_?NumericQ]:=createRaysObject[N[ParallelTable[{{{sz,sr},{Cos[\[Theta]],Sin[\[Theta]]},1}},{\[Theta],-beamHalfAngle,beamHalfAngle,rayAngularSpacing}]],wavelength];


(* ::Input::Initialization::Bold:: *)
(*if the ray coordinates are not floating points number, but exact (i.e. N[]) is removed*, then equations for aspherical lens that does not use FindRoot become slow*)createRayFan[wavelength_?NumericQ,sz_?NumericQ,sr_?NumericQ,beamDirection_List,beamHalfAngle_?NumericQ,beamAngularSpacing_?NumericQ]:=With[{\[Theta]0=ArcTan[beamDirection[[1]],beamDirection[[2]]]},createRaysObject[N[Table[{{{sz,sr},{Cos[\[Theta]0+\[Theta]],Sin[\[Theta]0+\[Theta]]},1}},{\[Theta],-beamHalfAngle,beamHalfAngle,beamAngularSpacing}]],wavelength]];


(* ::Input::Initialization::Bold:: *)
(*if the ray coordinates are not floating points number, but exact (i.e. N[]) is removed*, then equations for aspherical lens that does not use FindRoot become slow*)createRegularlySpacedRayFansFromNonPointSource[wavelength_?NumericQ,vertex_?NumericQ,objectRRange_List,fanCount_Integer,beamHalfAngle_?NumericQ,beamAngularSpacing_?NumericQ]:=Which[fanCount>1,With[{spacing=(objectRRange[[2]]-objectRRange[[1]])/(fanCount-1)},N[ParallelTable[createRaysObject[With[{origin={vertex,objectRRange[[1]]+i*spacing}},Table[{{origin,{Cos[\[Theta]],Sin[\[Theta]]},1}},{\[Theta],-beamHalfAngle,beamHalfAngle,beamAngularSpacing}]],wavelength],{i,0,fanCount-1}]]],fanCount==1,{createRayFan[wavelength,vertex,(objectRRange[[2]]+objectRRange[[1]])/2,beamHalfAngle,beamAngularSpacing]},True,{}]


(* ::Input::Initialization::Bold:: *)
Options[createRegularlySpacedRayFansFromNonPointSource3D]={LimitingApertureAngularRadius->\[Infinity],(*Ray intensity function takes as an argument the unit vector, representing the direction of the ray, and returns the intensity assigned to ray*)RayIntensityFunction->(1&)};


(* ::Input::Initialization::Bold:: *)
(*if the ray coordinates are not floating points number, but exact (i.e. N[]) is removed*, then equations for aspherical lens that does not use FindRoot become slow*)createRegularlySpacedRayFansFromNonPointSource3D[wavelength_?NumericQ,vertex_?NumericQ,objectXRange_List,objectYRange_List,fanCountX_Integer,fanCountY_Integer,rangePolarAngle_List,rangeAzimuth_List,rayAngularSpacing_?NumericQ,opts:OptionsPattern[createRegularlySpacedRayFansFromNonPointSource3D]]:=Which[fanCountX==1&&fanCountY==1,N[With[{origin={vertex,(objectXRange[[1]]+objectXRange[[2]])/2,(objectYRange[[1]]+objectYRange[[2]])/2}},{createRayPyramidSquareBase[wavelength,origin,rangePolarAngle,rangeAzimuth,rayAngularSpacing,FilterRules[{opts},Options[createRegularlySpacedRayFansFromNonPointSource3D]]]}]],fanCountX==1,With[{spacingY=(objectYRange[[2]]-objectYRange[[1]])/(fanCountY-1)},N[Table[With[{origin={vertex,(objectXRange[[1]]+objectXRange[[2]])/2,objectYRange[[1]]+j*spacingY}},createRayPyramidSquareBase[wavelength,origin,rangePolarAngle,rangeAzimuth,rayAngularSpacing,FilterRules[{opts},Options[createRegularlySpacedRayFansFromNonPointSource3D]]]],{j,0,fanCountY-1}]]],fanCountY==1,With[{spacingX=(objectXRange[[2]]-objectXRange[[1]])/(fanCountX-1)},N[Table[With[{origin={vertex,objectXRange[[1]]+i*spacingX,(objectYRange[[1]]+objectYRange[[2]])/2}},createRayPyramidSquareBase[wavelength,origin,rangePolarAngle,rangeAzimuth,rayAngularSpacing,FilterRules[{opts},Options[createRegularlySpacedRayFansFromNonPointSource3D]]]],{i,0,fanCountX-1}]]],True,With[{spacingX=(objectXRange[[2]]-objectXRange[[1]])/(fanCountX-1),spacingY=(objectYRange[[2]]-objectYRange[[1]])/(fanCountY-1)},Flatten[N[Table[With[{origin={vertex,objectXRange[[1]]+i*spacingX,objectYRange[[1]]+j*spacingY}},createRayPyramidSquareBase[wavelength,origin,rangePolarAngle,rangeAzimuth,rayAngularSpacing,FilterRules[{opts},Options[createRegularlySpacedRayFansFromNonPointSource3D]]]],{j,0,fanCountY-1},{i,0,fanCountX-1}]],1]]]


(* ::Input::Initialization::Bold:: *)
createCollimatedBeam2D[wavelength_?NumericQ,centerPointAtBeamOrigin_List,beamDirection_List,beamRadius_?NumericQ,raySpacing_?NumericQ]:=With[{minZ=centerPointAtBeamOrigin[[1]],minR=centerPointAtBeamOrigin[[2]]-beamRadius},createRaysObject[ParallelTable[{{{minZ,r},beamDirection,1}},{r,minR,minR+2*beamRadius,raySpacing}],wavelength]]


(* ::Input::Initialization::Bold:: *)
createCollimatedBeam3D[wavelength_?NumericQ,centerPointAtBeamOrigin_List,beamDirection_List,beamRadius_?NumericQ,raySpacing_?NumericQ]:=With[{cz=centerPointAtBeamOrigin[[1]],cx=centerPointAtBeamOrigin[[2]],cy=centerPointAtBeamOrigin[[3]]},With[{xMin=cx-beamRadius,xMax=cx+beamRadius},createRaysObject[Flatten[N[Table[If[beamRadius>= Abs[y-cy],Table[{{{cz,x,y},beamDirection,1}},{x,Max[xMin+Ceiling[((cx-Sqrt[beamRadius^2-(y-cy)^2])-xMin)/raySpacing]*raySpacing,xMin],Min[xMin+Floor[((cx+Sqrt[beamRadius^2-(y-cy)^2])-xMin)/raySpacing]*raySpacing,xMax],raySpacing}],{}],{y,cy-beamRadius,cy+beamRadius,raySpacing}]],1],wavelength]]]


(* ::Input::Initialization::Bold:: *)
createCollimatedSheet[wavelength_?NumericQ,centerPointAtBeamOrigin_List,beamDirection_List,beamRadius_?NumericQ,raySpacing_?NumericQ]:=With[{minZ=centerPointAtBeamOrigin[[1]],minY=centerPointAtBeamOrigin[[2]]-beamRadius},createRaysObject[ParallelTable[{{{minZ,centerPointAtBeamOrigin[[2]],y},beamDirection,1}},{y,minY,minY+2*beamRadius,raySpacing}],wavelength]]


(* ::Input::Initialization::Bold:: *)
Options[createRayPyramidSquareBase]={LimitingApertureAngularRadius->\[Infinity],(*Ray intensity function takes as an argument the unit vector, representing the direction of the ray, and returns the intensity assigned to ray*)RayIntensityFunction->(1&)};


(* ::Input::Initialization::Bold:: *)
(*beam from a single point, rays azimuthal and polar angles sampled from a regular grid,cross-section rectangular*)createRayPyramidSquareBase[wavelength_?NumericQ,origin_List,rangePolarAngle_List,rangeAzimuth_List,angularSpacing_?NumericQ,opts:OptionsPattern[createRayPyramidHexagonalBase]]:=With[{rayIntensityFunction=OptionValue[RayIntensityFunction],apertureAngularRadius=OptionValue[LimitingApertureAngularRadius],polarRangeCenter =(rangePolarAngle[[2]]+rangePolarAngle[[1]])/2,azimuthRangeCenter =(rangeAzimuth[[2]]+rangeAzimuth[[1]])/2},createRaysObject[If[OptionValue[LimitingApertureAngularRadius]>Sqrt[1/4 (rangePolarAngle[[2]]-rangePolarAngle[[1]])^2+1/4 (rangeAzimuth[[2]]-rangeAzimuth[[1]])^2],Flatten[N[Table[With[{dir={Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]}},{{origin,dir,rayIntensityFunction[dir]}}],{\[Phi],rangeAzimuth[[1]],rangeAzimuth[[2]],angularSpacing},{\[Theta],rangePolarAngle[[1]],rangePolarAngle[[2]],angularSpacing}]],1],Flatten[N[Table[If[apertureAngularRadius>= Abs[(\[Theta]-polarRangeCenter)] ,Table[With[{dir={Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]}},{{origin,dir,rayIntensityFunction[dir]}}],{\[Phi],Max[rangeAzimuth[[1]]+Ceiling[((azimuthRangeCenter-Sqrt[apertureAngularRadius^2-(\[Theta]-polarRangeCenter)^2])-rangeAzimuth[[1]])/angularSpacing]*angularSpacing,rangeAzimuth[[1]]],Min[rangeAzimuth[[1]]+Floor[((azimuthRangeCenter+Sqrt[apertureAngularRadius^2-(\[Theta]-polarRangeCenter)^2])-rangeAzimuth[[1]])/angularSpacing]*angularSpacing,rangeAzimuth[[2]]],angularSpacing}],{}],{\[Theta],rangePolarAngle[[1]],rangePolarAngle[[2]],angularSpacing}]],1]],wavelength]]


(* ::Input::Initialization::Bold:: *)
Options[createRayBeamRandomEllipsoidalCrossSection]={(*Ray intensity function takes as an argument the unit vector, representing the direction of the ray, and returns the intensity assigned to ray*)RayIntensityFunction->(1&)};


(* ::Input::Initialization::Bold:: *)
(*beam from a single point, rays azimuthal and polar angles sampled randomly within a an ellipse*)createRayBeamRandomEllipsoidalCrossSection[wavelength_?NumericQ,origin_List,rangePolarAngle_List,rangeAzimuth_List,rayCount_Integer,opts:OptionsPattern[createRayBeamRandomEllipsoidalCrossSection]]:=With[{polarRangeCenter =(rangePolarAngle[[2]]+rangePolarAngle[[1]])/2,azimuthRangeCenter =(rangeAzimuth[[2]]+rangeAzimuth[[1]])/2,polarSemiaxisLength=(rangePolarAngle[[2]]-rangePolarAngle[[1]])/2,azimuthSemiaxisLength=(rangeAzimuth[[2]]-rangeAzimuth[[1]])/2,rayIntensityFunction=OptionValue[RayIntensityFunction]},With[{points=RandomPoint[Disk[{azimuthRangeCenter,polarRangeCenter},{azimuthSemiaxisLength,polarSemiaxisLength}],rayCount]},createRaysObject[Table[With[{\[Phi]=points[[i,1]],\[Theta]=points[[i,2]]},With[{dir={Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]}},{{origin,dir,rayIntensityFunction[dir]}}]],{i,1,Length[points]}],wavelength]]]


(* ::Input::Initialization::Bold:: *)
Options[createRayBeamRandomRectangularCrossSection]={(*Ray intensity function takes as an argument the unit vector, representing the direction of the ray, and returns the intensity assigned to ray*)RayIntensityFunction->(1&),IndependentSamplingIntervalCountAzimuth->1,IndependentSamplingIntervalCountPolar->1,LimitingApertureAngularRadius->\[Infinity]};


(* ::Input::Initialization::Bold:: *)
createRayBeamRandomRectangularCrossSection[wavelength_?NumericQ,origin_List,rangePolarAngle_List,rangeAzimuth_List,rayCount_Integer,opts:OptionsPattern[createRayBeamRandomRectangularCrossSection]]:=With[{intervalCountAzimuth=OptionValue[IndependentSamplingIntervalCountAzimuth],intervalCountPolar=OptionValue[IndependentSamplingIntervalCountPolar],azimuthRangeCenter =(rangeAzimuth[[2]]+rangeAzimuth[[1]])/2,polarRangeCenter =(rangePolarAngle[[2]]+rangePolarAngle[[1]])/2,polarAxisLength=rangePolarAngle[[2]]-rangePolarAngle[[1]],azimuthAxisLength=rangeAzimuth[[2]]-rangeAzimuth[[1]],apertureAngularRadius=OptionValue[LimitingApertureAngularRadius],rayIntensityFunction=OptionValue[RayIntensityFunction]},createRaysObject[With[{points=If[intervalCountAzimuth>1||intervalCountPolar>1,With[{subDivisionSideAzimuth=azimuthAxisLength/intervalCountAzimuth,subDivisionSidePolar=polarAxisLength/intervalCountPolar},Flatten[Table[RandomPoint[Rectangle[{rangeAzimuth[[1]]+j*subDivisionSideAzimuth,rangePolarAngle[[1]]+i*subDivisionSidePolar},{rangeAzimuth[[1]]+(j+1)*subDivisionSideAzimuth,rangePolarAngle[[1]]+(i+1)*subDivisionSidePolar}],Round[rayCount/(intervalCountAzimuth*intervalCountPolar)]],{j,0,intervalCountAzimuth-1},{i,0,intervalCountPolar-1}],2]],RandomPoint[Rectangle[{rangeAzimuth[[1]],rangePolarAngle[[1]]},{rangeAzimuth[[2]],rangePolarAngle[[2]]}],rayCount]]},With[{pointsInCircle=If[apertureAngularRadius>Sqrt[1/4 (rangePolarAngle[[2]]-rangePolarAngle[[1]])^2+1/4 (rangeAzimuth[[2]]-rangeAzimuth[[1]])^2],points,With[{rmf=RegionMember[Disk[{azimuthRangeCenter,polarRangeCenter},apertureAngularRadius]]},Select[points,(rmf[#]&)]]]},Table[With[{\[Phi]=pointsInCircle[[i,1]],\[Theta]=pointsInCircle[[i,2]]},With[{dir={Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]}},{{origin,dir,rayIntensityFunction[dir]}}]],{i,1,Length[pointsInCircle]}]]],wavelength]]


(* ::Input::Initialization::Bold:: *)
Options[createRayPyramidHexagonalBase]={LimitingApertureAngularRadius->\[Infinity],(*Ray intensity function takes as an argument the unit vector, representing the direction of the ray, and returns the intensity assigned to ray*)RayIntensityFunction->(1&)};


(* ::Input::Initialization::Bold:: *)
(*beam from a single point, rays azimuthal and polar angles sampled from a hexagonal grid, cross-section hexagonal*)createRayPyramidHexagonalBase[wavelength_?NumericQ,origin_List,rangePolarAngle_List,rangeAzimuth_List,angularSpacing_?NumericQ,opts:OptionsPattern[createRayPyramidHexagonalBase]]:=createRaysObject[N[With[{rayIntensityFunction=OptionValue[RayIntensityFunction],apertureAngularRadius =OptionValue[LimitingApertureAngularRadius],polarRangeCenter =(rangePolarAngle[[2]]+rangePolarAngle[[1]])/2,azimuthRangeCenter =(rangeAzimuth[[2]]+rangeAzimuth[[1]])/2},If[apertureAngularRadius>= (rangePolarAngle[[2]]-rangePolarAngle[[1]])/2&&apertureAngularRadius>= (rangeAzimuth[[2]]-rangeAzimuth[[1]])/2,Flatten[Join[Table[With[{\[Theta]=(rangePolarAngle[[2]]+rangePolarAngle[[1]])/2-j*Sqrt[3]/2*angularSpacing},Table[With[{dir={Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]}},{{origin,dir,rayIntensityFunction[dir]}}],{\[Phi],rangeAzimuth[[1]]+j*angularSpacing/2,rangeAzimuth[[2]]-j*angularSpacing/2,angularSpacing}]],{j,0,Round[(rangePolarAngle[[2]]-rangePolarAngle[[1]])/(2 Sin[60Degree]*angularSpacing)],1}],Table[With[{\[Theta]=polarRangeCenter+j*Sqrt[3]/2*angularSpacing},Table[With[{dir={Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]}},{{origin,dir,rayIntensityFunction[dir]}}],{\[Phi],rangeAzimuth[[1]]+j*angularSpacing/2,rangeAzimuth[[2]]-j*angularSpacing/2,angularSpacing}]],{j,0,Round[(rangePolarAngle[[2]]-rangePolarAngle[[1]])/(2 Sin[60Degree]*angularSpacing)],1}]],1],With[{rays=Flatten[Join[Table[With[{\[Theta]=polarRangeCenter-j*Sqrt[3]/2*angularSpacing},Table[If[Sqrt[(\[Phi]-azimuthRangeCenter)^2+(\[Theta]-polarRangeCenter)^2]<= apertureAngularRadius,{{origin,{Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]},1}},Null],{\[Phi],rangeAzimuth[[1]]+j*angularSpacing/2,rangeAzimuth[[2]]-j*angularSpacing/2,angularSpacing}]],{j,0,Round[(rangePolarAngle[[2]]-rangePolarAngle[[1]])/(2 Sin[60Degree]*angularSpacing)],1}],Table[With[{\[Theta]=polarRangeCenter+j*Sqrt[3]/2*angularSpacing},Table[If[Sqrt[(\[Phi]-azimuthRangeCenter)^2+(\[Theta]-polarRangeCenter)^2]<= apertureAngularRadius,{{origin,{Sin[\[Theta]]Cos[\[Phi]],Sin[\[Theta]]Sin[\[Phi]],Cos[\[Theta]]},1}},Null],{\[Phi],rangeAzimuth[[1]]+j*angularSpacing/2,rangeAzimuth[[2]]-j*angularSpacing/2,angularSpacing}]],{j,0,Round[(rangePolarAngle[[2]]-rangePolarAngle[[1]])/(2 Sin[60Degree]*angularSpacing)],1}]],1]},Select[rays,(#=!=Null)&]]]]],wavelength]


(* ::Subsubsection::Bold:: *)
(*RAY DISTRIBUTION ANALYSIS*)


(* ::Input::Initialization::Bold:: *)
getIncidencePointsOfRaysOnScreen[rays_List]:=If[Length[rays]==0,{},If[AssociationQ[rays[[1]]],Flatten[Table[getIncidencePointsOfRaysOnScreen[rays[[i]]],{i,1,Length[rays]}],1],Map[{#1[[-1,1,2]],#1[[-1,1,3]]}&,rays]]]


(* ::Input::Initialization::Bold:: *)
getIncidencePointsOfRaysOnScreen[raysObject_Association]:=With[{rays=raysObject["traces"]},getIncidencePointsOfRaysOnScreen[rays]]


(* ::Input::Initialization::Bold:: *)
partitionRaysIncidentOnScreenIntoRectangularGrid[rays_List,screenIndex_Integer,gridCenter_List,spacingX_?NumericQ,spacingY_?NumericQ]:=GatherBy[Select[rays,((Length[#]>= screenIndex&&#[[screenIndex,1]]=!=Null)&)],{Round[(#1[[screenIndex,1,2]]-gridCenter[[1]])/spacingX],Round[(#1[[screenIndex,1,3]]-gridCenter[[2]])/spacingY]}&]  


(* ::Input::Initialization::Bold:: *)
partitionRaysIncidentOnScreenIntoRectangularGrid[raysObject_Association,screenIndex_Integer,gridCenter_List,spacingX_?NumericQ,spacingY_?NumericQ]:=With[{rays=raysObject["traces"]},partitionRaysIncidentOnScreenIntoRectangularGrid[rays,screenIndex,gridCenter,spacingX,spacingY]]


(* ::Input::Initialization::Bold:: *)
partitionRaysIncidentOnScreenRectangularGridTally[rays_List,screenIndex_,gridCenter_,spacingX_?NumericQ,spacingY_?NumericQ]:=With[{partitioned=partitionRaysIncidentOnScreenIntoRectangularGrid[rays,screenIndex,gridCenter,spacingX,spacingY]},ParallelMap[{Round[(#[[1,screenIndex,1,2]]-gridCenter[[1]])/spacingX] spacingX,Floor[(#[[1,screenIndex,1,3]]-gridCenter[[2]])/spacingY] spacingY,Sum[#[[j,screenIndex,3]],{j,1,Length[#]}]}&,partitioned]] 


(* ::Input::Initialization::Bold:: *)
partitionRaysIncidentOnScreenRectangularGridTally[raysObject_Association,gridCenter_List,spacingX_?NumericQ,spacingY_?NumericQ]:=With[{rays=raysObject["traces"]},partitionRaysIncidentOnScreenRectangularGridTally[rays,gridCenter,spacingX,spacingY]]


(* ::Input::Initialization::Bold:: *)
partitionRaysIncidentOnScreenIntoCircularBands[rays_List,screenIndex_Integer,center_List,spacingR_?NumericQ]:=With[{raysAll=If[Length[rays]>0&&AssociationQ[rays[[1]]],Flatten[Table[(rays[[i]])["traces"],{i,1,Length[rays]}],1],rays]},GatherBy[Select[raysAll,((Length[#]>= screenIndex&&#[[screenIndex,1]]=!=Null)&)],(Floor[Sqrt[(#[[screenIndex,1,2]]-center[[1]])^2+(#[[screenIndex,1,3]]-center[[2]])^2]/spacingR]&)]]


(* ::Input::Initialization::Bold:: *)
partitionRaysIncidentOnScreenIntoCircularBands[raysObject_Association,screenIndex_,center_,spacingR_]:=With[{rays=raysObject["traces"]},partitionRaysIncidentOnScreenIntoCircularBands[rays,screenIndex,center,spacingR]]


(* ::Input::Initialization::Bold:: *)
partitionRaysIncidentOnScreenIntoCircularBandsTally[rays_List,screenIndex_Integer,center_List,spacingR_?NumericQ]:=With[{partitioned=partitionRaysIncidentOnScreenIntoCircularBands[rays,screenIndex,center,spacingR]},With[{tallies=ParallelMap[With[{bandIndex=Floor[Sqrt[(#[[1,screenIndex,1,2]]-center[[1]])^2+(#[[1,screenIndex,1,3]]-center[[2]])^2]/spacingR]},{ bandIndex*spacingR,Sum[#[[j,screenIndex,3]],{j,1,Length[#]}]/(\[Pi]*(spacingR*(bandIndex+1) )^2- \[Pi]*(spacingR*bandIndex )^2)}]&,partitioned]},SortBy[tallies,(#[[1]]&)]]]


(* ::Input::Initialization::Bold:: *)
calculateDistributionOfIntensityOnScreenInGrid[rays_List,gridCenter_List,spacingX_?NumericQ,spacingY_?NumericQ]:=With[{partitioned = GatherBy[Select[rays,((#[[-1,1]]=!=Null)&)],(({Round[(#[[-1,1,2]]-gridCenter[[1]])/spacingX],Round[(#[[-1,1,3]]-gridCenter[[2]])/spacingY]})&)]},Table[{Round[(partitioned[[i,1,-1,1,2]]-gridCenter[[1]])/spacingX]*spacingX,Floor[(partitioned[[i,1,-1,1,3]]-gridCenter[[2]])/spacingY]*spacingY,Sum[partitioned[[i,j,-1,3]],{j,1,Length[partitioned[[i]]]}]},{i,1,Length[partitioned]}]]


(* ::Input::Initialization::Bold:: *)
calculateDistributionOfIntensityOnScreenInGrid[raysObject_Association,gridCenter_List,spacingX_?NumericQ,spacingY_?NumericQ]:=With[{rays=raysObject["traces"]},calculateDistributionOfIntensityOnScreenInGrid[rays,gridCenter,spacingX,spacingY]]


(* ::Input::Initialization::Bold:: *)
getRMS[data_List,maxR_?NumericQ]:=With[{dataSelected=Select[data,(#[[1]]<=maxR)&]},With[{binnedIntensities=Map[#[[2]]&,dataSelected]},With[{sd=StandardDeviation[binnedIntensities],mean=Mean[binnedIntensities]},Association["SD"->sd,"Relative SD"->sd/mean,"Mean"->mean]]]]


(* ::Code::Initialization::Bold:: *)
End[];


(* ::Code::Initialization::Bold:: *)
EndPackage[]
